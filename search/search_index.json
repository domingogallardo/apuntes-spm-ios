{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de la asignatura \"Servicios de las Plataformas M\u00f3viles (iOS)\" del Master en Desarrollo de Software para Dispositivos M\u00f3viles. Despliega el men\u00fa de la izquierda para consultar los apuntes.","title":"Home"},{"location":"sesion00/sesion00-introduccion.html","text":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS Planificaci\u00f3n Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App Entregas de pr\u00e1cticas Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: una semana despu\u00e9s del final de la asignatura (7 de junio) Recomendable realizar los ejercicios semana a semana Recursos En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App","title":"Introducci\u00f3n"},{"location":"sesion00/sesion00-introduccion.html#sesion-0-planificacion-bloque-ios","text":"","title":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS"},{"location":"sesion00/sesion00-introduccion.html#planificacion","text":"Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App","title":"Planificaci\u00f3n"},{"location":"sesion00/sesion00-introduccion.html#entregas-de-practicas","text":"Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: una semana despu\u00e9s del final de la asignatura (7 de junio) Recomendable realizar los ejercicios semana a semana","title":"Entregas de pr\u00e1cticas"},{"location":"sesion00/sesion00-introduccion.html#recursos","text":"En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App","title":"Recursos"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html","text":"Sesi\u00f3n 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Introducci\u00f3n En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps de iOS usando Test Flight y App Store Connect. Seguridad en las apps La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable. Cuenta de desarrollador de Apple Distintos programas de desarrollo Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el member center de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ : Cuenta de desarrollador Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder a la cuenta de desarrollador , en la que podremos gestionar numerosos elementos que veremos durante el curso. Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store. Equipo de desarrollo En todos los programas de pago de desarrollador de Apple, incluso en los programas individuales, es posible trabajar con un equipo de desarrolladores. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership de la cuenta de desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight. Demo Veremos una demostraci\u00f3n en la que accederemos a la cuenta de desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es) Certificados C\u00f3digo firmado Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma. Identidad de firma Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en la cuenta de desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador. Tipos de certificados Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el member center , Xcode o Acceso a llaveros . Gesti\u00f3n de los certificados en Xcode Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra las dos identidades y nos permite utilizar la que nos interese en cada momento. Creaci\u00f3n e instalaci\u00f3n de certificados Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se descarga de los servidores de Apple e instala autom\u00e1ticamente el certificados de firma. Ejecuci\u00f3n de apps en dispositivos reales Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) correcto que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store. Demo Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode. Instalaci\u00f3n de la identidad de firma Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito. Firma de una app Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app. App ejemplo ToDoList Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Podemos descargar la app de esta direcci\u00f3n y probar a ejecutarla en el simulador. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador. Comprobaci\u00f3n del certificado En la pantalla de Xcode Preferences... Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode . Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros En la aplicaci\u00f3n Acceso a Llaveros y podemos comprobar que se ha instalado el certificado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n . Conexi\u00f3n de un dispositivo real a Xcode Conectamos un dispositivo iOS real al ordenador. En Xcode seleccionamos Window Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo. Prueba en un dispositivo real Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica. Autorizaci\u00f3n al desarrollador en el dispositivo Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app. Archivo y distribuci\u00f3n de la app Seleccionando la opci\u00f3n de Xcode Product Archive se accede al panel de archivo y distribuci\u00f3n de la app La opci\u00f3n de exportar la app est\u00e1 deshabilitado por que estamos registrados con el programa gratuito. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Despliegue de apps en dispositivos de prueba Capacidades de las apps Para poder utilizar servicios avanzados proporcionados por Apple en las apps (como notificaciones push, iCloud o Game Center) es necesario darse de alta de forma individual en el programa de desarrollo de iOS o formar parte de un equipo de desarrollo. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer Support Advanced App Capabilities . Con el programa de desarrollo de la Universidad podemos acceder a m\u00e1s servicios que a los gratuitos, pero no a todos los servicios disponibles. La lista de servicios accesibles son los siguientes: Permisos para las apps Un permiso ( entitlement ) es un elemento de configuraci\u00f3n incluido en la firma digital de la app que le indica al sistema que permita a la app acceder a ciertos recursos o realizar ciertas operaciones. La forma de otorgar los permisos a una app es algo elaborada, para permitir una configuraci\u00f3n flexible y no atar los permisos a una \u00fanica app. El responsable de la cuenta de desarrollador debe crear un identificador denominado App ID y otorgar los permisos a ese identificador. Bundle Identifier Un bundle ID identifica de forma \u00fanica una app. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). La cadena deber\u00eda estar en un formato DNS-inverso y usar un dominio propio de la organizaci\u00f3n. De esta forma se garantiza su unicidad. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hello . Uso del Bundle ID Se utiliza durante el desarrollo para aprovisionar dispositivos y por el sistema operativo cuando la app se distribuye a los clientes. Por ejemplo, los servicios de Game Center o de compras In-App usan el bundle ID para identificar la app cuando utilizan estos servicios. App ID El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el member center . Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con permiso de acceso a iCloud y todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que permite que una o m\u00e1s apps desarrolladas por el equipo accedan a los permisos otorgados. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del APP ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha. Gesti\u00f3n de las capacidades en Xcode En Xcode se deben indicar las capacidades que necesita la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Capabilities . Dependiendo del programa de desarrollo en el que estemos tendremos m\u00e1s o menos capacidades disponibles. Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el member center alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores. Aprovisionamiento de apps Es necesario configurar un perfil de aprovisionamiento para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push) y para configurar dispositivos de prueba en los que podamos ejecutar la app. Con la cuenta de desarrollador gratuita es posible desarrollar aplicaciones, acceder a un n\u00famero limitado de servicios de Apple y probarlas configurando el dispositivo propio como un dispositivo de desarrollo. Pero es una forma muy limitada de prueba porque es necesario conectar f\u00edsicamente el dispositivo al ordenador en el que est\u00e1 Xcode. Es posible ejecutar apps en dispositivos de prueba sin tener que configurarlos como dispositivos de desarrollo usando perfiles de aprovisionamiento . Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad. Distribuci\u00f3n de apps La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran. Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Como ya hemos dicho, Apple permite ejecutar apps en dispositivos registrados mediante el uso de perfiles de aprovisionamiento . Apple tambi\u00e9n permite distribuir una app de forma restringida, s\u00f3lo a los dispositivos particulares de los empleados de una empresa. Para ello es necesario darse de alta en el Apple Developer Enterprise Program y utilizar tambi\u00e9n el perfil de aprovisionamiento apropiado. Perfil de aprovisionamiento Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio ~Library/MobileDevice/Provisioning Profiles . Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode. Es posible consultar su contenido desde el terminal con el comando: 1 security cms -D -i perfil .mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder: Dispositivos de prueba en el perfil de aprovisionamiento El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento ( provisioning profile ) y los permisos ( entitlements ) se usa para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store . Instalaci\u00f3n de la app en un dispositivo de prueba Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. Contiene funcionalidades que se han extra\u00eddo de iTunes. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado. Ejecuci\u00f3n de apps en dispositivos no registrados Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple. Certificados de empresa Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house . Demo Resumen del flujo de trabajo Es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Los dispositivos que se usan para el desarrollo deben ser registrados y a\u00f1adidos en el perfil de aprovisionamiento que uses para firmar la app. Si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode (es lo recomendado), Xcode crea estos elementos de forma autom\u00e1tica. Si perteneces a un equipo, algunos de estos permisos deben ser configurados por el administrador del equipo en la web de desarrollador de Apple. Pasos a seguir: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba. Equipo de desarrollo del programa de Universidad La mayor\u00eda de opciones en el member center ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde el member center o desde Xcode. Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el member center o en la aplicaci\u00f3n de Acceso a llaveros: Firma de la app con el nuevo certificado Para firmar la app con el nuevo certificado dejamos marcada la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma. Seleccionamos el team Universidad de Alicante. Aparecen los siguientes errores porque Xcode no puede realizar autom\u00e1ticamente las actualizaciones que necesita: La cuenta no tiene permisos suficientes para crear un perfil de aprovisionamiento. No existe perfil de aprovisionamiento aplicable al bundle ID de la app. Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el member center e incorporar en ese perfil el certificado del desarrollador. Examinamos los perfiles de aprovisionamiento Podemos examinar los perfiles de aprovisionamiento desde el Member Center o desde Xcode y el terminal En el Member Center tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento. Men\u00fa de opciones Contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps Creaci\u00f3n un App ID desde Member Center S\u00f3lo se puede hacer con el rol administrador. Dispositivos Para a\u00f1adir un dispositivo a un certificado de aprovisionamiento hay que a\u00f1adir su UDID, Unique Device Identifier . Cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9). Desde Xcode se puede obtener en la pantalla de Dispositivos ( Window Devices ). Se pueden registrar en el Member Center hasta 200 UDIDs para probar aplicaciones en desarrollo. Creaci\u00f3n de perfiles de aprovisionamento Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el Member Center y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde Member Center , ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n. Nuevo perfil de aprovisionamiento desde Member Center Firma de la app ToDoList con el perfil de aprovisionamiento creado Una vez creado el perfil de aprovisionamiento ya es posible aplicarlo a la app. Basta con definir un bundle ID compatible con el App ID definido en el perfil. En este caso, al haber definido un App ID \u00fanico (sin el * ) se define como bundle ID el mismo. El perfil de aprovisionamiento correspondiente se descarga autom\u00e1ticamente. Selecci\u00f3n manual del perfil de aprovisionamiento Es posible seleccionar manualmente un perfil de aprovisionamiento del member center eliminando la opci\u00f3n de Xcode de gesti\u00f3n autom\u00e1tica de la firma. Capabilities El perfil de aprovisionamiento que hemos creado permite 3 capabilities: Game Center In-App Purchase Keychain Sharing Es posible activar cualquiera de estos servicios en la app, en el men\u00fa Capabilities . Ahora este men\u00fa muestra m\u00e1s servicios posibles, al pertenecer al equipo de la UA: Activaci\u00f3n del permiso de Game Center Si se activa el permiso de Game Center Xcode se asegurar\u00e1 e que el perfil de aprovisionamiento seleccionado proporcione este permiso. Si no es as\u00ed aparecer\u00e1 un error y el bot\u00f3n Fix Issue. Es posible comprobar el error si se intenta activar el permiso Push Notificacions . Xcode puede arreglar el error creando un nuevo perfil de aprovisionamiento y subi\u00e9ndolo al Member Center . Para ello hay que tener permisos apropiados en la cuenta de desarrollador (ser un administrador del equipo en el caso de una organizaci\u00f3n o el propietario del equipo en el caso de un programa de desarrollo). Exportar la app Seleccionando en Xcode la opci\u00f3n Product Archive ahora ya est\u00e1 activa la opci\u00f3n Export Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Tarda un buen rato en generar el fichero ipa ( iOS App file ). El fichero generado es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento. Instalaci\u00f3n y ejecuci\u00f3n de la app Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2. Distribuci\u00f3n e instalaci\u00f3n de betas online Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple (lo veremos m\u00e1s adelante). Pero este servicio s\u00f3lo est\u00e1 disponible para apps enviadas al App Store. Es necesario para ello una cuenta de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Es lo que se consigue con servicios como el que vamos a ver: Fabric. Fabric Fabric es una plataforma y API que permite una gran cantidad de funcionalidades: distribuci\u00f3n, recopilaci\u00f3n de datos de crashes, recopilaci\u00f3n de estad\u00edsticas de uso, etc. Se trata de una plataforma creada por Twitter y comprada por Google en enero de 2017. Se puede acceder desde esta URL . En este a\u00f1o 2019 Google realizar\u00e1 la integraci\u00f3n del servicio en Firebase. Demo Alta y descarga de Fabric Debemos registrarnos en Fabric con nuestro correo electr\u00f3nico y nuestro nombre. Escribimos como nombre de la organizaci\u00f3n nuestro propio nombre. Hay entrar en el dashboard y descargar e instalar la aplicaci\u00f3n para Mac, movi\u00e9ndola a la carpeta de Aplicaciones. La \u00faltima versi\u00f3n es la 2.7.5. Una vez descargada, hay que registrarse en la aplicaci\u00f3n en ella con la misma cuenta y contrase\u00f1a que en la web. Instalaci\u00f3n de Fabric La aplicaci\u00f3n Fabric nos gu\u00eda paso a paso: Debemos seleccionar el proyecto XCode y a\u00f1adir un Run Script Build Phase . Se selecciona en Xcode Build Phases y en el s\u00edmbolo + se selecciona New Run Script Build Phase . En la opci\u00f3n Run Script se pega el c\u00f3digo que aparece en la aplicaci\u00f3n. Compilamos la aplicaci\u00f3n con la opci\u00f3n Product Build . Se instala el SDK Kit en el proyecto, arrastrando desde la aplicaci\u00f3n al proyecto. Debemos copiar el c\u00f3digo indicado en el fichero AppDelegate.swift . Y volvemos a compilar la aplicaci\u00f3n y la ejecutamos en el simulador. La aplicaci\u00f3n de Fabric detectar\u00e1 que la hemos lanzado y aparecer\u00e1 una pantalla indicando que todo ha ido correctamente. Tambi\u00e9n recibiremos un correo electr\u00f3nico indicando que la app ya se ha subido y est\u00e1 disponible para su distribuci\u00f3n. Distribuci\u00f3n a probadores Debemos seleccionar en Xcode la opci\u00f3n de Product Archive . Cuidado Recuerda que para habilitar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Autom\u00e1ticamente la app aparecer\u00e1 en la aplicaci\u00f3n de Fabric. Podremos activar la distribuci\u00f3n, a\u00f1adiendo los correos electr\u00f3nicos de las personas a las que se les enviar\u00e1. Si el UUID del dispositivo del probador est\u00e1 incluido en el perfil de aprovisionamiento podr\u00e1 ejecutar la app sin problemas. Si no, Fabric obtendr\u00e1 el UUID y nos lo proporcionar\u00e1 para que actualicemos el perfil de aprovisionamiento. Ejecuci\u00f3n de la app por el probador El probador recibe un e-mail que le dirige a una p\u00e1gina web desde la que debe instalar un perfil (que ser\u00e1 el que permitir\u00e1 leer el UUID del dispositivo y comprobar si est\u00e1 incluido en el perfil de aprovisionamiento instalado en la app que se distribuye). Si el dispositivo puede ejecutar la app aparecer\u00e1 un bot\u00f3n para instalarla. La forma de instalarla ser\u00e1 tan sencilla como pulsar ese bot\u00f3n (no hay necesidad de usar iTunes ni Xcode). Si el dispositivo no puede ejecutar la app, aparecer\u00e1 un mensaje indic\u00e1ndolo y nos informar\u00e1 del UUID. Dashboard de Fabric En el dashboard ( https:/fabric.io ) podemos acceder a estad\u00edsticas de descargas e instalaciones, informaci\u00f3n sobre los crashes de nuestra apps, etc. Tambi\u00e9n podemos invitar nuevos probadores y crear un enlace desde el que es posible instalar la app. Cuando se pulsa en el enlace se accede a una p\u00e1gina en la que se pide el e-mail de la persona que va a probar la app. Test Flight Distribuci\u00f3n de apps El proceso de distribuci\u00f3n de apps en el App Store es el siguiente: App Store Connect App Store Connect es el servicio de Apple con el que los desarrolladores pueden organizar: Todas sus apps para poder enviar a prueba versiones beta y subirlas al App Store. Toda la informaci\u00f3n legal y de impuestos. Informaci\u00f3n sobre el estado de los productos, retroalimentaci\u00f3n e informaci\u00f3n de descargas, ventas y ganancias. La plataforma est\u00e1 accesible desde el member center en los programas de pago. No est\u00e1 disponible en el programa de universidad. Tambi\u00e9n se puede acceder desde la URL https://appstoreconnect.apple.com . Nota Hasta el a\u00f1o pasado (2018) iTunes Connect era la plataforma \u00fanica a la que se sub\u00edan todos los productos para su distribuci\u00f3n (apps, ebooks, podcasts, m\u00fasica). A mediados del 2018 Apple divide en dos esa plataforma, creando App Store Connect para gestionar \u00fanicamente apps. Hemos conservado algunas im\u00e1gnes del curso pasado en el caso en sean muy similares a las actuales. En estas im\u00e1genes aparece la cabecera iTunes Connect en lugar de App Store Connect . Pasos para subir una app al App Store desde App Store Connect Crear un registro en App Store Connect, un identificador \u00fanico para el app. Subir una compilaci\u00f3n de la app. Pruebas Beta: probar la app con usuarios de la organizaci\u00f3n o usuarios invitados, usando Test Flight . Completar toda la informaci\u00f3n y enviar la app a revisi\u00f3n de la App Store. Una vez que ha superado la revisi\u00f3n, la app se pone a la venta en la App Store. Analizar anal\u00edticas de la app (de ventas, de uso, etc.) y desarrollar una nueva versi\u00f3n. A\u00f1adir informaci\u00f3n de la App Antes de subir una app a App Store Connect, hay que crear un registro de la misma indicando un identificador \u00fanico (SKU) que puede ser el propio bundle ID y seleccionando el App ID. Subir una compilaci\u00f3n de la app La forma m\u00e1s sencilla de subir una app a App Store Connect es utilizando Xcode. Debes crear un archivo ipa con la opci\u00f3n Product Archive y seleccionar la opci\u00f3n Upload to App Store . Es posible subir distintos builds y gestionarlos todos desde App Store Connect. El identificador de la app es su bundle id . Dise\u00f1o de la p\u00e1gina en el App Store En el App Store se muestra distinta informaci\u00f3n sobre la app. Es importante dise\u00f1ar bien esta p\u00e1gina para que sea atractiva para los usuarios y est\u00e9n interesados en descargar la app. App Store Connect se usa para gestionar estos los elementos necesarios para crear la p\u00e1gina de la app en el App Store: nombre de la App, iconos, previsualizaciones (pantallas y v\u00eddeos), descripci\u00f3n, novedades, palabras claves y categor\u00edas. Nuevos usuarios App Store Connect Es posible a\u00f1adir usuarios a la cuenta de App Store Connect. Son usuarios que van a poder trabajar con las apps subidas, realizando funciones limitadas por su funci\u00f3n. No es necesario tener una cuenta de organizaci\u00f3n para poder a\u00f1adir usuarios colaboradores en App Store Connect. Es posible en cuentas de desarrollador individual. Los usuarios a\u00f1adidos podr\u00e1n ser probadores internos en TestFlight. TestFlight TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos. Aprobaci\u00f3n de pruebas externas Una vez subida a App Store Connect la app entra autom\u00e1ticamente en un proceso de aprobaci\u00f3n para que se pueda distribuir externamente una versi\u00f3n beta en TestFlight. La aprobaci\u00f3n suele tardar menos de 1 d\u00eda la primera compilaci\u00f3n y ser casi instant\u00e1nea cada nueva compilaci\u00f3n que se sube. No es necesaria aprobaci\u00f3n para la distribuci\u00f3n de pruebas internas. TestFlight en App Store Connect Demo Vamos a comprobar el funcionamiento de TestFlight, subiendo la app ToDoList, a\u00f1adiendo probadores y comprobando la instalaci\u00f3n de la app en los probadores. Registro de una app en App Store Connect Registramos la app en App Store Connect. Subida a App Store Connect con Xcode Una vez creado el registro de la app ya es posible subirla desde Xcode. Compilaciones listas para probar Una vez que se ha subido a App Store Connect y ha pasado un tiempo necesario para que la plataforma prueba que la app puede ser distribuida para pruebas, aparecer\u00e1 con un indicador verde lista para probar. Los n\u00fameros de versi\u00f3n y de compilaci\u00f3n ( build ) son los definidos en Xcode. Ahora la app est\u00e1 lista para que sea probada por los usuarios de prueba internos. Podemos seleccionar la compilaci\u00f3n a distribuir. A\u00f1adir probadores externos y enlace de prueba Podemos tambi\u00e9n a\u00f1adir usuarios de prueba externos y un enlace de prueba que puede ser usado por cualquiera. Para ello es necesario crear un grupo de prueba y volver a solicitar una autorizaci\u00f3n de env\u00edo a pruebas de la app. Debe pasar un tiempo para App Store Connect apruebe la distribuci\u00f3n de prueba. Mientras tanto la compilaci\u00f3n seleccionada aparecer\u00e1 en estado Pendiente de revisi\u00f3n . Una vez aprobada la distribuci\u00f3n es posible crear un enlace para que cualquiera la pueda instalar y probar. TestFlight en los usuarios Los usuarios de prueba reciben un correo avis\u00e1ndoles de que la beta est\u00e1 disponible. Deben instalar la app TestFlight y en la app aparecer\u00e1 un bot\u00f3n que permitir\u00e1 instalar la app en el dispositivo. En este caso no es necesario que el dispositivo est\u00e9 en la lista incluida en el perfil de aprovisionamiento, porque la app est\u00e1 autorizada por Apple para su ejecuci\u00f3n en cualquier dispositivo. Nuevas compilaciones Cuando subimos desde Xcode una nueva compilaci\u00f3n, debemos entrar en el enlace de la compilaci\u00f3n para activar la nueva prueba. TestFlight enviar\u00e1 una notificaci\u00f3n autom\u00e1ticamente a todos los usuarios para que descarguen la nueva versi\u00f3n. Pr\u00e1cticas En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n lo que debes realizar: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA y firmar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Distribuir esta app firmada con el perfil de aprovisionamiento del equipo de la UA usando Fabric. Creaci\u00f3n de la cuenta de desarrollador Apple Deber\u00e1s crear un Apple ID introduciendo tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Activa la autenticaci\u00f3n de doble factor de alguna de las formas definida en este enlace . Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . De esta forma est\u00e1s accediendo al programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo Descarga la app ToDoList . Incluye tu nombre en alguna parte de la interfaz de usuario. F\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Inst\u00e1lala en un dispositivo de desarrollo conectado a Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Configuraci\u00f3n de la cuenta de desarrollador Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos y direcci\u00f3n de e-mail en este fichero Google Docs . Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n podemos entrar en el member center , comprobar que ya est\u00e1s en el programa y probar las distintas opciones disponibles. Firma y despliegue de app con perfil de aprovisionamiento Debes seguir los pasos realizados en la demostraci\u00f3n con la app ToDoList . Nos damos de alta al equipo de la universidad. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba. Distribuci\u00f3n con Fabric Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Entregas Resumen de las pr\u00e1cticas a realizar en esta sesi\u00f3n y entregas a realizar en Moodle. Descarga la app ToDoList (o usa una app tuya que hayas desarrollado) y f\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Modifica la app para que aparezca tu nombre en la interfaz de usuario. Inst\u00e1lala en un dispositivo de desarrollo de Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Firma la app con tu cuenta del equipo de la UA, activa el servicio de Game Center e inst\u00e1lala en otro dispositivo del profesor que est\u00e9 dado de alta en el perfil de aprovisionamiento, pero que no sea el dispositivo de desarrollo de Xcode. Instala la app usando Apple Configurator 2 . Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Guarda las fotograf\u00edas y pantallas en una carpeta, junto con el binario .ipa de la actividad 2, comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 . Bibliograf\u00eda Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Test Flight Documentaci\u00f3n de Fabric","title":"Sesi\u00f3n 1 - Firma, aprovisionamiento y distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#sesion-1-firma-aprovisionamiento-y-distribucion-de-apps","text":"","title":"Sesi\u00f3n 1:  Firma, aprovisionamiento y  distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#introduccion","text":"En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps de iOS usando Test Flight y App Store Connect.","title":"Introducci\u00f3n"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#seguridad-en-las-apps","text":"La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable.","title":"Seguridad en las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#cuenta-de-desarrollador-de-apple","text":"","title":"Cuenta de desarrollador de Apple"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distintos-programas-de-desarrollo","text":"Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el member center de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ :","title":"Distintos programas de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#cuenta-de-desarrollador","text":"Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder a la cuenta de desarrollador , en la que podremos gestionar numerosos elementos que veremos durante el curso. Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store.","title":"Cuenta de desarrollador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#equipo-de-desarrollo","text":"En todos los programas de pago de desarrollador de Apple, incluso en los programas individuales, es posible trabajar con un equipo de desarrolladores. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership de la cuenta de desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight.","title":"Equipo de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo","text":"Veremos una demostraci\u00f3n en la que accederemos a la cuenta de desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es)","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#certificados","text":"","title":"Certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#codigo-firmado","text":"Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma.","title":"C\u00f3digo firmado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#identidad-de-firma","text":"Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en la cuenta de desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador.","title":"Identidad de firma"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#tipos-de-certificados","text":"Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el member center , Xcode o Acceso a llaveros .","title":"Tipos de certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#gestion-de-los-certificados-en-xcode","text":"Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra las dos identidades y nos permite utilizar la que nos interese en cada momento.","title":"Gesti\u00f3n de los certificados en Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-e-instalacion-de-certificados","text":"Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se descarga de los servidores de Apple e instala autom\u00e1ticamente el certificados de firma.","title":"Creaci\u00f3n e instalaci\u00f3n de certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-reales","text":"Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) correcto que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store.","title":"Ejecuci\u00f3n de apps en dispositivos reales"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_1","text":"Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode.","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-la-identidad-de-firma","text":"Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito.","title":"Instalaci\u00f3n de la identidad de firma"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-una-app","text":"Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app.","title":"Firma de una app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-ejemplo-todolist","text":"Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Podemos descargar la app de esta direcci\u00f3n y probar a ejecutarla en el simulador. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador.","title":"App ejemplo ToDoList"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#comprobacion-del-certificado","text":"En la pantalla de Xcode Preferences... Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode .","title":"Comprobaci\u00f3n del certificado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#comprobacion-de-la-identidad-de-firma-en-acceso-a-llaveros","text":"En la aplicaci\u00f3n Acceso a Llaveros y podemos comprobar que se ha instalado el certificado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n .","title":"Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#conexion-de-un-dispositivo-real-a-xcode","text":"Conectamos un dispositivo iOS real al ordenador. En Xcode seleccionamos Window Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo.","title":"Conexi\u00f3n de un dispositivo real a Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#prueba-en-un-dispositivo-real","text":"Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica.","title":"Prueba en un dispositivo real"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#autorizacion-al-desarrollador-en-el-dispositivo","text":"Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app.","title":"Autorizaci\u00f3n al desarrollador en el dispositivo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app","text":"Seleccionando la opci\u00f3n de Xcode Product Archive se accede al panel de archivo y distribuci\u00f3n de la app La opci\u00f3n de exportar la app est\u00e1 deshabilitado por que estamos registrados con el programa gratuito. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita.","title":"Archivo y distribuci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#despliegue-de-apps-en-dispositivos-de-prueba","text":"","title":"Despliegue de apps en dispositivos de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#capacidades-de-las-apps","text":"Para poder utilizar servicios avanzados proporcionados por Apple en las apps (como notificaciones push, iCloud o Game Center) es necesario darse de alta de forma individual en el programa de desarrollo de iOS o formar parte de un equipo de desarrollo. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer Support Advanced App Capabilities . Con el programa de desarrollo de la Universidad podemos acceder a m\u00e1s servicios que a los gratuitos, pero no a todos los servicios disponibles. La lista de servicios accesibles son los siguientes:","title":"Capacidades de las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#permisos-para-las-apps","text":"Un permiso ( entitlement ) es un elemento de configuraci\u00f3n incluido en la firma digital de la app que le indica al sistema que permita a la app acceder a ciertos recursos o realizar ciertas operaciones. La forma de otorgar los permisos a una app es algo elaborada, para permitir una configuraci\u00f3n flexible y no atar los permisos a una \u00fanica app. El responsable de la cuenta de desarrollador debe crear un identificador denominado App ID y otorgar los permisos a ese identificador.","title":"Permisos para las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#bundle-identifier","text":"Un bundle ID identifica de forma \u00fanica una app. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). La cadena deber\u00eda estar en un formato DNS-inverso y usar un dominio propio de la organizaci\u00f3n. De esta forma se garantiza su unicidad. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hello .","title":"Bundle Identifier"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#uso-del-bundle-id","text":"Se utiliza durante el desarrollo para aprovisionar dispositivos y por el sistema operativo cuando la app se distribuye a los clientes. Por ejemplo, los servicios de Game Center o de compras In-App usan el bundle ID para identificar la app cuando utilizan estos servicios.","title":"Uso del Bundle ID"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-id","text":"El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el member center . Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con permiso de acceso a iCloud y todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que permite que una o m\u00e1s apps desarrolladas por el equipo accedan a los permisos otorgados. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del APP ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha.","title":"App ID"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#gestion-de-las-capacidades-en-xcode","text":"En Xcode se deben indicar las capacidades que necesita la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Capabilities . Dependiendo del programa de desarrollo en el que estemos tendremos m\u00e1s o menos capacidades disponibles. Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el member center alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores.","title":"Gesti\u00f3n de las capacidades en Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#aprovisionamiento-de-apps","text":"Es necesario configurar un perfil de aprovisionamiento para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push) y para configurar dispositivos de prueba en los que podamos ejecutar la app. Con la cuenta de desarrollador gratuita es posible desarrollar aplicaciones, acceder a un n\u00famero limitado de servicios de Apple y probarlas configurando el dispositivo propio como un dispositivo de desarrollo. Pero es una forma muy limitada de prueba porque es necesario conectar f\u00edsicamente el dispositivo al ordenador en el que est\u00e1 Xcode. Es posible ejecutar apps en dispositivos de prueba sin tener que configurarlos como dispositivos de desarrollo usando perfiles de aprovisionamiento . Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad.","title":"Aprovisionamiento de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-de-apps","text":"La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran. Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Como ya hemos dicho, Apple permite ejecutar apps en dispositivos registrados mediante el uso de perfiles de aprovisionamiento . Apple tambi\u00e9n permite distribuir una app de forma restringida, s\u00f3lo a los dispositivos particulares de los empleados de una empresa. Para ello es necesario darse de alta en el Apple Developer Enterprise Program y utilizar tambi\u00e9n el perfil de aprovisionamiento apropiado.","title":"Distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#perfil-de-aprovisionamiento","text":"Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio ~Library/MobileDevice/Provisioning Profiles . Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode. Es posible consultar su contenido desde el terminal con el comando: 1 security cms -D -i perfil .mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder:","title":"Perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dispositivos-de-prueba-en-el-perfil-de-aprovisionamiento","text":"El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento ( provisioning profile ) y los permisos ( entitlements ) se usa para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store .","title":"Dispositivos de prueba en el perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-la-app-en-un-dispositivo-de-prueba","text":"Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. Contiene funcionalidades que se han extra\u00eddo de iTunes. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado.","title":"Instalaci\u00f3n de la app en un dispositivo de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-no-registrados","text":"Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple.","title":"Ejecuci\u00f3n de apps en dispositivos no registrados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#certificados-de-empresa","text":"Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house .","title":"Certificados de empresa"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_2","text":"","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#resumen-del-flujo-de-trabajo","text":"Es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Los dispositivos que se usan para el desarrollo deben ser registrados y a\u00f1adidos en el perfil de aprovisionamiento que uses para firmar la app. Si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode (es lo recomendado), Xcode crea estos elementos de forma autom\u00e1tica. Si perteneces a un equipo, algunos de estos permisos deben ser configurados por el administrador del equipo en la web de desarrollador de Apple. Pasos a seguir: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba.","title":"Resumen del flujo de trabajo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#equipo-de-desarrollo-del-programa-de-universidad","text":"La mayor\u00eda de opciones en el member center ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde el member center o desde Xcode. Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el member center o en la aplicaci\u00f3n de Acceso a llaveros:","title":"Equipo de desarrollo del programa de Universidad"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-la-app-con-el-nuevo-certificado","text":"Para firmar la app con el nuevo certificado dejamos marcada la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma. Seleccionamos el team Universidad de Alicante. Aparecen los siguientes errores porque Xcode no puede realizar autom\u00e1ticamente las actualizaciones que necesita: La cuenta no tiene permisos suficientes para crear un perfil de aprovisionamiento. No existe perfil de aprovisionamiento aplicable al bundle ID de la app. Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el member center e incorporar en ese perfil el certificado del desarrollador.","title":"Firma de la app con el nuevo certificado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#examinamos-los-perfiles-de-aprovisionamiento","text":"Podemos examinar los perfiles de aprovisionamiento desde el Member Center o desde Xcode y el terminal En el Member Center tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento.","title":"Examinamos los perfiles de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#menu-de-opciones","text":"Contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps","title":"Men\u00fa de opciones"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-un-app-id-desde-member-center","text":"S\u00f3lo se puede hacer con el rol administrador.","title":"Creaci\u00f3n un App ID desde Member Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dispositivos","text":"Para a\u00f1adir un dispositivo a un certificado de aprovisionamiento hay que a\u00f1adir su UDID, Unique Device Identifier . Cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9). Desde Xcode se puede obtener en la pantalla de Dispositivos ( Window Devices ). Se pueden registrar en el Member Center hasta 200 UDIDs para probar aplicaciones en desarrollo.","title":"Dispositivos"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-de-perfiles-de-aprovisionamento","text":"Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el Member Center y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde Member Center , ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n.","title":"Creaci\u00f3n de perfiles de aprovisionamento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevo-perfil-de-aprovisionamiento-desde-member-center","text":"","title":"Nuevo perfil de aprovisionamiento desde Member Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-la-app-todolist-con-el-perfil-de-aprovisionamiento-creado","text":"Una vez creado el perfil de aprovisionamiento ya es posible aplicarlo a la app. Basta con definir un bundle ID compatible con el App ID definido en el perfil. En este caso, al haber definido un App ID \u00fanico (sin el * ) se define como bundle ID el mismo. El perfil de aprovisionamiento correspondiente se descarga autom\u00e1ticamente.","title":"Firma de la app ToDoList con el perfil de aprovisionamiento creado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#seleccion-manual-del-perfil-de-aprovisionamiento","text":"Es posible seleccionar manualmente un perfil de aprovisionamiento del member center eliminando la opci\u00f3n de Xcode de gesti\u00f3n autom\u00e1tica de la firma.","title":"Selecci\u00f3n manual del perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#capabilities","text":"El perfil de aprovisionamiento que hemos creado permite 3 capabilities: Game Center In-App Purchase Keychain Sharing Es posible activar cualquiera de estos servicios en la app, en el men\u00fa Capabilities . Ahora este men\u00fa muestra m\u00e1s servicios posibles, al pertenecer al equipo de la UA:","title":"Capabilities"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#activacion-del-permiso-de-game-center","text":"Si se activa el permiso de Game Center Xcode se asegurar\u00e1 e que el perfil de aprovisionamiento seleccionado proporcione este permiso. Si no es as\u00ed aparecer\u00e1 un error y el bot\u00f3n Fix Issue. Es posible comprobar el error si se intenta activar el permiso Push Notificacions . Xcode puede arreglar el error creando un nuevo perfil de aprovisionamiento y subi\u00e9ndolo al Member Center . Para ello hay que tener permisos apropiados en la cuenta de desarrollador (ser un administrador del equipo en el caso de una organizaci\u00f3n o el propietario del equipo en el caso de un programa de desarrollo).","title":"Activaci\u00f3n del permiso de Game Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#exportar-la-app","text":"Seleccionando en Xcode la opci\u00f3n Product Archive ahora ya est\u00e1 activa la opci\u00f3n Export Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Tarda un buen rato en generar el fichero ipa ( iOS App file ). El fichero generado es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento.","title":"Exportar la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-y-ejecucion-de-la-app","text":"Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2.","title":"Instalaci\u00f3n y ejecuci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-e-instalacion-de-betas-online","text":"Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple (lo veremos m\u00e1s adelante). Pero este servicio s\u00f3lo est\u00e1 disponible para apps enviadas al App Store. Es necesario para ello una cuenta de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Es lo que se consigue con servicios como el que vamos a ver: Fabric.","title":"Distribuci\u00f3n e instalaci\u00f3n de betas online"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#fabric","text":"Fabric es una plataforma y API que permite una gran cantidad de funcionalidades: distribuci\u00f3n, recopilaci\u00f3n de datos de crashes, recopilaci\u00f3n de estad\u00edsticas de uso, etc. Se trata de una plataforma creada por Twitter y comprada por Google en enero de 2017. Se puede acceder desde esta URL . En este a\u00f1o 2019 Google realizar\u00e1 la integraci\u00f3n del servicio en Firebase.","title":"Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_3","text":"","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#alta-y-descarga-de-fabric","text":"Debemos registrarnos en Fabric con nuestro correo electr\u00f3nico y nuestro nombre. Escribimos como nombre de la organizaci\u00f3n nuestro propio nombre. Hay entrar en el dashboard y descargar e instalar la aplicaci\u00f3n para Mac, movi\u00e9ndola a la carpeta de Aplicaciones. La \u00faltima versi\u00f3n es la 2.7.5. Una vez descargada, hay que registrarse en la aplicaci\u00f3n en ella con la misma cuenta y contrase\u00f1a que en la web.","title":"Alta y descarga de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-fabric","text":"La aplicaci\u00f3n Fabric nos gu\u00eda paso a paso: Debemos seleccionar el proyecto XCode y a\u00f1adir un Run Script Build Phase . Se selecciona en Xcode Build Phases y en el s\u00edmbolo + se selecciona New Run Script Build Phase . En la opci\u00f3n Run Script se pega el c\u00f3digo que aparece en la aplicaci\u00f3n. Compilamos la aplicaci\u00f3n con la opci\u00f3n Product Build . Se instala el SDK Kit en el proyecto, arrastrando desde la aplicaci\u00f3n al proyecto. Debemos copiar el c\u00f3digo indicado en el fichero AppDelegate.swift . Y volvemos a compilar la aplicaci\u00f3n y la ejecutamos en el simulador. La aplicaci\u00f3n de Fabric detectar\u00e1 que la hemos lanzado y aparecer\u00e1 una pantalla indicando que todo ha ido correctamente. Tambi\u00e9n recibiremos un correo electr\u00f3nico indicando que la app ya se ha subido y est\u00e1 disponible para su distribuci\u00f3n.","title":"Instalaci\u00f3n de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-a-probadores","text":"Debemos seleccionar en Xcode la opci\u00f3n de Product Archive . Cuidado Recuerda que para habilitar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Autom\u00e1ticamente la app aparecer\u00e1 en la aplicaci\u00f3n de Fabric. Podremos activar la distribuci\u00f3n, a\u00f1adiendo los correos electr\u00f3nicos de las personas a las que se les enviar\u00e1. Si el UUID del dispositivo del probador est\u00e1 incluido en el perfil de aprovisionamiento podr\u00e1 ejecutar la app sin problemas. Si no, Fabric obtendr\u00e1 el UUID y nos lo proporcionar\u00e1 para que actualicemos el perfil de aprovisionamiento.","title":"Distribuci\u00f3n a probadores"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-la-app-por-el-probador","text":"El probador recibe un e-mail que le dirige a una p\u00e1gina web desde la que debe instalar un perfil (que ser\u00e1 el que permitir\u00e1 leer el UUID del dispositivo y comprobar si est\u00e1 incluido en el perfil de aprovisionamiento instalado en la app que se distribuye). Si el dispositivo puede ejecutar la app aparecer\u00e1 un bot\u00f3n para instalarla. La forma de instalarla ser\u00e1 tan sencilla como pulsar ese bot\u00f3n (no hay necesidad de usar iTunes ni Xcode). Si el dispositivo no puede ejecutar la app, aparecer\u00e1 un mensaje indic\u00e1ndolo y nos informar\u00e1 del UUID.","title":"Ejecuci\u00f3n de la app por el probador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dashboard-de-fabric","text":"En el dashboard ( https:/fabric.io ) podemos acceder a estad\u00edsticas de descargas e instalaciones, informaci\u00f3n sobre los crashes de nuestra apps, etc. Tambi\u00e9n podemos invitar nuevos probadores y crear un enlace desde el que es posible instalar la app. Cuando se pulsa en el enlace se accede a una p\u00e1gina en la que se pide el e-mail de la persona que va a probar la app.","title":"Dashboard de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#test-flight","text":"","title":"Test Flight"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-de-apps_1","text":"El proceso de distribuci\u00f3n de apps en el App Store es el siguiente:","title":"Distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-store-connect","text":"App Store Connect es el servicio de Apple con el que los desarrolladores pueden organizar: Todas sus apps para poder enviar a prueba versiones beta y subirlas al App Store. Toda la informaci\u00f3n legal y de impuestos. Informaci\u00f3n sobre el estado de los productos, retroalimentaci\u00f3n e informaci\u00f3n de descargas, ventas y ganancias. La plataforma est\u00e1 accesible desde el member center en los programas de pago. No est\u00e1 disponible en el programa de universidad. Tambi\u00e9n se puede acceder desde la URL https://appstoreconnect.apple.com . Nota Hasta el a\u00f1o pasado (2018) iTunes Connect era la plataforma \u00fanica a la que se sub\u00edan todos los productos para su distribuci\u00f3n (apps, ebooks, podcasts, m\u00fasica). A mediados del 2018 Apple divide en dos esa plataforma, creando App Store Connect para gestionar \u00fanicamente apps. Hemos conservado algunas im\u00e1gnes del curso pasado en el caso en sean muy similares a las actuales. En estas im\u00e1genes aparece la cabecera iTunes Connect en lugar de App Store Connect .","title":"App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#pasos-para-subir-una-app-al-app-store-desde-app-store-connect","text":"Crear un registro en App Store Connect, un identificador \u00fanico para el app. Subir una compilaci\u00f3n de la app. Pruebas Beta: probar la app con usuarios de la organizaci\u00f3n o usuarios invitados, usando Test Flight . Completar toda la informaci\u00f3n y enviar la app a revisi\u00f3n de la App Store. Una vez que ha superado la revisi\u00f3n, la app se pone a la venta en la App Store. Analizar anal\u00edticas de la app (de ventas, de uso, etc.) y desarrollar una nueva versi\u00f3n.","title":"Pasos para subir una app al App Store desde App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#anadir-informacion-de-la-app","text":"Antes de subir una app a App Store Connect, hay que crear un registro de la misma indicando un identificador \u00fanico (SKU) que puede ser el propio bundle ID y seleccionando el App ID.","title":"A\u00f1adir informaci\u00f3n de la App"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#subir-una-compilacion-de-la-app","text":"La forma m\u00e1s sencilla de subir una app a App Store Connect es utilizando Xcode. Debes crear un archivo ipa con la opci\u00f3n Product Archive y seleccionar la opci\u00f3n Upload to App Store . Es posible subir distintos builds y gestionarlos todos desde App Store Connect. El identificador de la app es su bundle id .","title":"Subir una compilaci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#diseno-de-la-pagina-en-el-app-store","text":"En el App Store se muestra distinta informaci\u00f3n sobre la app. Es importante dise\u00f1ar bien esta p\u00e1gina para que sea atractiva para los usuarios y est\u00e9n interesados en descargar la app. App Store Connect se usa para gestionar estos los elementos necesarios para crear la p\u00e1gina de la app en el App Store: nombre de la App, iconos, previsualizaciones (pantallas y v\u00eddeos), descripci\u00f3n, novedades, palabras claves y categor\u00edas.","title":"Dise\u00f1o de la p\u00e1gina en el App Store"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevos-usuarios-app-store-connect","text":"Es posible a\u00f1adir usuarios a la cuenta de App Store Connect. Son usuarios que van a poder trabajar con las apps subidas, realizando funciones limitadas por su funci\u00f3n. No es necesario tener una cuenta de organizaci\u00f3n para poder a\u00f1adir usuarios colaboradores en App Store Connect. Es posible en cuentas de desarrollador individual. Los usuarios a\u00f1adidos podr\u00e1n ser probadores internos en TestFlight.","title":"Nuevos usuarios App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight","text":"TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos.","title":"TestFlight"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#aprobacion-de-pruebas-externas","text":"Una vez subida a App Store Connect la app entra autom\u00e1ticamente en un proceso de aprobaci\u00f3n para que se pueda distribuir externamente una versi\u00f3n beta en TestFlight. La aprobaci\u00f3n suele tardar menos de 1 d\u00eda la primera compilaci\u00f3n y ser casi instant\u00e1nea cada nueva compilaci\u00f3n que se sube. No es necesaria aprobaci\u00f3n para la distribuci\u00f3n de pruebas internas.","title":"Aprobaci\u00f3n de pruebas externas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight-en-app-store-connect","text":"","title":"TestFlight en App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_4","text":"Vamos a comprobar el funcionamiento de TestFlight, subiendo la app ToDoList, a\u00f1adiendo probadores y comprobando la instalaci\u00f3n de la app en los probadores.","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#registro-de-una-app-en-app-store-connect","text":"Registramos la app en App Store Connect.","title":"Registro de una app en App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#subida-a-app-store-connect-con-xcode","text":"Una vez creado el registro de la app ya es posible subirla desde Xcode.","title":"Subida a App Store Connect con Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#compilaciones-listas-para-probar","text":"Una vez que se ha subido a App Store Connect y ha pasado un tiempo necesario para que la plataforma prueba que la app puede ser distribuida para pruebas, aparecer\u00e1 con un indicador verde lista para probar. Los n\u00fameros de versi\u00f3n y de compilaci\u00f3n ( build ) son los definidos en Xcode. Ahora la app est\u00e1 lista para que sea probada por los usuarios de prueba internos. Podemos seleccionar la compilaci\u00f3n a distribuir.","title":"Compilaciones listas para probar"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#anadir-probadores-externos-y-enlace-de-prueba","text":"Podemos tambi\u00e9n a\u00f1adir usuarios de prueba externos y un enlace de prueba que puede ser usado por cualquiera. Para ello es necesario crear un grupo de prueba y volver a solicitar una autorizaci\u00f3n de env\u00edo a pruebas de la app. Debe pasar un tiempo para App Store Connect apruebe la distribuci\u00f3n de prueba. Mientras tanto la compilaci\u00f3n seleccionada aparecer\u00e1 en estado Pendiente de revisi\u00f3n . Una vez aprobada la distribuci\u00f3n es posible crear un enlace para que cualquiera la pueda instalar y probar.","title":"A\u00f1adir probadores externos y enlace de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight-en-los-usuarios","text":"Los usuarios de prueba reciben un correo avis\u00e1ndoles de que la beta est\u00e1 disponible. Deben instalar la app TestFlight y en la app aparecer\u00e1 un bot\u00f3n que permitir\u00e1 instalar la app en el dispositivo. En este caso no es necesario que el dispositivo est\u00e9 en la lista incluida en el perfil de aprovisionamiento, porque la app est\u00e1 autorizada por Apple para su ejecuci\u00f3n en cualquier dispositivo.","title":"TestFlight en los usuarios"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevas-compilaciones","text":"Cuando subimos desde Xcode una nueva compilaci\u00f3n, debemos entrar en el enlace de la compilaci\u00f3n para activar la nueva prueba. TestFlight enviar\u00e1 una notificaci\u00f3n autom\u00e1ticamente a todos los usuarios para que descarguen la nueva versi\u00f3n.","title":"Nuevas compilaciones"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#practicas","text":"En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n lo que debes realizar: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA y firmar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Distribuir esta app firmada con el perfil de aprovisionamiento del equipo de la UA usando Fabric.","title":"Pr\u00e1cticas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-de-la-cuenta-de-desarrollador-apple","text":"Deber\u00e1s crear un Apple ID introduciendo tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Activa la autenticaci\u00f3n de doble factor de alguna de las formas definida en este enlace . Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . De esta forma est\u00e1s accediendo al programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help","title":"Creaci\u00f3n de la cuenta de desarrollador Apple"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-e-instalacion-de-una-app-en-un-dispositivo-de-desarrollo","text":"Descarga la app ToDoList . Incluye tu nombre en alguna parte de la interfaz de usuario. F\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Inst\u00e1lala en un dispositivo de desarrollo conectado a Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n.","title":"Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#configuracion-de-la-cuenta-de-desarrollador","text":"Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos y direcci\u00f3n de e-mail en este fichero Google Docs . Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n podemos entrar en el member center , comprobar que ya est\u00e1s en el programa y probar las distintas opciones disponibles.","title":"Configuraci\u00f3n de la cuenta de desarrollador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-y-despliegue-de-app-con-perfil-de-aprovisionamiento","text":"Debes seguir los pasos realizados en la demostraci\u00f3n con la app ToDoList . Nos damos de alta al equipo de la universidad. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba.","title":"Firma y despliegue de app con perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-con-fabric","text":"Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos.","title":"Distribuci\u00f3n con Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#entregas","text":"Resumen de las pr\u00e1cticas a realizar en esta sesi\u00f3n y entregas a realizar en Moodle. Descarga la app ToDoList (o usa una app tuya que hayas desarrollado) y f\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Modifica la app para que aparezca tu nombre en la interfaz de usuario. Inst\u00e1lala en un dispositivo de desarrollo de Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Firma la app con tu cuenta del equipo de la UA, activa el servicio de Game Center e inst\u00e1lala en otro dispositivo del profesor que est\u00e9 dado de alta en el perfil de aprovisionamiento, pero que no sea el dispositivo de desarrollo de Xcode. Instala la app usando Apple Configurator 2 . Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Guarda las fotograf\u00edas y pantallas en una carpeta, junto con el binario .ipa de la actividad 2, comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 .","title":"Entregas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#bibliografia","text":"Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Test Flight Documentaci\u00f3n de Fabric","title":"Bibliograf\u00eda"},{"location":"sesion02/sesion02-notificaciones.html","text":"Sesi\u00f3n 2: Notificaciones En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS. Introducci\u00f3n En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11. Apariencia de las notificaciones Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes Notificaciones ). D\u00f3nde aparecen las notificaciones Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla). Interacci\u00f3n en las notificaciones Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app. Notificaciones locales Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado. Notificaciones remotas Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido. Para qu\u00e9 se usan las notificaciones Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice. Notification service app extensions Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones. Ciclo de vida de la app Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps. API de notificaciones A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones UNUserNotificationCenter La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n. Notifications UI Framework Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications . Preparaci\u00f3n de las notificaciones Registro de los tipos de notificaci\u00f3n Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n. Obtener los ajustes definidos por el usuario El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func applicationWillEnterForeground ( _ application : UIApplication ) { print ( Voy a pedir los settigs ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( Alert enabled ) } else { print ( Alert not enabled ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( Badge enabled ) } else { print ( Badge not enabled ) }}) } Notificaciones locales Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado. Creaci\u00f3n de notificaciones La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? ) Contenido de la notificaci\u00f3n El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: 1 2 3 4 5 let content = UNMutableNotificationContent () content . title = Introduction to Notifications content . subtitle = Session 707 content . body = Woah! These new notifications look amazing! Don\u2019t you agree? content . badge = 1 Media attachments Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) - UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + .png let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( error + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: 1 2 3 4 5 6 if let attachment = UNNotificationAttachment . create ( identifier : prueba , image : UIImage ( named : gatito.png ) ! , options : nil ) { content . attachments = [ attachment ] } Condiciones de disparo de la notificaci\u00f3n Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. 1 2 // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: 1 2 3 4 let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. 1 2 3 4 5 let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : Headquarters ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false ) Creaci\u00f3n de la notificaci\u00f3n local Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: 1 2 3 4 5 6 7 8 9 10 11 let content = UNMutableNotificationContent () content . title = Introducci\u00f3n a Notificaciones content . body = Hablemos sobre notificaciones! content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = peticionEjemplo let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( Error \\( error ) )} Demo Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo. Ejemplo de app: Notificaciones Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones. Acciones Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction . El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter asociada a un identificador. Una vez creada la categor\u00eda con el conjunto de acciones podemos crear una notificaci\u00f3n que contenga estas acciones inicializando la propiedad categoryIdentifier de la notificaci\u00f3n con la cadena apropiada. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto , y es la cadena: com.apple.UNNotificationDefaultActionIdentifier . Ejemplo de c\u00f3digo de creaci\u00f3n de una acci\u00f3n Para crear las acciones y asociarlas a una categor\u00eda: 1 2 3 4 5 6 7 8 9 10 let action1 = UNNotificationAction ( identifier : acepto , title : Acepto , options : []) let action2 = UNNotificationAction ( identifier : otro , title : Otro d\u00eda , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : mensaje , title : Mensaje , options : [], textInputButtonTitle : Enviar , textInputPlaceholder : Comentario ) let category = UNNotificationCategory ( identifier : invitacion , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Para asignar las acciones a la notificaci\u00f3n se asigna el identificador de la categor\u00eda. 1 content . categoryIdentifier = invitacion La notificaci\u00f3n creada tiene el siguiente aspecto: Manejo de notificaciones Una vez que el usuario ha pulsado una acci\u00f3n de la notificaci\u00f3n o la ha abierto nuestra app debe gestionar esa acci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Para ello debemos implementar los m\u00e9todos del protocolo UNUserNotificationCenterDelegate . userNotificationCenter(_:didReceive:withCompletionHandler:) : se llama cuando la app est\u00e1 en segundo plano y el usuario interact\u00faa con la notificaci\u00f3n. userNotificationCenter(_:willPresent:withCompletionHandler:) : se llama cuando la app est\u00e1 en primer plano y se recibe la notificaci\u00f3n. Estos m\u00e9todos se suelen implementar en el propio AppDelegate , que cumple este protocolo. Y se debe asignar al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:) . Por ejemplo: 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { ... UNUserNotificationCenter . current (). delegate = self ... } App en segundo plano Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local el usuario puede interactuar con las acciones de la notificaci\u00f3n o pulsar la opci\u00f3n de Abrir . En ambos casos se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) con la informaci\u00f3n de la opci\u00f3n seleccionada por el usuario. Si el usuario ha seleccionado una acci\u00f3n la aplicaci\u00f3n no pasa a primer plano. Sin embargo, si el usuario ha decidido abrir la notificaci\u00f3n, la aplicaci\u00f3n pasa a primer plano, ejecut\u00e1ndose el m\u00e9todo de ciclo de vida applicationWillEnterForeground del UIApplicationDelegate antes del m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) . Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida. Si la notificaci\u00f3n es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante). Un ejemplo del c\u00f3digo en el que se gestiona la notificaci\u00f3n recibida: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { // Get the meeting ID from the original notification. let userInfo = response . notification . request . content . userInfo if response . notification . request . content . categoryIdentifier == MEETING_INVITATION { // Retrieve the meeting details. let meetingID = userInfo [ MEETING_ID ] as ! String let userID = userInfo [ USER_ID ] as ! String switch response . actionIdentifier { case ACCEPT_ACTION : sharedMeetingManager . acceptMeeting ( user : userID , meetingID : meetingID ) break case DECLINE_ACTION : sharedMeetingManager . declineMeeting ( user : userID , meetingID : meetingID ) break case UNNotificationDefaultActionIdentifier , UNNotificationDismissActionIdentifier : // Queue meeting-related notifications for later // if the user does not act. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) break default : break } } else { // Handle other notification types... } // Always call the completion handler when done. completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier , el contenido de la constante UNNotificationDefaultActionIdentifier . App en primer plano En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Un ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { if notification . request . content . categoryIdentifier == MEETING_INVITATION { // Retrieve the meeting details. let meetingID = notification . request . content . userInfo [ MEETING_ID ] as ! String let userID = notification . request . content . userInfo [ USER_ID ] as ! String // Add the meeting to the queue. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) // Play a sound to let the user know about the invitation. completionHandler (. sound ) return } else { // Handle other notification types... } // Don t alert the user for other types. completionHandler ( UNNotificationPresentationOptions ( rawValue : 0 )) } Demo Probamos y examinamos el c\u00f3digo de la aplicaci\u00f3n de prueba que incluye acciones en la notificaci\u00f3n y que define las funciones de gesti\u00f3n de las notificaciones. Probamos a seleccionar distintas acciones y comprobar qu\u00e9 mensaje aparece por la salida est\u00e1ndar: Notificaciones remotas ( push ) Objetivos de las notificaciones remotas La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ). Arquitectura de las notificaciones remotas El servicio Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos. Arquitectura de seguridad No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs. Secuencia de registro del dispositivo Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs. Token del dispositivo Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo. Env\u00edo de notificaci\u00f3n remota usando el token Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado. Contenido de la notificaci\u00f3n Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple . El tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes y debe tener el formato de un objeto JSON diccionario (parejas clave, valor). Un ejemplo en JSON: 1 2 3 4 5 6 7 8 9 10 11 { aps : { alert : { title : Introducci\u00f3n a las notificaciones , subtitle : Sesi\u00f3n 707 , body : La nueva API de notificaciones es genial!!! , category : mensaje , }, badge : 1 }, } El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: - Mensaje de alerta a mostrar al usuario - Numero a a\u00f1adir en el globo del icono de la app - Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. El usuario no recibir\u00e1 ninguna notificaci\u00f3n, pero ver\u00e1 el nuevo contenido la siguiente vez que abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app. Otros ejemplos de payload . N\u00famero en el badge y custom keys : 1 2 3 4 5 6 7 8 9 { aps : { alert : You got your emails. , badge : 9 , sound : bingbong.aiff }, acme1 : bar , acme2 : 42 } Notificaci\u00f3n con cadenas localizadas: 1 2 3 4 5 6 7 8 9 10 { aps : { alert : { loc-key : GAME_PLAY_REQUEST_FORMAT , loc-args : [ Jenna , Frank ] }, sound : chime.aiff }, acme : foo } Notificaci\u00f3n con acciones: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { aps : { alert\u201d : { \u201cbody\u201d : Acme message received from Johnny Appleseed\u201d , \u201caction-loc-key\u201d : \u201cVIEW\u201d, actions : [ { \u201cid : \u201cdelete , title : Delete }, { \u201cid : \u201creply-to\u201d, loc-key : \u201cREPLYTO\u201d, loc-args : [\u201cJane ] } ] } badge : 3 , sound : \u201cchime.aiff }, acme-account : jane.appleseed@apple.com , acme-message : message 123456 } Servidores proveedores Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida por Apple basada en un protocolo HTTP/2 y TLS. Es posible montar un servidor propio usando librer\u00edas ya existentes. Por ejemplo, en Java existe la librer\u00eda Pushy . Es recomendable consultar la documentaci\u00f3n de Apple Setting Up a Remote Notification Server y Sending Notification Requests to APNs . La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal. En cualquier caso nuestro servidor deber\u00e1 conectarse al APNs usando una t\u00e9cnica segura: o bien un certificado proporcionado por Apple (es lo que haremos en la demostraci\u00f3n) o bien un token, usando JWT (JSON Web Token). Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs Gesti\u00f3n de las notificaciones remotas en la app Capacidad de notificaci\u00f3n remota La app debe tener el permiso de usar las notificaciones remotas. Debe usar un perfil de aprovisionamiento con un App ID que otorgue ese permiso. Se puede hacer desde Xcode o desde el la web de desarrollador. En la demostraci\u00f3n lo haremos desde la web del programa de desarrollo de la universidad. Registro de las notificaciones Para que una app trabaje con notificaciones remotas lo primero que debe hacerse, al igual que con las notificaciones locales, es pedir permiso al usuario. La forma de hacerlo es id\u00e9ntica a las de las notificaciones locales, usando el m\u00e9todo requestAuthorization(options:completionHandler:) . Una vez hecho esto, hay que conseguir el token asociado al dispositivo y la app registr\u00e1ndose en el Apple Push Notification service (APNs). Lo hace el m\u00e9todo registerForRemoteNotifications del objeto application. Se trata de un m\u00e9todo as\u00edncrono. Si el registro en el servicio tiene \u00e9xito, la app llama al m\u00e9todo application(_:didRegisterForRemoteNotificationsWithDeviceToken:) del delegado de la aplicaci\u00f3n pasando el token asignado que habr\u00e1 que incluir en las notificaciones que enviemos al dispositivo. Ejemplo de c\u00f3digo de registro de las notificaciones remotas: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } Ejemplo de obtenci\u00f3n del token e impresi\u00f3n en la consola: 1 2 3 4 5 6 7 8 9 10 11 12 13 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( Failed to register: , error ) } Recepci\u00f3n de las notificaciones en la app La gesti\u00f3n de las notificaciones recibidas es id\u00e9ntica a la ya vista en notificaciones locales, us\u00e1ndose exactamente los mismos manejadores, con la excepci\u00f3n de la posibilidad de gestionar notificaciones remotas cuando la app est\u00e1 en segundo plano. Recordemos los manejadores que ya vimos en las notificaciones locales: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate cuando llega la notificaci\u00f3n. Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . La diferencia de las notificaciones remotas es la posibilidad de definir el manejador application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app, que se activa cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 : 1 2 3 4 5 6 7 { aps : { content-available : 1 }, acme1 : bar , acme2 : 42 } Para que se llame al m\u00e9todo se debe activar la capability Background Modes Remote Notifications en Xcode. El m\u00e9todo se llama tanto si la app est\u00e1 en primer plano como si est\u00e1 en segundo plano. De hecho, es recomendable usarlo \u00fanicamente para gestionar notificaciones silenciosas que no se muestran al usuario sino que se usan para que la app pueda recuperar informaci\u00f3n del servidor que se mostrar\u00e1 la siguiente vez que el usuario lance la app. Por ello habr\u00eda que enviar un payload como el que hemos visto anteriormente. Con custom keys pero en el que el diccionario aps no contenga ninguna clave que disparare una interacci\u00f3n con el usuario. Ejemplo de app Ejemplo de app que usaremos para demostrar las notificaciones remotas: C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando la app est\u00e1 en primer plano : 1 2 3 4 5 6 7 8 9 10 11 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificaci\u00f3n primer plano ) let aps = notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let news = aps [ alert ] as ? String { createNewNewsItem ( text : news ) } // No mostramos la notificaci\u00f3n completionHandler ([]) } C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando ha sido accionada por el usuario : 1 2 3 4 5 6 7 8 9 10 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { print ( Usuario ha pulsado una notificaci\u00f3n ) let aps = response . notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let news = aps [ alert ] as ? String { createNewNewsItem ( text : news ) } completionHandler () } C\u00f3digo de gesti\u00f3n de una notificaci\u00f3n silenciosa : 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) - Void ) { print ( Recibida notificaci\u00f3n remota en background ) createNewNewsItem ( text : Notificaci\u00f3n silenciosa ) completionHandler ( UIBackgroundFetchResult . newData ) } Demo Pasos necesarios para la demo En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP que tendremos que configurar con: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push. Nuevo App ID en el member center Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n. Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push. Creaci\u00f3n del certificado SSL en el member center Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros Asistente de Certificados Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest . Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest Generaci\u00f3n del fichero .pem Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros. Lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs: Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles19) Creamos el fichero .pem con el siguiente comando: 1 2 $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Una vez hecho esto, ya tendremos listo el certificado para enviar la notificaci\u00f3n push al APNs, usando el script PHP. Creaci\u00f3n del perfil de aprovisionamiento Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo. Obtenci\u00f3n del token del dispositivo Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo y de la app que va a recibir la notificaci\u00f3n. Para ello debemos ejecutar la app en un dispositivo f\u00edsico (no funciona en el simulador). Probamos la app NotificacionesPush Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs. La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador. Anotamos el token del dispositivo que aparece en la consola al ejecutar la app por primera vez. Probamos a enviar notificaciones remotas al dispositivo Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: 1 2 3 $ php apnspush.php Hola mundo desde la UA Connected to APNS Message successfully delivered Pr\u00e1ctica Descarga las apps Notificaciones y NotificacionesPush su c\u00f3digo y pru\u00e9balas. La primera puedes probarla en el simulador. La segunda deber\u00e1s probarla ejecut\u00e1ndola en un dispositivo real y enviando notificaciones remotas tal y como hemos hecho en la demo. Ejercicio 1: Modifica la app ToDoList para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2: Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3: A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n silenciosa enviada con una notificaci\u00f3n push. Utiliza el script PHP y este certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas. Bibliograf\u00eda Framework UserNotifications Asking Permission to Use Notifications Scheduling a Notification Locally from Your App Handling Notifications and Notification-Related Actions Registering Your App with APNs Generating a Remote Notification Pushing Updates to Your App Silently Setting Up a Remote Notification Server Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"Sesi\u00f3n 2 - Notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#sesion-2-notificaciones","text":"En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS.","title":"Sesi\u00f3n 2: Notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#introduccion","text":"En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11.","title":"Introducci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#apariencia-de-las-notificaciones","text":"Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes Notificaciones ).","title":"Apariencia de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#donde-aparecen-las-notificaciones","text":"Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla).","title":"D\u00f3nde aparecen las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#interaccion-en-las-notificaciones","text":"Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app.","title":"Interacci\u00f3n en las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-locales","text":"Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado.","title":"Notificaciones locales"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-remotas","text":"Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido.","title":"Notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#para-que-se-usan-las-notificaciones","text":"Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice.","title":"Para qu\u00e9 se usan las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#notification-service-app-extensions","text":"Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones.","title":"Notification service app extensions"},{"location":"sesion02/sesion02-notificaciones.html#ciclo-de-vida-de-la-app","text":"Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps.","title":"Ciclo de vida de la app"},{"location":"sesion02/sesion02-notificaciones.html#api-de-notificaciones","text":"A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones","title":"API de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#unusernotificationcenter","text":"La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n.","title":"UNUserNotificationCenter"},{"location":"sesion02/sesion02-notificaciones.html#notifications-ui-framework","text":"Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications .","title":"Notifications UI Framework"},{"location":"sesion02/sesion02-notificaciones.html#preparacion-de-las-notificaciones","text":"","title":"Preparaci\u00f3n de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#registro-de-los-tipos-de-notificacion","text":"Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n.","title":"Registro de los tipos de notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#obtener-los-ajustes-definidos-por-el-usuario","text":"El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func applicationWillEnterForeground ( _ application : UIApplication ) { print ( Voy a pedir los settigs ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( Alert enabled ) } else { print ( Alert not enabled ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( Badge enabled ) } else { print ( Badge not enabled ) }}) }","title":"Obtener los ajustes definidos por el usuario"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-locales_1","text":"Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado.","title":"Notificaciones locales"},{"location":"sesion02/sesion02-notificaciones.html#creacion-de-notificaciones","text":"La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? )","title":"Creaci\u00f3n de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#contenido-de-la-notificacion","text":"El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: 1 2 3 4 5 let content = UNMutableNotificationContent () content . title = Introduction to Notifications content . subtitle = Session 707 content . body = Woah! These new notifications look amazing! Don\u2019t you agree? content . badge = 1","title":"Contenido de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#media-attachments","text":"Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) - UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + .png let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( error + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: 1 2 3 4 5 6 if let attachment = UNNotificationAttachment . create ( identifier : prueba , image : UIImage ( named : gatito.png ) ! , options : nil ) { content . attachments = [ attachment ] }","title":"Media attachments"},{"location":"sesion02/sesion02-notificaciones.html#condiciones-de-disparo-de-la-notificacion","text":"Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. 1 2 // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: 1 2 3 4 let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. 1 2 3 4 5 let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : Headquarters ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false )","title":"Condiciones de disparo de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#creacion-de-la-notificacion-local","text":"Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: 1 2 3 4 5 6 7 8 9 10 11 let content = UNMutableNotificationContent () content . title = Introducci\u00f3n a Notificaciones content . body = Hablemos sobre notificaciones! content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = peticionEjemplo let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( Error \\( error ) )}","title":"Creaci\u00f3n de la notificaci\u00f3n local"},{"location":"sesion02/sesion02-notificaciones.html#demo","text":"Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo.","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-app-notificaciones","text":"Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones.","title":"Ejemplo de app: Notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#acciones","text":"Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction . El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter asociada a un identificador. Una vez creada la categor\u00eda con el conjunto de acciones podemos crear una notificaci\u00f3n que contenga estas acciones inicializando la propiedad categoryIdentifier de la notificaci\u00f3n con la cadena apropiada. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto , y es la cadena: com.apple.UNNotificationDefaultActionIdentifier .","title":"Acciones"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-codigo-de-creacion-de-una-accion","text":"Para crear las acciones y asociarlas a una categor\u00eda: 1 2 3 4 5 6 7 8 9 10 let action1 = UNNotificationAction ( identifier : acepto , title : Acepto , options : []) let action2 = UNNotificationAction ( identifier : otro , title : Otro d\u00eda , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : mensaje , title : Mensaje , options : [], textInputButtonTitle : Enviar , textInputPlaceholder : Comentario ) let category = UNNotificationCategory ( identifier : invitacion , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Para asignar las acciones a la notificaci\u00f3n se asigna el identificador de la categor\u00eda. 1 content . categoryIdentifier = invitacion La notificaci\u00f3n creada tiene el siguiente aspecto:","title":"Ejemplo de c\u00f3digo de creaci\u00f3n de una acci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#manejo-de-notificaciones","text":"Una vez que el usuario ha pulsado una acci\u00f3n de la notificaci\u00f3n o la ha abierto nuestra app debe gestionar esa acci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Para ello debemos implementar los m\u00e9todos del protocolo UNUserNotificationCenterDelegate . userNotificationCenter(_:didReceive:withCompletionHandler:) : se llama cuando la app est\u00e1 en segundo plano y el usuario interact\u00faa con la notificaci\u00f3n. userNotificationCenter(_:willPresent:withCompletionHandler:) : se llama cuando la app est\u00e1 en primer plano y se recibe la notificaci\u00f3n. Estos m\u00e9todos se suelen implementar en el propio AppDelegate , que cumple este protocolo. Y se debe asignar al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:) . Por ejemplo: 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { ... UNUserNotificationCenter . current (). delegate = self ... }","title":"Manejo de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#app-en-segundo-plano","text":"Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local el usuario puede interactuar con las acciones de la notificaci\u00f3n o pulsar la opci\u00f3n de Abrir . En ambos casos se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) con la informaci\u00f3n de la opci\u00f3n seleccionada por el usuario. Si el usuario ha seleccionado una acci\u00f3n la aplicaci\u00f3n no pasa a primer plano. Sin embargo, si el usuario ha decidido abrir la notificaci\u00f3n, la aplicaci\u00f3n pasa a primer plano, ejecut\u00e1ndose el m\u00e9todo de ciclo de vida applicationWillEnterForeground del UIApplicationDelegate antes del m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) . Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida. Si la notificaci\u00f3n es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante). Un ejemplo del c\u00f3digo en el que se gestiona la notificaci\u00f3n recibida: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { // Get the meeting ID from the original notification. let userInfo = response . notification . request . content . userInfo if response . notification . request . content . categoryIdentifier == MEETING_INVITATION { // Retrieve the meeting details. let meetingID = userInfo [ MEETING_ID ] as ! String let userID = userInfo [ USER_ID ] as ! String switch response . actionIdentifier { case ACCEPT_ACTION : sharedMeetingManager . acceptMeeting ( user : userID , meetingID : meetingID ) break case DECLINE_ACTION : sharedMeetingManager . declineMeeting ( user : userID , meetingID : meetingID ) break case UNNotificationDefaultActionIdentifier , UNNotificationDismissActionIdentifier : // Queue meeting-related notifications for later // if the user does not act. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) break default : break } } else { // Handle other notification types... } // Always call the completion handler when done. completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier , el contenido de la constante UNNotificationDefaultActionIdentifier .","title":"App en segundo plano"},{"location":"sesion02/sesion02-notificaciones.html#app-en-primer-plano","text":"En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Un ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { if notification . request . content . categoryIdentifier == MEETING_INVITATION { // Retrieve the meeting details. let meetingID = notification . request . content . userInfo [ MEETING_ID ] as ! String let userID = notification . request . content . userInfo [ USER_ID ] as ! String // Add the meeting to the queue. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) // Play a sound to let the user know about the invitation. completionHandler (. sound ) return } else { // Handle other notification types... } // Don t alert the user for other types. completionHandler ( UNNotificationPresentationOptions ( rawValue : 0 )) }","title":"App en primer plano"},{"location":"sesion02/sesion02-notificaciones.html#demo_1","text":"Probamos y examinamos el c\u00f3digo de la aplicaci\u00f3n de prueba que incluye acciones en la notificaci\u00f3n y que define las funciones de gesti\u00f3n de las notificaciones. Probamos a seleccionar distintas acciones y comprobar qu\u00e9 mensaje aparece por la salida est\u00e1ndar:","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-remotas-push","text":"","title":"Notificaciones remotas (push)"},{"location":"sesion02/sesion02-notificaciones.html#objetivos-de-las-notificaciones-remotas","text":"La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ).","title":"Objetivos de las notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#arquitectura-de-las-notificaciones-remotas","text":"El servicio Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos.","title":"Arquitectura de las notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#arquitectura-de-seguridad","text":"No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs.","title":"Arquitectura de seguridad"},{"location":"sesion02/sesion02-notificaciones.html#secuencia-de-registro-del-dispositivo","text":"Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs.","title":"Secuencia de registro del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#token-del-dispositivo","text":"Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo.","title":"Token del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#envio-de-notificacion-remota-usando-el-token","text":"Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado.","title":"Env\u00edo de notificaci\u00f3n remota usando el token"},{"location":"sesion02/sesion02-notificaciones.html#contenido-de-la-notificacion_1","text":"Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple . El tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes y debe tener el formato de un objeto JSON diccionario (parejas clave, valor). Un ejemplo en JSON: 1 2 3 4 5 6 7 8 9 10 11 { aps : { alert : { title : Introducci\u00f3n a las notificaciones , subtitle : Sesi\u00f3n 707 , body : La nueva API de notificaciones es genial!!! , category : mensaje , }, badge : 1 }, } El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: - Mensaje de alerta a mostrar al usuario - Numero a a\u00f1adir en el globo del icono de la app - Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. El usuario no recibir\u00e1 ninguna notificaci\u00f3n, pero ver\u00e1 el nuevo contenido la siguiente vez que abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app. Otros ejemplos de payload . N\u00famero en el badge y custom keys : 1 2 3 4 5 6 7 8 9 { aps : { alert : You got your emails. , badge : 9 , sound : bingbong.aiff }, acme1 : bar , acme2 : 42 } Notificaci\u00f3n con cadenas localizadas: 1 2 3 4 5 6 7 8 9 10 { aps : { alert : { loc-key : GAME_PLAY_REQUEST_FORMAT , loc-args : [ Jenna , Frank ] }, sound : chime.aiff }, acme : foo } Notificaci\u00f3n con acciones: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { aps : { alert\u201d : { \u201cbody\u201d : Acme message received from Johnny Appleseed\u201d , \u201caction-loc-key\u201d : \u201cVIEW\u201d, actions : [ { \u201cid : \u201cdelete , title : Delete }, { \u201cid : \u201creply-to\u201d, loc-key : \u201cREPLYTO\u201d, loc-args : [\u201cJane ] } ] } badge : 3 , sound : \u201cchime.aiff }, acme-account : jane.appleseed@apple.com , acme-message : message 123456 }","title":"Contenido de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#servidores-proveedores","text":"Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida por Apple basada en un protocolo HTTP/2 y TLS. Es posible montar un servidor propio usando librer\u00edas ya existentes. Por ejemplo, en Java existe la librer\u00eda Pushy . Es recomendable consultar la documentaci\u00f3n de Apple Setting Up a Remote Notification Server y Sending Notification Requests to APNs . La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal. En cualquier caso nuestro servidor deber\u00e1 conectarse al APNs usando una t\u00e9cnica segura: o bien un certificado proporcionado por Apple (es lo que haremos en la demostraci\u00f3n) o bien un token, usando JWT (JSON Web Token). Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"Servidores proveedores"},{"location":"sesion02/sesion02-notificaciones.html#gestion-de-las-notificaciones-remotas-en-la-app","text":"","title":"Gesti\u00f3n de las notificaciones remotas en la app"},{"location":"sesion02/sesion02-notificaciones.html#capacidad-de-notificacion-remota","text":"La app debe tener el permiso de usar las notificaciones remotas. Debe usar un perfil de aprovisionamiento con un App ID que otorgue ese permiso. Se puede hacer desde Xcode o desde el la web de desarrollador. En la demostraci\u00f3n lo haremos desde la web del programa de desarrollo de la universidad.","title":"Capacidad de notificaci\u00f3n remota"},{"location":"sesion02/sesion02-notificaciones.html#registro-de-las-notificaciones","text":"Para que una app trabaje con notificaciones remotas lo primero que debe hacerse, al igual que con las notificaciones locales, es pedir permiso al usuario. La forma de hacerlo es id\u00e9ntica a las de las notificaciones locales, usando el m\u00e9todo requestAuthorization(options:completionHandler:) . Una vez hecho esto, hay que conseguir el token asociado al dispositivo y la app registr\u00e1ndose en el Apple Push Notification service (APNs). Lo hace el m\u00e9todo registerForRemoteNotifications del objeto application. Se trata de un m\u00e9todo as\u00edncrono. Si el registro en el servicio tiene \u00e9xito, la app llama al m\u00e9todo application(_:didRegisterForRemoteNotificationsWithDeviceToken:) del delegado de la aplicaci\u00f3n pasando el token asignado que habr\u00e1 que incluir en las notificaciones que enviemos al dispositivo. Ejemplo de c\u00f3digo de registro de las notificaciones remotas: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } Ejemplo de obtenci\u00f3n del token e impresi\u00f3n en la consola: 1 2 3 4 5 6 7 8 9 10 11 12 13 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( Failed to register: , error ) }","title":"Registro de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#recepcion-de-las-notificaciones-en-la-app","text":"La gesti\u00f3n de las notificaciones recibidas es id\u00e9ntica a la ya vista en notificaciones locales, us\u00e1ndose exactamente los mismos manejadores, con la excepci\u00f3n de la posibilidad de gestionar notificaciones remotas cuando la app est\u00e1 en segundo plano. Recordemos los manejadores que ya vimos en las notificaciones locales: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate cuando llega la notificaci\u00f3n. Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . La diferencia de las notificaciones remotas es la posibilidad de definir el manejador application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app, que se activa cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 : 1 2 3 4 5 6 7 { aps : { content-available : 1 }, acme1 : bar , acme2 : 42 } Para que se llame al m\u00e9todo se debe activar la capability Background Modes Remote Notifications en Xcode. El m\u00e9todo se llama tanto si la app est\u00e1 en primer plano como si est\u00e1 en segundo plano. De hecho, es recomendable usarlo \u00fanicamente para gestionar notificaciones silenciosas que no se muestran al usuario sino que se usan para que la app pueda recuperar informaci\u00f3n del servidor que se mostrar\u00e1 la siguiente vez que el usuario lance la app. Por ello habr\u00eda que enviar un payload como el que hemos visto anteriormente. Con custom keys pero en el que el diccionario aps no contenga ninguna clave que disparare una interacci\u00f3n con el usuario.","title":"Recepci\u00f3n de las notificaciones en la app"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-app","text":"Ejemplo de app que usaremos para demostrar las notificaciones remotas: C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando la app est\u00e1 en primer plano : 1 2 3 4 5 6 7 8 9 10 11 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificaci\u00f3n primer plano ) let aps = notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let news = aps [ alert ] as ? String { createNewNewsItem ( text : news ) } // No mostramos la notificaci\u00f3n completionHandler ([]) } C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando ha sido accionada por el usuario : 1 2 3 4 5 6 7 8 9 10 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { print ( Usuario ha pulsado una notificaci\u00f3n ) let aps = response . notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let news = aps [ alert ] as ? String { createNewNewsItem ( text : news ) } completionHandler () } C\u00f3digo de gesti\u00f3n de una notificaci\u00f3n silenciosa : 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) - Void ) { print ( Recibida notificaci\u00f3n remota en background ) createNewNewsItem ( text : Notificaci\u00f3n silenciosa ) completionHandler ( UIBackgroundFetchResult . newData ) }","title":"Ejemplo de app"},{"location":"sesion02/sesion02-notificaciones.html#demo_2","text":"","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#pasos-necesarios-para-la-demo","text":"En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP que tendremos que configurar con: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push.","title":"Pasos necesarios para la demo"},{"location":"sesion02/sesion02-notificaciones.html#nuevo-app-id-en-el-member-center","text":"Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n. Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push.","title":"Nuevo App ID en el member center"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-certificado-ssl-en-el-member-center","text":"Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros Asistente de Certificados Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest . Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest","title":"Creaci\u00f3n del certificado SSL en el member center"},{"location":"sesion02/sesion02-notificaciones.html#generacion-del-fichero-pem","text":"Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros. Lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs: Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles19) Creamos el fichero .pem con el siguiente comando: 1 2 $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Una vez hecho esto, ya tendremos listo el certificado para enviar la notificaci\u00f3n push al APNs, usando el script PHP.","title":"Generaci\u00f3n del fichero .pem"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-perfil-de-aprovisionamiento","text":"Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"sesion02/sesion02-notificaciones.html#obtencion-del-token-del-dispositivo","text":"Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo y de la app que va a recibir la notificaci\u00f3n. Para ello debemos ejecutar la app en un dispositivo f\u00edsico (no funciona en el simulador).","title":"Obtenci\u00f3n del token del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#probamos-la-app-notificacionespush","text":"Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs. La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador. Anotamos el token del dispositivo que aparece en la consola al ejecutar la app por primera vez.","title":"Probamos la app NotificacionesPush"},{"location":"sesion02/sesion02-notificaciones.html#probamos-a-enviar-notificaciones-remotas-al-dispositivo","text":"Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: 1 2 3 $ php apnspush.php Hola mundo desde la UA Connected to APNS Message successfully delivered","title":"Probamos a enviar notificaciones remotas al dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#practica","text":"Descarga las apps Notificaciones y NotificacionesPush su c\u00f3digo y pru\u00e9balas. La primera puedes probarla en el simulador. La segunda deber\u00e1s probarla ejecut\u00e1ndola en un dispositivo real y enviando notificaciones remotas tal y como hemos hecho en la demo. Ejercicio 1: Modifica la app ToDoList para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2: Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3: A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n silenciosa enviada con una notificaci\u00f3n push. Utiliza el script PHP y este certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas.","title":"Pr\u00e1ctica"},{"location":"sesion02/sesion02-notificaciones.html#bibliografia","text":"Framework UserNotifications Asking Permission to Use Notifications Scheduling a Notification Locally from Your App Handling Notifications and Notification-Related Actions Registering Your App with APNs Generating a Remote Notification Pushing Updates to Your App Silently Setting Up a Remote Notification Server Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"Bibliograf\u00eda"},{"location":"sesion03/sesion03-icloud.html","text":"Sesi\u00f3n 3: iCloud y CloudKit iCloud iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros. Filosof\u00eda de iCloud para el usuario de iOS Un escenario frecuente es que un usuario tenga una app instalada en m\u00e1s de un dispositivo (un iPhone y un iPad, por ejemplo). Por ejemplo es muy com\u00fan usar la app de fotos, la del calendario, o las notas en cualquier dispositivo. En este escenario, la idea principal de iCloud es que el usuario pueda pasar de un dispositivo a otro y seguir trabajando con el mismo estado de la app tal y como la dej\u00f3 en el dispositivo anterior. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud. Cuenta iCloud Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID. Casi todos los usuarios de dispositivos Apple tienen activada esta cuenta. Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos asociados al mismo Apple ID: Recordatorios, Notas, etc. El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. De forma gratuita Apple proporciona 5Gb de espacio en la cuenta de iCloud. Nota La cuenta de iCloud puede activarse desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos . Distintas APIs Bajo el nombre gen\u00e9rico de iCloud, existen distintas APIs que Apple ha ido proporcionando a los desarrolladores para gestionar datos asociados a la cuenta de usuario: Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit : nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en la gesti\u00f3n en la nube de registros con diccionarios clave-valor, con un enfoque muy similar a las tecnolog\u00edas NoSQL. Se trata de un API de peticiones a los servidores en la nube, que no mantiene un estado local. Es conveniente usarla en combinaci\u00f3n con Core Data, si queremos hacer persistentes en local los datos existentes en la nube. Basada en peticiones y respuestas as\u00edncronas. Vamos a ver en esta sesi\u00f3n el almacenamiento clave-valor y CloudKit , que son las APIs m\u00e1s usadas. Preparaci\u00f3n de aprovisionamiento y permisos para iCloud Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo autom\u00e1ticamente desde Xcode. Creaci\u00f3n del App ID Para trabajar con iCloud clave-valor puedes utilizar el perfil de aprovisionamiento Master Moviles iCloud creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.iCloud . Tambi\u00e9n hemos actualizado el perfil Master Moviles ToDoList para incluir los permisos de uso de iCloud y CloudKit. Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Hemos creado el permiso (App ID) Master Moviles iCloud con el bundle name es.ua.mastermoviles.iCloud que incluye la capacidad de iCloud. La activaci\u00f3n del permiso de iCloud aparecer\u00e1 en amarillo porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). Pero es suficiente para trabajar con iCloud clave-valor. iCloud clave-valor API de almacenamiento clave-valor Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para gestionar estos valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: 1 let iCloudStore = NSUbiquitousKeyValueStore . default M\u00e9todo synchronize 1 func synchronize () - Bool Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano. Ejemplo de uso de synchronize al lanzar la app 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) - Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } } ... } Guardar valores en el almac\u00e9n de claves-valor Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: 1 store . set ( 100 , forKey : puntuacion ) Obtenci\u00f3n de valores del almac\u00e9n de claves-valor Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) - [Any]? bool(forKey: String) - Bool dictionary(forKey: String) - [String : Any]? string(forKey: String) - String? longLong(forKey: String) - Int64 ... forKey es el String que es la clave en el almac\u00e9n de claves-valor. Devuelve el valor asociado a la clave o nil si la clave no existe (0 en el caso de los m\u00e9todos que devuelven un valor num\u00e9rico). Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: 1 let puntuacion = Int ( store . longLong ( forKey : puntuacion )) Definici\u00f3n de un observador de cambios Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado. Por ejemplo, en el siguiente c\u00f3digo se registra como observador un m\u00e9todo de la propia clase AppDelegate : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) - Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } NotificationCenter . default . addObserver ( self , selector : #selector ( muestraValoriCloud ( notification :)), name : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : nil ) return true } @objc func muestraValoriCloud ( notification : Notification ){ let valoriCloud = Int ( store . longLong ( forKey : puntuaci\u00f3n )) // Actualizamos el valor en el controller } Demo Mostramos la app iCloudKeyValue , primero la versi\u00f3n sin comunicaci\u00f3n con iCloud clave-valor y despu\u00e9s la que utiliza iCloud clave-valor para guardar el valor del contador. Mostramos la app ejecut\u00e1ndose en dos dispositivos simult\u00e1neamente y mostrando c\u00f3mo los cambios en un dispositivo se actualizan en el otro. CloudKit Introducci\u00f3n a CloudKit El origen de CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Permite gestionar datos remotos ubicados en los servidores de iCloud propios de Apple. En los datos propios de la aplicaci\u00f3n (datos privados del usuario) el almacenamiento se imputa a las cuentas iCloud de los usuarios. Existe la posibilidad de datos p\u00fablicos, en un almacenamiento gestionado por el desarrollador (gratuito hasta una capacidad y de pago a partir de ella). Permite datos estructurados y datos bulk . Los datos est\u00e1n en la nube e iCloud proporciona una tecnolog\u00eda de transporte, basada en peticiones de registro, de lectura y de b\u00fasqueda. Los datos obtenidos se almacenan en la aplicaci\u00f3n. Si queremos hacerlos persistentes de forma local (para que est\u00e9n disponibles sin conexi\u00f3n) podemos utilizar otra tecnolog\u00eda como Core Data. Tecnolog\u00eda de transporte CloudKit no proporciona ninguna forma de almacenar datos localmente. Es un servicio para mover datos a y desde iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para iCloud y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen. Elementos de CloudKit Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias Contenedores M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Es posible compartir un contenedor entre varias apps , siempre que hayan sido desarrolladas por el mismo desarrollador. Cada contenedor tiene un nombre \u00fanico. El nombre del contenedor con el que trabaja la app se define en la configuraci\u00f3n de capabilities de Xcode y en el App ID del perfil de aprovisionamiento. Los contenedores no pueden borrarse. Clase CKContainer La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta. Datos p\u00fablicos y privados Se pueden guardar datos de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los datos p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los datos privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar datos en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro. Bases de datos Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos: Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : 1 2 3 let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase Dashboard Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores y bases de datos. https://icloud.developer.apple.com/dashboard/ La interfaz web permite: Crear, visualizar, editar y borrar tipos de registros, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue Ejemplo de visualizaci\u00f3n de tipos de registros: CloudKit trabaja sobre registros en iCloud CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. A diferencia de las bases de datos relacionales tradicionales, en las que el modelo de datos se basa en tablas, en CloudKit se trabaja con tipos de registros . Un tipo de registro se define din\u00e1micamente, en tiempo de ejecuci\u00f3n de la app, por un nombre y un conjunto de claves. Una instancia concreta de un registro tiene un identificador \u00fanico y es un diccionario de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros. Por ejemplo, en la siguiente figura se muestran dos tipos de registros con sus campos asociados. El nombre del primer tipo de registro es Artwork y el del segundo Artist . Nota En iCloud se dispone de dos tipos de entornos: el entorno de desarrollo y el de producci\u00f3n . Cuando se desarrolla la app se construyen de forma din\u00e1mica los tipos de registros, con sus identificadores y sus campos. Despu\u00e9s se debe desplegar estos tipos de registros al entorno de producci\u00f3n, en donde ya no es posible modificar los tipos de registro. Registros Una base de datos est\u00e1 compuesta de registros: Las instancias de registro son objetos de la clase CKRecord . Cada instancia es un conjunto de parejas clave y valor (determinados por el tipo de registro) y tiene un identificador \u00fanico, un objeto de la clase CKRecord.ID . Este identificador \u00fanico podemos proporcionarlo en el momento de creaci\u00f3n del registro o podemos dejar que se inicializa autom\u00e1ticamente, si no lo definimos. Para crear una instancia de registro es necesario identificar el tipo de registro, definido por un String : 1 let artistaRecord = CKRecord ( recordType : Artista ) Si es la primera vez que se crea un registro de ese tipo, se crea el tipo de registro din\u00e1micamente en la base de datos. Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): 1 2 3 4 artistaRecord [ artista ] = Jonhn Lennon let formatter = DateFormatter () formatter . dateFormat = yyyy/MM/dd artistaRecord [ fechanacimiento ] = formatter . date ( from : 1940/10/09 ) ! Datos en los registros Es posible definir los siguientes tipos de valores que pueden haber en los campos de los registros: NSString ( String ): Cadenas NSNumber ( Int , Double , ...): N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior Grabaci\u00f3n de registros Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). 1 2 3 4 privateDB . save ( toDoItemRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) in print ( Error: \\( String ( describing : error )) ) }) Relaciones entre registros: referencias Es posible definir relaciones entre los registros. Por ejemplo un Artwork est\u00e1 relacionado con un Artist . Son similares a las claves ajenas en el tradicional modelo relacional con las que se implementan relaciones muchos-a-uno. La clase CKReference es la utilizada para definir estas relaciones: 1 itemRecord [ owningList ] = CKReference ( record : listRecord , action : . deleteSelf ) La constante .deleteSelf indica que si el registro referenciado se borra, el propio registro tambi\u00e9n debe borrarse (borrado en cascada). La otra posible acci\u00f3n es .none . Queries Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation . Por ejemplo, la query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual es la siguiente (se ha a\u00f1adido c\u00f3digo de ejemplo en el que se actualiza el array de tareas por hacer y se actualiza la vista de la tabla) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let privateDB = CKContainer . default (). privateCloudDatabase let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( value : true )) privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { if let nombre = result [ nombre ] { let toDoItem = ToDoItem ( nombre : nombre as ! String , publica : false ) self . toDoItems . append ( toDoItem ) } } DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) } else { print ( Query error: \\( String ( describing : error )) ) } }) Importante Para que funcione la consulta que recupera todos los registros de un tipo hay que crear en el dashboard un \u00edndice queryable sobre el campo nativo recordName . Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) 1 2 let predicate = NSPredicate ( format : nombre BEGINSWITH Limpiar ) let predicate = NSPredicate ( format : favoriteColors CONTAINS red ) Operaciones con registros obtenidos Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func deleteTarea ( _ toDoItem : ToDoItem ) { let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( format : nombre == %@ , argumentArray : [ toDoItem . nombreItem ])) let publicDB = CKContainer . default (). publicCloudDatabase publicDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord publicDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( Error: \\( String ( describing : error )) ) }) } } }) } Caracter\u00edsticas sociales de CloudKit CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente. Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente. Ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let container = CKContainer . default () print ( Container: ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( Permiso concedido: + \\( permissionStatus == CKApplicationPermissionStatus . granted ) )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }}) Suscripciones Es posible hacer consultas \"permanentes\" que son ejecutadas en background por el servidor tras cada registro salvado. Generan notificaciones push con los resultados. CloudKit JS CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) Un ejemplo de aplicaci\u00f3n web presentado por Apple en el que se demuestra el uso de esta librer\u00eda CloudKit Catalog Demo Gesti\u00f3n en el member center Una de las opciones del member center permite gestionar contenedores de iCloud. Utilizaremos un contenedor con el identificador iCloud.es.ua.mastermoviles.ToDoList que utilizaremos en la app ToDoList . Asignaci\u00f3n del container al App ID Incluimos en el App ID Master Moviles ToDoList (con el bundle Id es.ua.mastermoviles.ToDoList ) el contenedor de iCloud anterior. Creaci\u00f3n del perfil de aprovisionamiento Actualizamos el perfil de aprovisionamiento Master Moviles ToDoList con el App ID anterior. Actualizaci\u00f3n de capacidades de la app ToDoList Ejecutamos la app ToDoList Ejecutamos la app ToDoList modificada para trabajar con CloudKit y comprobamos c\u00f3mo se guardan las tareas, a pesar de eliminarlas de la memoria. Las tareas se cargan de la base de datos cuando la app se inicializa, en el m\u00e9todo viewDidLoad . Mostramos c\u00f3mo se a\u00f1aden registros en las bases de datos p\u00fablicas y privadas. Dashboard Comprobamos tambi\u00e9n el Dashboard y vemos c\u00f3mo se actualiza conforme guardamos nuevos registros. El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. https://icloud.developer.apple.com/dashboard/ Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud. Los tipos de registros: Y los logs: Pr\u00e1ctica Pr\u00e1ctica: iCloud clave-valor Descarga la app iCloudKeyValue en la que se muestra un controller de tipo Stepper y una etiqueta con un n\u00famero que va cambiando seg\u00fan se pulsa el controller. Comprueba que si matas la app se pierde el valor introducido. Modifica la app, a\u00f1adiendo c\u00f3digo para que cada vez que se cambie el n\u00famero se guarde en iCloud clave-valor. Implementa tambi\u00e9n una notificaci\u00f3n para que si se modifica el valor en otro dispositivo se actualice en el dispositivo actual. Puedes probarlo modificando el valor en el simulador y deber\u00e1 actualizarse en un dispositivo f\u00edsico en el que est\u00e9s logeado con el mismo Apple ID (al rev\u00e9s no funciona: si cambias el valor en el dispositivo f\u00edsico, no se actualiza en el simulador, porque no funciona el NotificationCenter ). Pr\u00e1ctica: ToDoList en CloudKit Configuraci\u00f3n de la app: Seguimos trabajando con el proyecto ToDoList y el bundle ID es.ua.mastermoviles.ToDoList y el perfil de aprovisionamiento Master Moviles ToDoList (lo hemos actualizado para que incluya el permiso de acceso a CloudKit). Actualiza en Xcode el permiso para utilizar CloudKit y el contenedor iCloud.es.ua.mastermoviles.ToDoList . Desarrollo de la pr\u00e1ctica: A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. (Opcional): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Al a\u00f1adir una tarea debes permitir la opci\u00f3n de hacerlo en la base de datos p\u00fablica. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas. (Opcional): A\u00f1ade una funcionalidad en la que se recargue la tabla con los datos de iCloud cuando se tire de la tabla hacia abajo. Pista para actualizar la tabla Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoListTableViewController : 1 2 3 DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) Referencias CloudKit Documentation CloudKit Quick Start iCloud Design Guide Providing User Access to CloudKit Data Changing Access Controls on User Data Responding to Requests to Delete Data Identifying an App's Containers CloudKit JS","title":"Sesi\u00f3n 3 - iCloud"},{"location":"sesion03/sesion03-icloud.html#sesion-3-icloud-y-cloudkit","text":"","title":"Sesi\u00f3n 3: iCloud y CloudKit"},{"location":"sesion03/sesion03-icloud.html#icloud","text":"iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros.","title":"iCloud"},{"location":"sesion03/sesion03-icloud.html#filosofia-de-icloud-para-el-usuario-de-ios","text":"Un escenario frecuente es que un usuario tenga una app instalada en m\u00e1s de un dispositivo (un iPhone y un iPad, por ejemplo). Por ejemplo es muy com\u00fan usar la app de fotos, la del calendario, o las notas en cualquier dispositivo. En este escenario, la idea principal de iCloud es que el usuario pueda pasar de un dispositivo a otro y seguir trabajando con el mismo estado de la app tal y como la dej\u00f3 en el dispositivo anterior. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud.","title":"Filosof\u00eda de iCloud para el usuario de iOS"},{"location":"sesion03/sesion03-icloud.html#cuenta-icloud","text":"Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID. Casi todos los usuarios de dispositivos Apple tienen activada esta cuenta. Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos asociados al mismo Apple ID: Recordatorios, Notas, etc. El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. De forma gratuita Apple proporciona 5Gb de espacio en la cuenta de iCloud. Nota La cuenta de iCloud puede activarse desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos .","title":"Cuenta iCloud"},{"location":"sesion03/sesion03-icloud.html#distintas-apis","text":"Bajo el nombre gen\u00e9rico de iCloud, existen distintas APIs que Apple ha ido proporcionando a los desarrolladores para gestionar datos asociados a la cuenta de usuario: Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit : nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en la gesti\u00f3n en la nube de registros con diccionarios clave-valor, con un enfoque muy similar a las tecnolog\u00edas NoSQL. Se trata de un API de peticiones a los servidores en la nube, que no mantiene un estado local. Es conveniente usarla en combinaci\u00f3n con Core Data, si queremos hacer persistentes en local los datos existentes en la nube. Basada en peticiones y respuestas as\u00edncronas. Vamos a ver en esta sesi\u00f3n el almacenamiento clave-valor y CloudKit , que son las APIs m\u00e1s usadas.","title":"Distintas APIs"},{"location":"sesion03/sesion03-icloud.html#preparacion-de-aprovisionamiento-y-permisos-para-icloud","text":"Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo autom\u00e1ticamente desde Xcode.","title":"Preparaci\u00f3n de aprovisionamiento y permisos para iCloud"},{"location":"sesion03/sesion03-icloud.html#creacion-del-app-id","text":"Para trabajar con iCloud clave-valor puedes utilizar el perfil de aprovisionamiento Master Moviles iCloud creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.iCloud . Tambi\u00e9n hemos actualizado el perfil Master Moviles ToDoList para incluir los permisos de uso de iCloud y CloudKit. Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Hemos creado el permiso (App ID) Master Moviles iCloud con el bundle name es.ua.mastermoviles.iCloud que incluye la capacidad de iCloud. La activaci\u00f3n del permiso de iCloud aparecer\u00e1 en amarillo porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). Pero es suficiente para trabajar con iCloud clave-valor.","title":"Creaci\u00f3n del App ID"},{"location":"sesion03/sesion03-icloud.html#icloud-clave-valor","text":"","title":"iCloud clave-valor"},{"location":"sesion03/sesion03-icloud.html#api-de-almacenamiento-clave-valor","text":"Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para gestionar estos valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: 1 let iCloudStore = NSUbiquitousKeyValueStore . default","title":"API de almacenamiento clave-valor"},{"location":"sesion03/sesion03-icloud.html#metodo-synchronize","text":"1 func synchronize () - Bool Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano.","title":"M\u00e9todo synchronize"},{"location":"sesion03/sesion03-icloud.html#ejemplo-de-uso-de-synchronize-al-lanzar-la-app","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) - Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } } ... }","title":"Ejemplo de uso de synchronize al lanzar la app"},{"location":"sesion03/sesion03-icloud.html#guardar-valores-en-el-almacen-de-claves-valor","text":"Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: 1 store . set ( 100 , forKey : puntuacion )","title":"Guardar valores en el almac\u00e9n de claves-valor"},{"location":"sesion03/sesion03-icloud.html#obtencion-de-valores-del-almacen-de-claves-valor","text":"Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) - [Any]? bool(forKey: String) - Bool dictionary(forKey: String) - [String : Any]? string(forKey: String) - String? longLong(forKey: String) - Int64 ... forKey es el String que es la clave en el almac\u00e9n de claves-valor. Devuelve el valor asociado a la clave o nil si la clave no existe (0 en el caso de los m\u00e9todos que devuelven un valor num\u00e9rico). Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: 1 let puntuacion = Int ( store . longLong ( forKey : puntuacion ))","title":"Obtenci\u00f3n de valores del almac\u00e9n de claves-valor"},{"location":"sesion03/sesion03-icloud.html#definicion-de-un-observador-de-cambios","text":"Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado. Por ejemplo, en el siguiente c\u00f3digo se registra como observador un m\u00e9todo de la propia clase AppDelegate : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) - Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } NotificationCenter . default . addObserver ( self , selector : #selector ( muestraValoriCloud ( notification :)), name : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : nil ) return true } @objc func muestraValoriCloud ( notification : Notification ){ let valoriCloud = Int ( store . longLong ( forKey : puntuaci\u00f3n )) // Actualizamos el valor en el controller }","title":"Definici\u00f3n de un observador de cambios"},{"location":"sesion03/sesion03-icloud.html#demo","text":"Mostramos la app iCloudKeyValue , primero la versi\u00f3n sin comunicaci\u00f3n con iCloud clave-valor y despu\u00e9s la que utiliza iCloud clave-valor para guardar el valor del contador. Mostramos la app ejecut\u00e1ndose en dos dispositivos simult\u00e1neamente y mostrando c\u00f3mo los cambios en un dispositivo se actualizan en el otro.","title":"Demo"},{"location":"sesion03/sesion03-icloud.html#cloudkit","text":"","title":"CloudKit"},{"location":"sesion03/sesion03-icloud.html#introduccion-a-cloudkit","text":"El origen de CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Permite gestionar datos remotos ubicados en los servidores de iCloud propios de Apple. En los datos propios de la aplicaci\u00f3n (datos privados del usuario) el almacenamiento se imputa a las cuentas iCloud de los usuarios. Existe la posibilidad de datos p\u00fablicos, en un almacenamiento gestionado por el desarrollador (gratuito hasta una capacidad y de pago a partir de ella). Permite datos estructurados y datos bulk . Los datos est\u00e1n en la nube e iCloud proporciona una tecnolog\u00eda de transporte, basada en peticiones de registro, de lectura y de b\u00fasqueda. Los datos obtenidos se almacenan en la aplicaci\u00f3n. Si queremos hacerlos persistentes de forma local (para que est\u00e9n disponibles sin conexi\u00f3n) podemos utilizar otra tecnolog\u00eda como Core Data.","title":"Introducci\u00f3n a CloudKit"},{"location":"sesion03/sesion03-icloud.html#tecnologia-de-transporte","text":"CloudKit no proporciona ninguna forma de almacenar datos localmente. Es un servicio para mover datos a y desde iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para iCloud y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen.","title":"Tecnolog\u00eda de transporte"},{"location":"sesion03/sesion03-icloud.html#elementos-de-cloudkit","text":"Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias","title":"Elementos de CloudKit"},{"location":"sesion03/sesion03-icloud.html#contenedores","text":"M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Es posible compartir un contenedor entre varias apps , siempre que hayan sido desarrolladas por el mismo desarrollador. Cada contenedor tiene un nombre \u00fanico. El nombre del contenedor con el que trabaja la app se define en la configuraci\u00f3n de capabilities de Xcode y en el App ID del perfil de aprovisionamiento. Los contenedores no pueden borrarse.","title":"Contenedores"},{"location":"sesion03/sesion03-icloud.html#clase-ckcontainer","text":"La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta.","title":"Clase CKContainer"},{"location":"sesion03/sesion03-icloud.html#datos-publicos-y-privados","text":"Se pueden guardar datos de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los datos p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los datos privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar datos en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro.","title":"Datos p\u00fablicos y privados"},{"location":"sesion03/sesion03-icloud.html#bases-de-datos","text":"Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos: Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : 1 2 3 let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase","title":"Bases de datos"},{"location":"sesion03/sesion03-icloud.html#dashboard","text":"Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores y bases de datos. https://icloud.developer.apple.com/dashboard/ La interfaz web permite: Crear, visualizar, editar y borrar tipos de registros, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue Ejemplo de visualizaci\u00f3n de tipos de registros:","title":"Dashboard"},{"location":"sesion03/sesion03-icloud.html#cloudkit-trabaja-sobre-registros-en-icloud","text":"CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. A diferencia de las bases de datos relacionales tradicionales, en las que el modelo de datos se basa en tablas, en CloudKit se trabaja con tipos de registros . Un tipo de registro se define din\u00e1micamente, en tiempo de ejecuci\u00f3n de la app, por un nombre y un conjunto de claves. Una instancia concreta de un registro tiene un identificador \u00fanico y es un diccionario de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros. Por ejemplo, en la siguiente figura se muestran dos tipos de registros con sus campos asociados. El nombre del primer tipo de registro es Artwork y el del segundo Artist . Nota En iCloud se dispone de dos tipos de entornos: el entorno de desarrollo y el de producci\u00f3n . Cuando se desarrolla la app se construyen de forma din\u00e1mica los tipos de registros, con sus identificadores y sus campos. Despu\u00e9s se debe desplegar estos tipos de registros al entorno de producci\u00f3n, en donde ya no es posible modificar los tipos de registro.","title":"CloudKit trabaja sobre registros en iCloud"},{"location":"sesion03/sesion03-icloud.html#registros","text":"Una base de datos est\u00e1 compuesta de registros: Las instancias de registro son objetos de la clase CKRecord . Cada instancia es un conjunto de parejas clave y valor (determinados por el tipo de registro) y tiene un identificador \u00fanico, un objeto de la clase CKRecord.ID . Este identificador \u00fanico podemos proporcionarlo en el momento de creaci\u00f3n del registro o podemos dejar que se inicializa autom\u00e1ticamente, si no lo definimos. Para crear una instancia de registro es necesario identificar el tipo de registro, definido por un String : 1 let artistaRecord = CKRecord ( recordType : Artista ) Si es la primera vez que se crea un registro de ese tipo, se crea el tipo de registro din\u00e1micamente en la base de datos. Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): 1 2 3 4 artistaRecord [ artista ] = Jonhn Lennon let formatter = DateFormatter () formatter . dateFormat = yyyy/MM/dd artistaRecord [ fechanacimiento ] = formatter . date ( from : 1940/10/09 ) !","title":"Registros"},{"location":"sesion03/sesion03-icloud.html#datos-en-los-registros","text":"Es posible definir los siguientes tipos de valores que pueden haber en los campos de los registros: NSString ( String ): Cadenas NSNumber ( Int , Double , ...): N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior","title":"Datos en los registros"},{"location":"sesion03/sesion03-icloud.html#grabacion-de-registros","text":"Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). 1 2 3 4 privateDB . save ( toDoItemRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) in print ( Error: \\( String ( describing : error )) ) })","title":"Grabaci\u00f3n de registros"},{"location":"sesion03/sesion03-icloud.html#relaciones-entre-registros-referencias","text":"Es posible definir relaciones entre los registros. Por ejemplo un Artwork est\u00e1 relacionado con un Artist . Son similares a las claves ajenas en el tradicional modelo relacional con las que se implementan relaciones muchos-a-uno. La clase CKReference es la utilizada para definir estas relaciones: 1 itemRecord [ owningList ] = CKReference ( record : listRecord , action : . deleteSelf ) La constante .deleteSelf indica que si el registro referenciado se borra, el propio registro tambi\u00e9n debe borrarse (borrado en cascada). La otra posible acci\u00f3n es .none .","title":"Relaciones entre registros: referencias"},{"location":"sesion03/sesion03-icloud.html#queries","text":"Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation . Por ejemplo, la query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual es la siguiente (se ha a\u00f1adido c\u00f3digo de ejemplo en el que se actualiza el array de tareas por hacer y se actualiza la vista de la tabla) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let privateDB = CKContainer . default (). privateCloudDatabase let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( value : true )) privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { if let nombre = result [ nombre ] { let toDoItem = ToDoItem ( nombre : nombre as ! String , publica : false ) self . toDoItems . append ( toDoItem ) } } DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) } else { print ( Query error: \\( String ( describing : error )) ) } }) Importante Para que funcione la consulta que recupera todos los registros de un tipo hay que crear en el dashboard un \u00edndice queryable sobre el campo nativo recordName . Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) 1 2 let predicate = NSPredicate ( format : nombre BEGINSWITH Limpiar ) let predicate = NSPredicate ( format : favoriteColors CONTAINS red )","title":"Queries"},{"location":"sesion03/sesion03-icloud.html#operaciones-con-registros-obtenidos","text":"Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func deleteTarea ( _ toDoItem : ToDoItem ) { let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( format : nombre == %@ , argumentArray : [ toDoItem . nombreItem ])) let publicDB = CKContainer . default (). publicCloudDatabase publicDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord publicDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( Error: \\( String ( describing : error )) ) }) } } }) }","title":"Operaciones con registros obtenidos"},{"location":"sesion03/sesion03-icloud.html#caracteristicas-sociales-de-cloudkit","text":"CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente. Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente. Ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let container = CKContainer . default () print ( Container: ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( Permiso concedido: + \\( permissionStatus == CKApplicationPermissionStatus . granted ) )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }})","title":"Caracter\u00edsticas sociales de CloudKit"},{"location":"sesion03/sesion03-icloud.html#suscripciones","text":"Es posible hacer consultas \"permanentes\" que son ejecutadas en background por el servidor tras cada registro salvado. Generan notificaciones push con los resultados.","title":"Suscripciones"},{"location":"sesion03/sesion03-icloud.html#cloudkit-js","text":"CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) Un ejemplo de aplicaci\u00f3n web presentado por Apple en el que se demuestra el uso de esta librer\u00eda CloudKit Catalog","title":"CloudKit JS"},{"location":"sesion03/sesion03-icloud.html#demo_1","text":"","title":"Demo"},{"location":"sesion03/sesion03-icloud.html#gestion-en-el-member-center","text":"Una de las opciones del member center permite gestionar contenedores de iCloud. Utilizaremos un contenedor con el identificador iCloud.es.ua.mastermoviles.ToDoList que utilizaremos en la app ToDoList .","title":"Gesti\u00f3n en el member center"},{"location":"sesion03/sesion03-icloud.html#asignacion-del-container-al-app-id","text":"Incluimos en el App ID Master Moviles ToDoList (con el bundle Id es.ua.mastermoviles.ToDoList ) el contenedor de iCloud anterior.","title":"Asignaci\u00f3n del container al App ID"},{"location":"sesion03/sesion03-icloud.html#creacion-del-perfil-de-aprovisionamiento","text":"Actualizamos el perfil de aprovisionamiento Master Moviles ToDoList con el App ID anterior.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"sesion03/sesion03-icloud.html#actualizacion-de-capacidades-de-la-app-todolist","text":"","title":"Actualizaci\u00f3n de capacidades de la app ToDoList"},{"location":"sesion03/sesion03-icloud.html#ejecutamos-la-app-todolist","text":"Ejecutamos la app ToDoList modificada para trabajar con CloudKit y comprobamos c\u00f3mo se guardan las tareas, a pesar de eliminarlas de la memoria. Las tareas se cargan de la base de datos cuando la app se inicializa, en el m\u00e9todo viewDidLoad . Mostramos c\u00f3mo se a\u00f1aden registros en las bases de datos p\u00fablicas y privadas.","title":"Ejecutamos la app ToDoList"},{"location":"sesion03/sesion03-icloud.html#dashboard_1","text":"Comprobamos tambi\u00e9n el Dashboard y vemos c\u00f3mo se actualiza conforme guardamos nuevos registros. El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. https://icloud.developer.apple.com/dashboard/ Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud. Los tipos de registros: Y los logs:","title":"Dashboard"},{"location":"sesion03/sesion03-icloud.html#practica","text":"","title":"Pr\u00e1ctica"},{"location":"sesion03/sesion03-icloud.html#practica-icloud-clave-valor","text":"Descarga la app iCloudKeyValue en la que se muestra un controller de tipo Stepper y una etiqueta con un n\u00famero que va cambiando seg\u00fan se pulsa el controller. Comprueba que si matas la app se pierde el valor introducido. Modifica la app, a\u00f1adiendo c\u00f3digo para que cada vez que se cambie el n\u00famero se guarde en iCloud clave-valor. Implementa tambi\u00e9n una notificaci\u00f3n para que si se modifica el valor en otro dispositivo se actualice en el dispositivo actual. Puedes probarlo modificando el valor en el simulador y deber\u00e1 actualizarse en un dispositivo f\u00edsico en el que est\u00e9s logeado con el mismo Apple ID (al rev\u00e9s no funciona: si cambias el valor en el dispositivo f\u00edsico, no se actualiza en el simulador, porque no funciona el NotificationCenter ).","title":"Pr\u00e1ctica: iCloud clave-valor"},{"location":"sesion03/sesion03-icloud.html#practica-todolist-en-cloudkit","text":"Configuraci\u00f3n de la app: Seguimos trabajando con el proyecto ToDoList y el bundle ID es.ua.mastermoviles.ToDoList y el perfil de aprovisionamiento Master Moviles ToDoList (lo hemos actualizado para que incluya el permiso de acceso a CloudKit). Actualiza en Xcode el permiso para utilizar CloudKit y el contenedor iCloud.es.ua.mastermoviles.ToDoList . Desarrollo de la pr\u00e1ctica: A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. (Opcional): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Al a\u00f1adir una tarea debes permitir la opci\u00f3n de hacerlo en la base de datos p\u00fablica. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas. (Opcional): A\u00f1ade una funcionalidad en la que se recargue la tabla con los datos de iCloud cuando se tire de la tabla hacia abajo.","title":"Pr\u00e1ctica: ToDoList en CloudKit"},{"location":"sesion03/sesion03-icloud.html#pista-para-actualizar-la-tabla","text":"Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoListTableViewController : 1 2 3 DispatchQueue . main . async ( execute : { self . tableView . reloadData () })","title":"Pista para actualizar la tabla"},{"location":"sesion03/sesion03-icloud.html#referencias","text":"CloudKit Documentation CloudKit Quick Start iCloud Design Guide Providing User Access to CloudKit Data Changing Access Controls on User Data Responding to Requests to Delete Data Identifying an App's Containers CloudKit JS","title":"Referencias"},{"location":"sesion04/sesion04-mapas-localizacion.html","text":"Sesi\u00f3n 4: Mapas y localizaci\u00f3n MapKit Aspectos b\u00e1sicos de MapKit Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, etc. Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps. Aspectos b\u00e1sicos de MapKit Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir. Un ejemplo de la app Mapas mostrando una vista 3D de Alicante: Geometr\u00eda de los mapas Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: 1 2 let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) Otros puntos Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas. Permisos para activar los mapas en nuestra app Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y las pruebas. A\u00f1adir un mapa en nuestra app La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que cumpla el protocolo MKMapViewDelegate . Ejemplo de c\u00f3digo para a\u00f1adir un mapa mediante programa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 30 , width : self . view . frame . width , height : 200 )) self . view . addSubview ( map ) map . delegate = self } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () } } El resultado tiene el siguiente aspecto: Inicializaci\u00f3n del mapa Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. } @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) let initialLocation = CLLocation ( latitude : alicanteLocation . latitude , longitude : alicanteLocation . longitude ) centerMapOnLocation ( mapView : mapView , loc : initialLocation ) } } func centerMapOnLocation ( mapView : MKMapView , loc : CLLocation ) { let regionRadius : CLLocationDistance = 1000 let coordinateRegion = MKCoordinateRegionMakeWithDistance ( loc . coordinate , regionRadius * 4.0 , regionRadius * 4.0 ) mapView . setRegion ( coordinateRegion , animated : true ) } ... } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado MKMapViewDelegate a un objeto que defina las funciones de este delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado. La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, el c\u00f3digo anterior centra el mapa en Alicante y muestra una zona de 4 km. de alto y ancho. Tipos de mapas La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: 1 2 3 4 5 enum MKMapType : UInt { case standard case satellite case hybrid } Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } } Uso del delegado El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. Por ejemplo: 1 2 3 func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) ) } Anotaciones Las anotaciones permiten resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n. Clases relacionadas Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa (una \"chincheta\" por defecto). El protocolo MKAnnotation El protocolo MKAnnotation define los m\u00e9todos que deben cumplir los objetos que vayan a implementar una anotaci\u00f3n: 1 2 3 var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } coordinate : coordenadas de la anotaci\u00f3n title : cadena mostrada en el callout subtitle : cadena subt\u00edtulo mostrada en el callout Podemos conformar el protocolo en cualquier clase. Por ejemplo, podemos definir una clase Pin : 1 2 3 4 5 6 7 8 9 10 11 12 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate super . init () } } MKAnnotationView La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image y definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta). Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa . Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. 1 2 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar. Por ejemplo: 1 2 3 4 5 6 7 8 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { print ( Devolviendo vista para anotaci\u00f3n: \\( annotation ) ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; } A\u00f1adir anotaciones en el mapa Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): 1 2 let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin ) Elementos en el callout Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure . Por ejemplo, podemos mostrar im\u00e1genes en la parte izquierda del callout , un thumbnail con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Podemos guardar la imagen en el objeto modelo annotation y despu\u00e9s inicializar la imagen del callout con esa imagen. Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar. Podr\u00edamos tambi\u00e9n tener una colecci\u00f3n de im\u00e1genes y guardar en el pin la m\u00e1s cercana a sus coordenadas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : alicante1_thumb.png ) ! } else { self . thumbImage = UIImage ( named : alicante2_thumb.png ) ! } super . init () } } La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 func mapView ( mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { // // el mismo c\u00f3digo que antes // let pin = annotation as ! Pin let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin . thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButtonType . detailDisclosure ) return view } Overlays Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com . Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa. Un ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View : 1 2 3 4 5 6 7 8 9 10 class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } } El overlay debe a\u00f1adirse al mapView : 1 2 let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: 1 2 3 4 5 6 7 8 9 10 11 12 func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) - MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : overlay_park )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () } Geocoding El API de MapKit proporciona funcionalidades para realizar geocoding , transformar coordenadas del mapa en nombres de lugares y vicersa. La clase CLGeocoder proporciona un API que realiza estas operaciones realizando peticiones a un servicio de Apple. Debemos crear un objeto geocoder y realizar una petici\u00f3n llamando a uno de sus m\u00e9todos de forward geocoding o reverse geocoding . Las peticiones de reverse geocoding toman una longitud y latitud y obtienen una direcci\u00f3n con nombres. Las peticiones de forward geocoding hacen al rev\u00e9s: toman una direcci\u00f3n con nombres y buscan la correspondiente latitud y longitud. Estas peticiones pueden tambi\u00e9n devolver informaci\u00f3n adicional acerca de la localizaci\u00f3n especificada, como un punto de inter\u00e9s o un edificio en esa localizaci\u00f3n. El objeto devuelto en ambos tipos de peticiones es un CLPlacemark . En el caso de peticiones forward geocoding se puede devolver una lista de lugares a los que corresponde la direcci\u00f3n suministrada. Un placemark (marca de lugar) contiene propiedades para especificar el nombre de una calle, de una ciudad o de un pa\u00eds. Tambi\u00e9n contienen propiedades que describen caracter\u00edsticas geogr\u00e1ficas relevantes o puntos de inter\u00e9s en la localizaci\u00f3n, como los nombres de monta\u00f1as, r\u00edos, negocios o localizaciones. Existe un l\u00edmite en el ratio de peticiones de geocoding que puede hacer una app. Si se hacen demasiadas peticiones en un tiempo peque\u00f1o puede producirse un error. Conversi\u00f3n de localizaci\u00f3n en placemarks Con el m\u00e9todo reverseGeocodeLocation se puede obtener una lista de placemarks asociadas a unas coordenadas. Las llamadas al objeto geocoder son as\u00edncronas y hay que pasarle al m\u00e9todo una clausura completion handler . Un ejemplo de uso: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func lookUpCurrentLocation ( completionHandler : @ escaping ( CLPlacemark ?) - Void ) { // Use the last reported location. if let lastLocation = self . locationManager . location { let geocoder = CLGeocoder () // Look up the location and pass it to the completion handler geocoder . reverseGeocodeLocation ( lastLocation , completionHandler : { ( placemarks , error ) in if error == nil { let firstLocation = placemarks ?[ 0 ] completionHandler ( firstLocation ) } else { // An error occurred during geocoding. completionHandler ( nil ) } }) } else { // No location was available. completionHandler ( nil ) } } Conversi\u00f3n de placemarks en localizaciones Con el m\u00e9todo geocodeAddressString se puede pasar una direcci\u00f3n al geocoder y obtener una lista de lugares asociados ( placemarks ). Se obtendr\u00e1n menos lugares cuanto m\u00e1s precisa sea la direcci\u00f3n. Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getCoordinate ( addressString : String , completionHandler : @ escaping ( CLLocationCoordinate2D , NSError ?) - Void ) { let geocoder = CLGeocoder () geocoder . geocodeAddressString ( addressString ) { ( placemarks , error ) in if error == nil { if let placemark = placemarks ?[ 0 ] { let location = placemark . location ! completionHandler ( location . coordinate , nil ) return } } completionHandler ( kCLLocationCoordinate2DInvalid , error as NSError ?) } } Otras caracter\u00edsticas: b\u00fasquedas, rutas y 3D No tenemos tiempo de verlo, pero el API tambi\u00e9n proporciona la posibilidad de realizar b\u00fasquedas y rutas en los mapas: As\u00ed como la posibilidad de mostrar el mapa en 3D: Localizaci\u00f3n Mediante el framework Core Location es posible obtener la localizaci\u00f3n del dispositivo m\u00f3vil. Los datos de localizaci\u00f3n pueden ser muy \u00fatiles para proporcionar servicios al usuario en distintos tipos de apps, como redes sociales, compras o navegaci\u00f3n. Este framework proporciona bastantes funcionalidades que podemos usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones nos permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda. La clase principal del framework es CLLocationManager . Activaci\u00f3n de los servicios de localizaci\u00f3n Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS. Solicitar informaci\u00f3n al usuario Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n. Clase CLLocationManager Se debe crear una instancia de la clase CLLocation\u200bManager . Se necesita mantener una referencia a esta instancia que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, no debemos almacenar una referencia al location manager en una variable local. La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() . Ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ... Monitorizaci\u00f3n de la localizaci\u00f3n Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): 1 2 3 func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones } Clase CLLocation La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description Activaci\u00f3n de la localizaci\u00f3n en el mapa Una vez activado el servicio de localizaci\u00f3n se puede visualizar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton } Prueba de la localizaci\u00f3n en el simulador Es posible probar los servicios de localizaci\u00f3n desde el simulador. Pare ello se debe seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug Location y escoger una de las siguientes opciones: Ninguna (se desactiva la localizadi\u00f3n) Custom (se puede definir una localizaci\u00f3n) Apple (localizaci\u00f3n de Apple en San Francisco) City Bicycle Ride (Simulaci\u00f3n de un paseo en bicicleta) City Run (Simulaci\u00f3n de una carrera por la ciudad) Freeway Ride (Simulaci\u00f3n de un recorrido en coche) Pr\u00e1ctica Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incl\u00fayelo en un Navigation Controller con la opci\u00f3n Editor Embed In Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control. En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa. A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n. Parte opcional 1 Implementa un segue que haga aparecer otra vista con un detalle de la foto. Pista 1 (Segue): 1 2 3 4 5 6 7 8 9 10 11 12 13 func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : DetalleImagen , sender : view ) } override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if segue . identifier == DetalleImagen { if let pin = ( sender as ? MKAnnotationView )?. annotation as ? Pin { if let vc = segue . destination as ? MiImageViewController { vc . imageDetail = pin . thumbImage } } } } Pista 2 ( ViewController de la vista detalle): 1 2 3 4 5 6 7 8 9 10 11 12 class ImageDetailViewController : UIViewController { @IBOutlet weak var imageView : UIImageView ! var imageDetail : UIImage ? = nil override func viewDidLoad () { super . viewDidLoad () if imageDetail != nil { imageView . image = imageDetail ! } } } Parte opcional 2 Implementa una llamada al servicio de geolocalizaci\u00f3n que coloque como subt\u00edtulo del Pin el pa\u00eds en el que se ha colocado el mismo. Parte opcional 3 A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) ) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Si la anotaci\u00f3n que se quiere mostrar no es de tipo Pin debes poner la vista a nil para que se use la vista por defecto (el c\u00edrculo). Referencias Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide Map Kit Framework Reference Core Location Framework Reference Converting a User's Location to a Descriptive Placemark Converting Between Coordinates and User-Friendly Place Names","title":"Sesi\u00f3n 4 - Mapas y localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#sesion-4-mapas-y-localizacion","text":"","title":"Sesi\u00f3n 4: Mapas y localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#mapkit","text":"","title":"MapKit"},{"location":"sesion04/sesion04-mapas-localizacion.html#aspectos-basicos-de-mapkit","text":"Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, etc. Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps.","title":"Aspectos b\u00e1sicos de MapKit"},{"location":"sesion04/sesion04-mapas-localizacion.html#aspectos-basicos-de-mapkit_1","text":"Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir. Un ejemplo de la app Mapas mostrando una vista 3D de Alicante:","title":"Aspectos b\u00e1sicos de MapKit"},{"location":"sesion04/sesion04-mapas-localizacion.html#geometria-de-los-mapas","text":"Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: 1 2 let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 )","title":"Geometr\u00eda de los mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#otros-puntos","text":"Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas.","title":"Otros puntos"},{"location":"sesion04/sesion04-mapas-localizacion.html#permisos-para-activar-los-mapas-en-nuestra-app","text":"Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y las pruebas.","title":"Permisos para activar los mapas en nuestra app"},{"location":"sesion04/sesion04-mapas-localizacion.html#anadir-un-mapa-en-nuestra-app","text":"La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que cumpla el protocolo MKMapViewDelegate . Ejemplo de c\u00f3digo para a\u00f1adir un mapa mediante programa: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 30 , width : self . view . frame . width , height : 200 )) self . view . addSubview ( map ) map . delegate = self } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () } } El resultado tiene el siguiente aspecto:","title":"A\u00f1adir un mapa en nuestra app"},{"location":"sesion04/sesion04-mapas-localizacion.html#inicializacion-del-mapa","text":"Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. } @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) let initialLocation = CLLocation ( latitude : alicanteLocation . latitude , longitude : alicanteLocation . longitude ) centerMapOnLocation ( mapView : mapView , loc : initialLocation ) } } func centerMapOnLocation ( mapView : MKMapView , loc : CLLocation ) { let regionRadius : CLLocationDistance = 1000 let coordinateRegion = MKCoordinateRegionMakeWithDistance ( loc . coordinate , regionRadius * 4.0 , regionRadius * 4.0 ) mapView . setRegion ( coordinateRegion , animated : true ) } ... } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado MKMapViewDelegate a un objeto que defina las funciones de este delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado. La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, el c\u00f3digo anterior centra el mapa en Alicante y muestra una zona de 4 km. de alto y ancho.","title":"Inicializaci\u00f3n del mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#tipos-de-mapas","text":"La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: 1 2 3 4 5 enum MKMapType : UInt { case standard case satellite case hybrid }","title":"Tipos de mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#ejemplo-de-seleccion-del-tipo-de-mapa-con-un-segmentedcontrol","text":"Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } }","title":"Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl"},{"location":"sesion04/sesion04-mapas-localizacion.html#uso-del-delegado","text":"El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. Por ejemplo: 1 2 3 func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) ) }","title":"Uso del delegado"},{"location":"sesion04/sesion04-mapas-localizacion.html#anotaciones","text":"Las anotaciones permiten resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n.","title":"Anotaciones"},{"location":"sesion04/sesion04-mapas-localizacion.html#clases-relacionadas","text":"Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa (una \"chincheta\" por defecto).","title":"Clases relacionadas"},{"location":"sesion04/sesion04-mapas-localizacion.html#el-protocolo-mkannotation","text":"El protocolo MKAnnotation define los m\u00e9todos que deben cumplir los objetos que vayan a implementar una anotaci\u00f3n: 1 2 3 var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } coordinate : coordenadas de la anotaci\u00f3n title : cadena mostrada en el callout subtitle : cadena subt\u00edtulo mostrada en el callout Podemos conformar el protocolo en cualquier clase. Por ejemplo, podemos definir una clase Pin : 1 2 3 4 5 6 7 8 9 10 11 12 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate super . init () } }","title":"El protocolo MKAnnotation"},{"location":"sesion04/sesion04-mapas-localizacion.html#mkannotationview","text":"La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image y definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta). Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa . Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. 1 2 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar. Por ejemplo: 1 2 3 4 5 6 7 8 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { print ( Devolviendo vista para anotaci\u00f3n: \\( annotation ) ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; }","title":"MKAnnotationView"},{"location":"sesion04/sesion04-mapas-localizacion.html#anadir-anotaciones-en-el-mapa","text":"Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): 1 2 let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin )","title":"A\u00f1adir anotaciones en el mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#elementos-en-el-callout","text":"Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure . Por ejemplo, podemos mostrar im\u00e1genes en la parte izquierda del callout , un thumbnail con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Podemos guardar la imagen en el objeto modelo annotation y despu\u00e9s inicializar la imagen del callout con esa imagen. Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar. Podr\u00edamos tambi\u00e9n tener una colecci\u00f3n de im\u00e1genes y guardar en el pin la m\u00e1s cercana a sus coordenadas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : alicante1_thumb.png ) ! } else { self . thumbImage = UIImage ( named : alicante2_thumb.png ) ! } super . init () } } La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 func mapView ( mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { // // el mismo c\u00f3digo que antes // let pin = annotation as ! Pin let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin . thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButtonType . detailDisclosure ) return view }","title":"Elementos en el callout"},{"location":"sesion04/sesion04-mapas-localizacion.html#overlays","text":"Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com . Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa. Un ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View : 1 2 3 4 5 6 7 8 9 10 class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } } El overlay debe a\u00f1adirse al mapView : 1 2 let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: 1 2 3 4 5 6 7 8 9 10 11 12 func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) - MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : overlay_park )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () }","title":"Overlays"},{"location":"sesion04/sesion04-mapas-localizacion.html#geocoding","text":"El API de MapKit proporciona funcionalidades para realizar geocoding , transformar coordenadas del mapa en nombres de lugares y vicersa. La clase CLGeocoder proporciona un API que realiza estas operaciones realizando peticiones a un servicio de Apple. Debemos crear un objeto geocoder y realizar una petici\u00f3n llamando a uno de sus m\u00e9todos de forward geocoding o reverse geocoding . Las peticiones de reverse geocoding toman una longitud y latitud y obtienen una direcci\u00f3n con nombres. Las peticiones de forward geocoding hacen al rev\u00e9s: toman una direcci\u00f3n con nombres y buscan la correspondiente latitud y longitud. Estas peticiones pueden tambi\u00e9n devolver informaci\u00f3n adicional acerca de la localizaci\u00f3n especificada, como un punto de inter\u00e9s o un edificio en esa localizaci\u00f3n. El objeto devuelto en ambos tipos de peticiones es un CLPlacemark . En el caso de peticiones forward geocoding se puede devolver una lista de lugares a los que corresponde la direcci\u00f3n suministrada. Un placemark (marca de lugar) contiene propiedades para especificar el nombre de una calle, de una ciudad o de un pa\u00eds. Tambi\u00e9n contienen propiedades que describen caracter\u00edsticas geogr\u00e1ficas relevantes o puntos de inter\u00e9s en la localizaci\u00f3n, como los nombres de monta\u00f1as, r\u00edos, negocios o localizaciones. Existe un l\u00edmite en el ratio de peticiones de geocoding que puede hacer una app. Si se hacen demasiadas peticiones en un tiempo peque\u00f1o puede producirse un error.","title":"Geocoding"},{"location":"sesion04/sesion04-mapas-localizacion.html#conversion-de-localizacion-en-placemarks","text":"Con el m\u00e9todo reverseGeocodeLocation se puede obtener una lista de placemarks asociadas a unas coordenadas. Las llamadas al objeto geocoder son as\u00edncronas y hay que pasarle al m\u00e9todo una clausura completion handler . Un ejemplo de uso: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func lookUpCurrentLocation ( completionHandler : @ escaping ( CLPlacemark ?) - Void ) { // Use the last reported location. if let lastLocation = self . locationManager . location { let geocoder = CLGeocoder () // Look up the location and pass it to the completion handler geocoder . reverseGeocodeLocation ( lastLocation , completionHandler : { ( placemarks , error ) in if error == nil { let firstLocation = placemarks ?[ 0 ] completionHandler ( firstLocation ) } else { // An error occurred during geocoding. completionHandler ( nil ) } }) } else { // No location was available. completionHandler ( nil ) } }","title":"Conversi\u00f3n de localizaci\u00f3n en placemarks"},{"location":"sesion04/sesion04-mapas-localizacion.html#conversion-de-placemarks-en-localizaciones","text":"Con el m\u00e9todo geocodeAddressString se puede pasar una direcci\u00f3n al geocoder y obtener una lista de lugares asociados ( placemarks ). Se obtendr\u00e1n menos lugares cuanto m\u00e1s precisa sea la direcci\u00f3n. Ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func getCoordinate ( addressString : String , completionHandler : @ escaping ( CLLocationCoordinate2D , NSError ?) - Void ) { let geocoder = CLGeocoder () geocoder . geocodeAddressString ( addressString ) { ( placemarks , error ) in if error == nil { if let placemark = placemarks ?[ 0 ] { let location = placemark . location ! completionHandler ( location . coordinate , nil ) return } } completionHandler ( kCLLocationCoordinate2DInvalid , error as NSError ?) } }","title":"Conversi\u00f3n de placemarks en localizaciones"},{"location":"sesion04/sesion04-mapas-localizacion.html#otras-caracteristicas-busquedas-rutas-y-3d","text":"No tenemos tiempo de verlo, pero el API tambi\u00e9n proporciona la posibilidad de realizar b\u00fasquedas y rutas en los mapas: As\u00ed como la posibilidad de mostrar el mapa en 3D:","title":"Otras caracter\u00edsticas: b\u00fasquedas, rutas y 3D"},{"location":"sesion04/sesion04-mapas-localizacion.html#localizacion","text":"Mediante el framework Core Location es posible obtener la localizaci\u00f3n del dispositivo m\u00f3vil. Los datos de localizaci\u00f3n pueden ser muy \u00fatiles para proporcionar servicios al usuario en distintos tipos de apps, como redes sociales, compras o navegaci\u00f3n. Este framework proporciona bastantes funcionalidades que podemos usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones nos permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda. La clase principal del framework es CLLocationManager .","title":"Localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#activacion-de-los-servicios-de-localizacion","text":"Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS.","title":"Activaci\u00f3n de los servicios de localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#solicitar-informacion-al-usuario","text":"Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n.","title":"Solicitar informaci\u00f3n al usuario"},{"location":"sesion04/sesion04-mapas-localizacion.html#clase-cllocationmanager","text":"Se debe crear una instancia de la clase CLLocation\u200bManager . Se necesita mantener una referencia a esta instancia que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, no debemos almacenar una referencia al location manager en una variable local. La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() . Ejemplo de c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ...","title":"Clase CLLocationManager"},{"location":"sesion04/sesion04-mapas-localizacion.html#monitorizacion-de-la-localizacion","text":"Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): 1 2 3 func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones }","title":"Monitorizaci\u00f3n de la localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#clase-cllocation","text":"La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description","title":"Clase CLLocation"},{"location":"sesion04/sesion04-mapas-localizacion.html#activacion-de-la-localizacion-en-el-mapa","text":"Una vez activado el servicio de localizaci\u00f3n se puede visualizar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton }","title":"Activaci\u00f3n de la localizaci\u00f3n en el mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#prueba-de-la-localizacion-en-el-simulador","text":"Es posible probar los servicios de localizaci\u00f3n desde el simulador. Pare ello se debe seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug Location y escoger una de las siguientes opciones: Ninguna (se desactiva la localizadi\u00f3n) Custom (se puede definir una localizaci\u00f3n) Apple (localizaci\u00f3n de Apple en San Francisco) City Bicycle Ride (Simulaci\u00f3n de un paseo en bicicleta) City Run (Simulaci\u00f3n de una carrera por la ciudad) Freeway Ride (Simulaci\u00f3n de un recorrido en coche)","title":"Prueba de la localizaci\u00f3n en el simulador"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica","text":"Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incl\u00fayelo en un Navigation Controller con la opci\u00f3n Editor Embed In Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control. En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa. A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n. Parte opcional 1 Implementa un segue que haga aparecer otra vista con un detalle de la foto. Pista 1 (Segue): 1 2 3 4 5 6 7 8 9 10 11 12 13 func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : DetalleImagen , sender : view ) } override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if segue . identifier == DetalleImagen { if let pin = ( sender as ? MKAnnotationView )?. annotation as ? Pin { if let vc = segue . destination as ? MiImageViewController { vc . imageDetail = pin . thumbImage } } } } Pista 2 ( ViewController de la vista detalle): 1 2 3 4 5 6 7 8 9 10 11 12 class ImageDetailViewController : UIViewController { @IBOutlet weak var imageView : UIImageView ! var imageDetail : UIImage ? = nil override func viewDidLoad () { super . viewDidLoad () if imageDetail != nil { imageView . image = imageDetail ! } } } Parte opcional 2 Implementa una llamada al servicio de geolocalizaci\u00f3n que coloque como subt\u00edtulo del Pin el pa\u00eds en el que se ha colocado el mismo. Parte opcional 3 A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) ) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Si la anotaci\u00f3n que se quiere mostrar no es de tipo Pin debes poner la vista a nil para que se use la vista por defecto (el c\u00edrculo).","title":"Pr\u00e1ctica"},{"location":"sesion04/sesion04-mapas-localizacion.html#referencias","text":"Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide Map Kit Framework Reference Core Location Framework Reference Converting a User's Location to a Descriptive Placemark Converting Between Coordinates and User-Friendly Place Names","title":"Referencias"},{"location":"sesion05/sesion05-extensiones.html","text":"Sesi\u00f3n 5: Extensiones Extensiones Introducci\u00f3n Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo). Targets Las extensiones se incluyen en el proyecto como targets adicionales que acompa\u00f1an a la app principal. Un target especifica un producto a construir por Xcode. Por ejemplo, si cuando creamos un proyecto escogemos a\u00f1adir tests unitarios y de UI, Xcode introduce autom\u00e1ticamente estos targets, adem\u00e1s de la app principal. Para a\u00f1adir manualmente un nuevo target al proyecto podemos seleccionar el bot\u00f3n + en la parte de abajo o la opci\u00f3n Editor Add Target... . Podemos seleccionar el target y especificar sus caracter\u00edsticas en el panel principal. Hay que especificar los mismos elementos que para una app principal (de hecho los targets son como mini apps): Bundle Id, versi\u00f3n, build Certificado y perfil de aprovisionamiento Permisos ( capabilities ) Configuraci\u00f3n y reglas del build Esquema Cada target tiene una configuraci\u00f3n autom\u00e1tica de construcci\u00f3n definida por su esquema ( schema ). Un esquema es una colecci\u00f3n de configuraciones que especifican las acciones a realizar para la compilaci\u00f3n del target y el entorno ejecutable a usar para lanzar el producto. Cuando abrimos o creamos un proyecto, Xcode crea autom\u00e1ticamente un esquema para cada target . El men\u00fa de esquemas se puede usar para cambiar el esquema activo y el destino. Podemos usar tambi\u00e9n el men\u00fa de esquemas para crear, editar y gestionar esquemas y para a\u00f1adir y descartar simuladores. Los esquemas y los destinos son distintos. Los destinos especifican d\u00f3nde instalar la app (dispositivos f\u00edsicos y simuladores). Los esquemas especifican los ajustes para compilar, ejecutar, testear, monitorizar, analizar y archivar el proyecto. Estos ajustes se pueden configurar en la opci\u00f3n de editar esquema. Ejemplo de extensi\u00f3n: Compartir Veamos un ejemplo concreto, la extensi\u00f3n Compartir ( Share Extension ). Muchas aplicaciones proporcionan el punto de extensi\u00f3n Compartir, en el que se pueden instalar extensiones de tipo Share Extension . Por ejemplo, en la siguiente imagen vemos como se puede acceder a la opci\u00f3n de compartir en una p\u00e1gina del navegador Safari y c\u00f3mo el usuario puede acceder a las extensiones que se han a\u00f1adido. La extensi\u00f3n Compartir hereda un ViewController por defecto de tipo SLComposeServiceViewController que contiene entre otros: Un campo de texto que puede editar el usuario, Una previsualizaci\u00f3n del objeto a compartir Los botones Cancel y Post La extensi\u00f3n puede configurar algunos aspectos de este ViewController . Por ejemplo, puede a\u00f1adir una opci\u00f3n en la parte inferior en la que el usuario pueda seleccionar d\u00f3nde compartir. Por ejemplo, esto se hace en la extensi\u00f3n adaptada por la app Recordatorios , en la que se da la opci\u00f3n de seleccionar el recordatorio en el que se quiere a\u00f1adir la p\u00e1gina. SLComposeServiceViewController Cuando creamos una extensi\u00f3n (m\u00e1s adelante haremos una demostraci\u00f3n) Xcode crea una plantilla inicial de c\u00f3digo. En el caso de una extensi\u00f3n Compartir la plantilla define un view controller hijo de SLComposeServiceViewController en el que podemos configurar el funcionamiento de la extensi\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import UIKit import Social class ShareViewController : SLComposeServiceViewController { override func isContentValid () - Bool { // Do validation of contentText and/or NSExtensionContext // attachments here return true } override func didSelectPost () { // This is called after the user selects Post. Do the // upload of contentText and/or NSExtensionContext // attachments. // Inform the host that we re done, so it un-blocks its UI. // Note: Alternatively you could call super s -didSelectPost, // which will similarly complete the extension context. self . extensionContext !. completeRequest ( returningItems : [], completionHandler : nil ) } override func configurationItems () - [ Any ] ! { // To add configuration options via table cells at the // bottom of the sheet, return an array of // SLComposeSheetConfigurationItem here. return [] } } Extension Context La aplicaci\u00f3n que invoca a la extensi\u00f3n crea un objeto de tipo NSExtensionContext que se guarda en la variable extensionContext del SLComposeServiceViewController . Este objeto contiene la informaci\u00f3n del \u00edtem o \u00edtems que el usuario a seleccionado para compartir en su propiedad inputItems : var inputItems : [Any] Creaci\u00f3n de extensiones dentro de apps Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n. Se construyen de forma independiente Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador. Demo: Extensi\u00f3n Compartir Vamos a crear una extensi\u00f3n Compartir desde cero. Creamos un proyecto nuevo llamado PruebaExtension y a\u00f1adimos un nuevo target . Elegimos el tipo de extensi\u00f3n Share Extension : Escribimos como nombre del producto Compartir y aceptamos activar el esquema Compartir . Comprobamos los dos productos existentes, el c\u00f3digo de cada uno de ellos, y los esquemas. A\u00f1adimos en el storyboard de la app principal una etiqueta que deber\u00e1 aparecer cuando la app est\u00e9 lanzada en el simulador. A\u00f1adimos c\u00f3digo en el view controller creado por defecto para la extensi\u00f3n en el que imprimimos algunos mensajes en la salida est\u00e1ndar. Podemos instalar y depurar la extensi\u00f3n seleccionando el esquema y ejecut\u00e1ndolo. Aparece un panel en el que tenemos que seleccionar la app compa\u00f1era de la extensi\u00f3n (cualquier extensi\u00f3n debe instalarse junto con una app principal). Podemos escoger cualquier app de las ya instaladas. Lo m\u00e1s normal es que instalemos primero la app principal y despu\u00e9s ejecutemos la extensi\u00f3n usando esta app. Cuando se lance la app principal, ya se habr\u00e1 cargado la extensi\u00f3n. Abrimos Safari, por ejemplo, y escogemos la opci\u00f3n compartir . Comprobamos si la extensi\u00f3n est\u00e1 habilitada. Pulsamos la extensi\u00f3n Compartir y vemos c\u00f3mo se activa su view controller y como aparecen en la consola los mensajes que hemos a\u00f1adido en el c\u00f3digo. Tipos de extensiones Puntos de extensi\u00f3n Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple . Algunos de los tipos de extensiones que proporciona el sistema: Actions : Permite manipular contenido de la app original Audio Unit : Permite generar o modificar un stream de audio Custom Keyboard : Permite reemplazar el teclado del sistema con un teclado customizado Document Provider : Permite acceder y gestionar un repositorio de ficheros Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Permite editar una foto o un v\u00eddeo en la app Fotos Share : Permite enviar a un sitio web o compartir contenido con otros Today : Permite a\u00f1adir widgets en el panel de Hoy WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch. Xcode permite a\u00f1adir un target que implementa cualquiera de las extensiones anteriores, creando el c\u00f3digo y la configuraci\u00f3n inicial de la misma. Un ejemplo del aspecto de las extensiones Custom Keyboard y Photo Editing : Propiedades de la extensi\u00f3n Todos los aspectos relacionados con la configuraci\u00f3n de la extensi\u00f3n, incluido su tipo, se definen en propiedades en el fichero Info.plist . Por ejemplo, la extensi\u00f3n Share a\u00f1adida en la demostraci\u00f3n se crea con las siguientes propiedades: 1 2 3 4 5 6 7 8 9 10 11 12 key NSExtension /key dict key NSExtensionAttributes /key dict key NSExtensionActivationRule /key string TRUEPREDICATE /string /dict key NSExtensionMainStoryboard /key string MainInterface /string key NSExtensionPointIdentifier /key string com.apple.share-services /string /dict La propiedad NSExtensionPointIdentifier es la que define el tipo de extensi\u00f3n y el punto de extensi\u00f3n. Como vemos, en el caso de una extensi\u00f3n de tipo Share es com.apple.share-services . Panel Today Veamos algunas caracter\u00edsticas de otro tipo de extensi\u00f3n, la Today Extension . En iOS los usuarios pueden visualizar un panel especial, denominado Today , en el que es posible instalar extensiones. Se accede a este panel con un gesto de deslizar hacia la derecha, incluso con el dispositivo bloqueado. Las extensiones tienen una peque\u00f1a vista que se muestran apiladas una sobre otra. Tambi\u00e9n se puede acceder a una segunda vista ampliada al pulsar Mostrar m\u00e1s . El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas. Notification Service Extension Veamos un \u00faltimo ejemplo de extensi\u00f3n, la Notification Service Extension . La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. En este caso Xcode no genera ninguna vista ni controller, s\u00f3lo una clase NotificationService que extiende UNNotificationServiceExtension y que debemos modificar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import UserNotifications class NotificationService : UNNotificationServiceExtension { var contentHandler : (( UNNotificationContent ) - Void )? var bestAttemptContent : UNMutableNotificationContent ? override func didReceive ( _ request : UNNotificationRequest , withContentHandler contentHandler : @ escaping ( UNNotificationContent ) - Void ) { self . contentHandler = contentHandler bestAttemptContent = ( request . content . mutableCopy () as ? UNMutableNotificationContent ) if let bestAttemptContent = bestAttemptContent { // Modify the notification content here... bestAttemptContent . title = \\( bestAttemptContent . title ) [modified] contentHandler ( bestAttemptContent ) } } override func serviceExtensionTimeWillExpire () { // Called just before the extension will be terminated by // the system. // Use this as an opportunity to deliver your best attempt // at modified content, otherwise the original push payload // will be used. if let contentHandler = contentHandler , let bestAttemptContent = bestAttemptContent { contentHandler ( bestAttemptContent ) } } } Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario. Funcionamiento de una extensi\u00f3n Ciclo de vida de una extension Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. Si la extensi\u00f3n tiene un ViewController , el sistema llama al m\u00e9todo viewDidLoad() para inicializar la vista y permitir que el usuario interaccione con ella. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social. Comunicaci\u00f3n de la app extension Una app extension se comunica principalmente con su app anfitriona (la app desde la que se lanza la extensi\u00f3n). No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Como ya hemos visto, un objeto del tipo NSExtensionContext . Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora. Comunicaci\u00f3n entre la app y la extensi\u00f3n La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Veamos posibles formas de hacerlo. La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando: frameworks embebidos compartidos grupos de apps a trav\u00e9s de una persistencia com\u00fan, usando CoreData o sqlite Framework embebido para compartir c\u00f3digo Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files . Grupos de apps Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Tambi\u00e9n lo puede crear autom\u00e1ticamente Xcode en la opci\u00f3n App Groups en las capabilities . Todas las apps y extensiones deben usar ese mismo identificador de grupo en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode). Configuraci\u00f3n del grupo de apps Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList App IDs y perfiles de aprovisionamiento A\u00f1adimos el identificador de grupo en los App IDs y actualizamos el perfil de aprovisionamiento. App IDs: ToDoList CloudKit ToDoList Today Extension Perfiles de aprovisionamiento: ToDoListCloudKit Profile ToDoList Today Extension Capabilities Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido. Compartir datos con UserDefaults La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. 1 2 3 4 5 6 7 8 9 10 11 let compartido = UserDefaults ( suiteName : group.app.group.id ) // set valores compartido ?. set ( 1 , forKey : contador ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : contador ) Compartir datos con FileManager La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. 1 2 3 4 5 6 let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : group.com.company.project ) { ... } Demo: CustomNotes Veamos un ejemplo completo de extensi\u00f3n de tipo Share Extension , la app CustomNotes , adaptada de una versi\u00f3n original hecha con Swift 3 y disponible en github . La aplicaci\u00f3n original se describe en este art\u00edculo de Medium . Se ha modificado la app original, simplific\u00e1ndola y adapt\u00e1ndola a Swift 5. La puedes descargar desde este enlace . Algunas caracter\u00edsticas interesantes: Utiliza Core Data para guardar las notas. Define un grupo de app compartido entre la extensi\u00f3n y la app en el que se guardan los datos. Permite seleccionar la nota en la que se guarda el texto a compartir. Examinamos c\u00f3mo funcionan la app y la extensi\u00f3n. Pr\u00e1ctica: ToDoList Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y nombre del \u00faltimo de ellos. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA. Referencias P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide Tutorial Raywenderlich sobre extensiones Today (Crypticker)","title":"Sesi\u00f3n 5 - Extensiones"},{"location":"sesion05/sesion05-extensiones.html#sesion-5-extensiones","text":"","title":"Sesi\u00f3n 5: Extensiones"},{"location":"sesion05/sesion05-extensiones.html#extensiones","text":"","title":"Extensiones"},{"location":"sesion05/sesion05-extensiones.html#introduccion","text":"Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo).","title":"Introducci\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#targets","text":"Las extensiones se incluyen en el proyecto como targets adicionales que acompa\u00f1an a la app principal. Un target especifica un producto a construir por Xcode. Por ejemplo, si cuando creamos un proyecto escogemos a\u00f1adir tests unitarios y de UI, Xcode introduce autom\u00e1ticamente estos targets, adem\u00e1s de la app principal. Para a\u00f1adir manualmente un nuevo target al proyecto podemos seleccionar el bot\u00f3n + en la parte de abajo o la opci\u00f3n Editor Add Target... . Podemos seleccionar el target y especificar sus caracter\u00edsticas en el panel principal. Hay que especificar los mismos elementos que para una app principal (de hecho los targets son como mini apps): Bundle Id, versi\u00f3n, build Certificado y perfil de aprovisionamiento Permisos ( capabilities ) Configuraci\u00f3n y reglas del build","title":"Targets"},{"location":"sesion05/sesion05-extensiones.html#esquema","text":"Cada target tiene una configuraci\u00f3n autom\u00e1tica de construcci\u00f3n definida por su esquema ( schema ). Un esquema es una colecci\u00f3n de configuraciones que especifican las acciones a realizar para la compilaci\u00f3n del target y el entorno ejecutable a usar para lanzar el producto. Cuando abrimos o creamos un proyecto, Xcode crea autom\u00e1ticamente un esquema para cada target . El men\u00fa de esquemas se puede usar para cambiar el esquema activo y el destino. Podemos usar tambi\u00e9n el men\u00fa de esquemas para crear, editar y gestionar esquemas y para a\u00f1adir y descartar simuladores. Los esquemas y los destinos son distintos. Los destinos especifican d\u00f3nde instalar la app (dispositivos f\u00edsicos y simuladores). Los esquemas especifican los ajustes para compilar, ejecutar, testear, monitorizar, analizar y archivar el proyecto. Estos ajustes se pueden configurar en la opci\u00f3n de editar esquema.","title":"Esquema"},{"location":"sesion05/sesion05-extensiones.html#ejemplo-de-extension-compartir","text":"Veamos un ejemplo concreto, la extensi\u00f3n Compartir ( Share Extension ). Muchas aplicaciones proporcionan el punto de extensi\u00f3n Compartir, en el que se pueden instalar extensiones de tipo Share Extension . Por ejemplo, en la siguiente imagen vemos como se puede acceder a la opci\u00f3n de compartir en una p\u00e1gina del navegador Safari y c\u00f3mo el usuario puede acceder a las extensiones que se han a\u00f1adido. La extensi\u00f3n Compartir hereda un ViewController por defecto de tipo SLComposeServiceViewController que contiene entre otros: Un campo de texto que puede editar el usuario, Una previsualizaci\u00f3n del objeto a compartir Los botones Cancel y Post La extensi\u00f3n puede configurar algunos aspectos de este ViewController . Por ejemplo, puede a\u00f1adir una opci\u00f3n en la parte inferior en la que el usuario pueda seleccionar d\u00f3nde compartir. Por ejemplo, esto se hace en la extensi\u00f3n adaptada por la app Recordatorios , en la que se da la opci\u00f3n de seleccionar el recordatorio en el que se quiere a\u00f1adir la p\u00e1gina.","title":"Ejemplo de extensi\u00f3n: Compartir"},{"location":"sesion05/sesion05-extensiones.html#slcomposeserviceviewcontroller","text":"Cuando creamos una extensi\u00f3n (m\u00e1s adelante haremos una demostraci\u00f3n) Xcode crea una plantilla inicial de c\u00f3digo. En el caso de una extensi\u00f3n Compartir la plantilla define un view controller hijo de SLComposeServiceViewController en el que podemos configurar el funcionamiento de la extensi\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import UIKit import Social class ShareViewController : SLComposeServiceViewController { override func isContentValid () - Bool { // Do validation of contentText and/or NSExtensionContext // attachments here return true } override func didSelectPost () { // This is called after the user selects Post. Do the // upload of contentText and/or NSExtensionContext // attachments. // Inform the host that we re done, so it un-blocks its UI. // Note: Alternatively you could call super s -didSelectPost, // which will similarly complete the extension context. self . extensionContext !. completeRequest ( returningItems : [], completionHandler : nil ) } override func configurationItems () - [ Any ] ! { // To add configuration options via table cells at the // bottom of the sheet, return an array of // SLComposeSheetConfigurationItem here. return [] } }","title":"SLComposeServiceViewController"},{"location":"sesion05/sesion05-extensiones.html#extension-context","text":"La aplicaci\u00f3n que invoca a la extensi\u00f3n crea un objeto de tipo NSExtensionContext que se guarda en la variable extensionContext del SLComposeServiceViewController . Este objeto contiene la informaci\u00f3n del \u00edtem o \u00edtems que el usuario a seleccionado para compartir en su propiedad inputItems : var inputItems : [Any]","title":"Extension Context"},{"location":"sesion05/sesion05-extensiones.html#creacion-de-extensiones-dentro-de-apps","text":"Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n.","title":"Creaci\u00f3n de extensiones dentro de apps"},{"location":"sesion05/sesion05-extensiones.html#se-construyen-de-forma-independiente","text":"Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador.","title":"Se construyen de forma independiente"},{"location":"sesion05/sesion05-extensiones.html#demo-extension-compartir","text":"Vamos a crear una extensi\u00f3n Compartir desde cero. Creamos un proyecto nuevo llamado PruebaExtension y a\u00f1adimos un nuevo target . Elegimos el tipo de extensi\u00f3n Share Extension : Escribimos como nombre del producto Compartir y aceptamos activar el esquema Compartir . Comprobamos los dos productos existentes, el c\u00f3digo de cada uno de ellos, y los esquemas. A\u00f1adimos en el storyboard de la app principal una etiqueta que deber\u00e1 aparecer cuando la app est\u00e9 lanzada en el simulador. A\u00f1adimos c\u00f3digo en el view controller creado por defecto para la extensi\u00f3n en el que imprimimos algunos mensajes en la salida est\u00e1ndar. Podemos instalar y depurar la extensi\u00f3n seleccionando el esquema y ejecut\u00e1ndolo. Aparece un panel en el que tenemos que seleccionar la app compa\u00f1era de la extensi\u00f3n (cualquier extensi\u00f3n debe instalarse junto con una app principal). Podemos escoger cualquier app de las ya instaladas. Lo m\u00e1s normal es que instalemos primero la app principal y despu\u00e9s ejecutemos la extensi\u00f3n usando esta app. Cuando se lance la app principal, ya se habr\u00e1 cargado la extensi\u00f3n. Abrimos Safari, por ejemplo, y escogemos la opci\u00f3n compartir . Comprobamos si la extensi\u00f3n est\u00e1 habilitada. Pulsamos la extensi\u00f3n Compartir y vemos c\u00f3mo se activa su view controller y como aparecen en la consola los mensajes que hemos a\u00f1adido en el c\u00f3digo.","title":"Demo: Extensi\u00f3n Compartir"},{"location":"sesion05/sesion05-extensiones.html#tipos-de-extensiones","text":"","title":"Tipos de extensiones"},{"location":"sesion05/sesion05-extensiones.html#puntos-de-extension","text":"Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple . Algunos de los tipos de extensiones que proporciona el sistema: Actions : Permite manipular contenido de la app original Audio Unit : Permite generar o modificar un stream de audio Custom Keyboard : Permite reemplazar el teclado del sistema con un teclado customizado Document Provider : Permite acceder y gestionar un repositorio de ficheros Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Permite editar una foto o un v\u00eddeo en la app Fotos Share : Permite enviar a un sitio web o compartir contenido con otros Today : Permite a\u00f1adir widgets en el panel de Hoy WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch. Xcode permite a\u00f1adir un target que implementa cualquiera de las extensiones anteriores, creando el c\u00f3digo y la configuraci\u00f3n inicial de la misma. Un ejemplo del aspecto de las extensiones Custom Keyboard y Photo Editing :","title":"Puntos de extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#propiedades-de-la-extension","text":"Todos los aspectos relacionados con la configuraci\u00f3n de la extensi\u00f3n, incluido su tipo, se definen en propiedades en el fichero Info.plist . Por ejemplo, la extensi\u00f3n Share a\u00f1adida en la demostraci\u00f3n se crea con las siguientes propiedades: 1 2 3 4 5 6 7 8 9 10 11 12 key NSExtension /key dict key NSExtensionAttributes /key dict key NSExtensionActivationRule /key string TRUEPREDICATE /string /dict key NSExtensionMainStoryboard /key string MainInterface /string key NSExtensionPointIdentifier /key string com.apple.share-services /string /dict La propiedad NSExtensionPointIdentifier es la que define el tipo de extensi\u00f3n y el punto de extensi\u00f3n. Como vemos, en el caso de una extensi\u00f3n de tipo Share es com.apple.share-services .","title":"Propiedades de la extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#panel-today","text":"Veamos algunas caracter\u00edsticas de otro tipo de extensi\u00f3n, la Today Extension . En iOS los usuarios pueden visualizar un panel especial, denominado Today , en el que es posible instalar extensiones. Se accede a este panel con un gesto de deslizar hacia la derecha, incluso con el dispositivo bloqueado. Las extensiones tienen una peque\u00f1a vista que se muestran apiladas una sobre otra. Tambi\u00e9n se puede acceder a una segunda vista ampliada al pulsar Mostrar m\u00e1s . El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas.","title":"Panel Today"},{"location":"sesion05/sesion05-extensiones.html#notification-service-extension","text":"Veamos un \u00faltimo ejemplo de extensi\u00f3n, la Notification Service Extension . La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. En este caso Xcode no genera ninguna vista ni controller, s\u00f3lo una clase NotificationService que extiende UNNotificationServiceExtension y que debemos modificar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import UserNotifications class NotificationService : UNNotificationServiceExtension { var contentHandler : (( UNNotificationContent ) - Void )? var bestAttemptContent : UNMutableNotificationContent ? override func didReceive ( _ request : UNNotificationRequest , withContentHandler contentHandler : @ escaping ( UNNotificationContent ) - Void ) { self . contentHandler = contentHandler bestAttemptContent = ( request . content . mutableCopy () as ? UNMutableNotificationContent ) if let bestAttemptContent = bestAttemptContent { // Modify the notification content here... bestAttemptContent . title = \\( bestAttemptContent . title ) [modified] contentHandler ( bestAttemptContent ) } } override func serviceExtensionTimeWillExpire () { // Called just before the extension will be terminated by // the system. // Use this as an opportunity to deliver your best attempt // at modified content, otherwise the original push payload // will be used. if let contentHandler = contentHandler , let bestAttemptContent = bestAttemptContent { contentHandler ( bestAttemptContent ) } } } Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario.","title":"Notification Service Extension"},{"location":"sesion05/sesion05-extensiones.html#funcionamiento-de-una-extension","text":"","title":"Funcionamiento de una extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#ciclo-de-vida-de-una-extension","text":"Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. Si la extensi\u00f3n tiene un ViewController , el sistema llama al m\u00e9todo viewDidLoad() para inicializar la vista y permitir que el usuario interaccione con ella. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social.","title":"Ciclo de vida de una extension"},{"location":"sesion05/sesion05-extensiones.html#comunicacion-de-la-app-extension","text":"Una app extension se comunica principalmente con su app anfitriona (la app desde la que se lanza la extensi\u00f3n). No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Como ya hemos visto, un objeto del tipo NSExtensionContext . Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora.","title":"Comunicaci\u00f3n de la app extension"},{"location":"sesion05/sesion05-extensiones.html#comunicacion-entre-la-app-y-la-extension","text":"La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Veamos posibles formas de hacerlo. La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando: frameworks embebidos compartidos grupos de apps a trav\u00e9s de una persistencia com\u00fan, usando CoreData o sqlite","title":"Comunicaci\u00f3n entre la app y la extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#framework-embebido-para-compartir-codigo","text":"Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files .","title":"Framework embebido para compartir c\u00f3digo"},{"location":"sesion05/sesion05-extensiones.html#grupos-de-apps","text":"Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Tambi\u00e9n lo puede crear autom\u00e1ticamente Xcode en la opci\u00f3n App Groups en las capabilities . Todas las apps y extensiones deben usar ese mismo identificador de grupo en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode).","title":"Grupos de apps"},{"location":"sesion05/sesion05-extensiones.html#configuracion-del-grupo-de-apps","text":"Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList","title":"Configuraci\u00f3n del grupo de apps"},{"location":"sesion05/sesion05-extensiones.html#app-ids-y-perfiles-de-aprovisionamiento","text":"A\u00f1adimos el identificador de grupo en los App IDs y actualizamos el perfil de aprovisionamiento. App IDs: ToDoList CloudKit ToDoList Today Extension Perfiles de aprovisionamiento: ToDoListCloudKit Profile ToDoList Today Extension","title":"App IDs y perfiles de aprovisionamiento"},{"location":"sesion05/sesion05-extensiones.html#capabilities","text":"Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido.","title":"Capabilities"},{"location":"sesion05/sesion05-extensiones.html#compartir-datos-con-userdefaults","text":"La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. 1 2 3 4 5 6 7 8 9 10 11 let compartido = UserDefaults ( suiteName : group.app.group.id ) // set valores compartido ?. set ( 1 , forKey : contador ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : contador )","title":"Compartir datos con UserDefaults"},{"location":"sesion05/sesion05-extensiones.html#compartir-datos-con-filemanager","text":"La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. 1 2 3 4 5 6 let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : group.com.company.project ) { ... }","title":"Compartir datos con FileManager"},{"location":"sesion05/sesion05-extensiones.html#demo-customnotes","text":"Veamos un ejemplo completo de extensi\u00f3n de tipo Share Extension , la app CustomNotes , adaptada de una versi\u00f3n original hecha con Swift 3 y disponible en github . La aplicaci\u00f3n original se describe en este art\u00edculo de Medium . Se ha modificado la app original, simplific\u00e1ndola y adapt\u00e1ndola a Swift 5. La puedes descargar desde este enlace . Algunas caracter\u00edsticas interesantes: Utiliza Core Data para guardar las notas. Define un grupo de app compartido entre la extensi\u00f3n y la app en el que se guardan los datos. Permite seleccionar la nota en la que se guarda el texto a compartir. Examinamos c\u00f3mo funcionan la app y la extensi\u00f3n.","title":"Demo: CustomNotes"},{"location":"sesion05/sesion05-extensiones.html#practica-todolist","text":"Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y nombre del \u00faltimo de ellos. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA.","title":"Pr\u00e1ctica: ToDoList"},{"location":"sesion05/sesion05-extensiones.html#referencias","text":"P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide Tutorial Raywenderlich sobre extensiones Today (Crypticker)","title":"Referencias"},{"location":"sesion06/sesion06-compras-inapp.html","text":"Sesi\u00f3n 6: Compras In-App Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 \u00bfQu\u00e9 es una compra In-App? Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra. Ejemplos de uso Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium Podemos permitir la subscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line Tipos de compras In-App - Compras No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz. Tipos de compras In-App - Subscripciones Subscripciones auto-renovables Como los no-consumibles, las subscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Subscripciones no-renovables Subscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la subscripci\u00f3n se realizan desde la app (y el servidor). Requisitos para activar las In-App Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador. Contratos \u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla. Servicios a activar en la app Bundle identifier y App Id Configuraci\u00f3n In-App desde iTunes Connect Datos del app Pantalla para a\u00f1adir nuevos In-Apps Seleccionar el tipo de In-App Caracter\u00edsticas del In-App Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple Caracter\u00edsticas del In-App Caracter\u00edsticas del In-App (2) Usuarios de prueba Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba. Aplicaci\u00f3n ejemplo Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en las plantillas en este enlace Aplicaci\u00f3n ejemplo (2) El proceso de compra en un vistazo Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver . Clase auxiliar InApp (1) Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : 1 2 3 protocol InAppDelegate { func compraRecibida () } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . defaultQueue (). addTransactionObserver ( self ) // Cargamos la lista de productos productIdentiferList . append ( ejemplo3 ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () } Clase auxiliar InApp (2) 1 2 3 4 5 6 7 8 9 // M\u00e9todo del delegado al que se llama cuando se han recibido los productos func productsRequest ( request : SKProductsRequest , didReceiveResponse response : SKProductsResponse ) { print ( Hemos recibido \\( response . products . count ) productos ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( Producto invalido id: \\( invalidProductId ) ) } } Clase auxiliar InApp (3) 1 2 3 4 5 6 7 8 9 10 11 12 13 // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count 0 SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . defaultQueue (). addPayment ( pago ) print ( Comprando... ) } else { print ( No existen productos ) } } Clase auxiliar InApp (4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // M\u00e9todo del delegado al que se llama cuando el usuario compra el InApp func paymentQueue ( queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . Purchased : print ( Purchased ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Failed : print ( Failed ) print ( Error de transacci\u00f3n: \\( transaction . error ?. localizedDescription ) ) SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Restored : print ( Restored ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) default : print ( Otro ) } } } Clase ViewController (1) En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () // Instancia de la clase auxiliar InApp override func viewDidLoad () { // Nos hacemos delegados de InApp inApp . delegate = self // Escondemos el bot\u00f3n que da acceso a la pantalla sorpresa botonSorpresa . hidden = true // Comprobamos si el usuario ha comprado antes el inApp // Funciona si el usuario est\u00e1 identificado if NSUserDefaults . standardUserDefaults (). boolForKey ( inAppComprado ) { botonSorpresa . hidden = false } else { botonSorpresa . hidden = true } super . viewDidLoad () } Clase ViewController (2) La acci\u00f3n asociada al bot\u00f3n de compra llama al m\u00e9todo lanzarPago de la instancia de nuestra clase InApp : 1 2 3 4 5 // Acci\u00f3n asociada al bot\u00f3n de compra @IBAction func hazCompra ( sender : UIButton ) { print ( Click bot\u00f3n de compra ) inApp . lanzarPago () } Clase ViewController (3) En el m\u00e9todo compraRecibida() (del protocolo) activamos un bot\u00f3n que da acceso a la pantalla sorpresa. 1 2 3 4 // Implementaci\u00f3n del m\u00e9todo del protocolo InAppDelegate func compraRecibida () { botonSorpresa . hidden = false } Acci\u00f3n para mostrar la pantalla sorpresa: 1 2 3 4 @IBAction func sorpresa ( sender : UIButton ){ performSegueWithIdentifier ( Sorpresa , sender : view ) } } Demo Referencias Recursos sobre compras In-App In-App Purchase Configuration Guide for iTunes Connect In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Getting Started with In-App purchase Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Sesi\u00f3n 6: <br/> Compras In-App"},{"location":"sesion06/sesion06-compras-inapp.html#sesion-6-compras-in-app","text":"","title":"Sesi\u00f3n 6:  Compras In-App"},{"location":"sesion06/sesion06-compras-inapp.html#servicios-de-las-plataformas-moviles-ios","text":"Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18","title":"Servicios de las plataformas m\u00f3viles - iOS"},{"location":"sesion06/sesion06-compras-inapp.html#que-es-una-compra-in-app","text":"Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra.","title":"\u00bfQu\u00e9 es una compra In-App?"},{"location":"sesion06/sesion06-compras-inapp.html#ejemplos-de-uso","text":"Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium Podemos permitir la subscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line","title":"Ejemplos de uso"},{"location":"sesion06/sesion06-compras-inapp.html#tipos-de-compras-in-app-compras","text":"No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz.","title":"Tipos de compras In-App - Compras"},{"location":"sesion06/sesion06-compras-inapp.html#tipos-de-compras-in-app-subscripciones","text":"Subscripciones auto-renovables Como los no-consumibles, las subscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Subscripciones no-renovables Subscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la subscripci\u00f3n se realizan desde la app (y el servidor).","title":"Tipos de compras In-App - Subscripciones"},{"location":"sesion06/sesion06-compras-inapp.html#requisitos-para-activar-las-in-app","text":"Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador.","title":"Requisitos para activar las In-App"},{"location":"sesion06/sesion06-compras-inapp.html#contratos","text":"\u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla.","title":"Contratos"},{"location":"sesion06/sesion06-compras-inapp.html#servicios-a-activar-en-la-app","text":"","title":"Servicios a activar en la app"},{"location":"sesion06/sesion06-compras-inapp.html#bundle-identifier-y-app-id","text":"","title":"Bundle identifier y App Id"},{"location":"sesion06/sesion06-compras-inapp.html#configuracion-in-app-desde-itunes-connect","text":"","title":"Configuraci\u00f3n In-App desde iTunes Connect"},{"location":"sesion06/sesion06-compras-inapp.html#datos-del-app","text":"","title":"Datos del app"},{"location":"sesion06/sesion06-compras-inapp.html#pantalla-para-anadir-nuevos-in-apps","text":"","title":"Pantalla para a\u00f1adir nuevos In-Apps"},{"location":"sesion06/sesion06-compras-inapp.html#seleccionar-el-tipo-de-in-app","text":"","title":"Seleccionar el tipo de In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app","text":"Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple","title":"Caracter\u00edsticas del In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app_1","text":"","title":"Caracter\u00edsticas del In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app-2","text":"","title":"Caracter\u00edsticas del In-App (2)"},{"location":"sesion06/sesion06-compras-inapp.html#usuarios-de-prueba","text":"Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba.","title":"Usuarios de prueba"},{"location":"sesion06/sesion06-compras-inapp.html#aplicacion-ejemplo","text":"Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en las plantillas en este enlace","title":"Aplicaci\u00f3n ejemplo"},{"location":"sesion06/sesion06-compras-inapp.html#aplicacion-ejemplo-2","text":"","title":"Aplicaci\u00f3n ejemplo (2)"},{"location":"sesion06/sesion06-compras-inapp.html#el-proceso-de-compra-en-un-vistazo","text":"Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver .","title":"El proceso de compra en un vistazo"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-1","text":"Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : 1 2 3 protocol InAppDelegate { func compraRecibida () } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . defaultQueue (). addTransactionObserver ( self ) // Cargamos la lista de productos productIdentiferList . append ( ejemplo3 ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () }","title":"Clase auxiliar InApp (1)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-2","text":"1 2 3 4 5 6 7 8 9 // M\u00e9todo del delegado al que se llama cuando se han recibido los productos func productsRequest ( request : SKProductsRequest , didReceiveResponse response : SKProductsResponse ) { print ( Hemos recibido \\( response . products . count ) productos ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( Producto invalido id: \\( invalidProductId ) ) } }","title":"Clase auxiliar InApp (2)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count 0 SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . defaultQueue (). addPayment ( pago ) print ( Comprando... ) } else { print ( No existen productos ) } }","title":"Clase auxiliar InApp (3)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // M\u00e9todo del delegado al que se llama cuando el usuario compra el InApp func paymentQueue ( queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . Purchased : print ( Purchased ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Failed : print ( Failed ) print ( Error de transacci\u00f3n: \\( transaction . error ?. localizedDescription ) ) SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Restored : print ( Restored ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) default : print ( Otro ) } } }","title":"Clase auxiliar InApp (4)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-1","text":"En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () // Instancia de la clase auxiliar InApp override func viewDidLoad () { // Nos hacemos delegados de InApp inApp . delegate = self // Escondemos el bot\u00f3n que da acceso a la pantalla sorpresa botonSorpresa . hidden = true // Comprobamos si el usuario ha comprado antes el inApp // Funciona si el usuario est\u00e1 identificado if NSUserDefaults . standardUserDefaults (). boolForKey ( inAppComprado ) { botonSorpresa . hidden = false } else { botonSorpresa . hidden = true } super . viewDidLoad () }","title":"Clase ViewController (1)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-2","text":"La acci\u00f3n asociada al bot\u00f3n de compra llama al m\u00e9todo lanzarPago de la instancia de nuestra clase InApp : 1 2 3 4 5 // Acci\u00f3n asociada al bot\u00f3n de compra @IBAction func hazCompra ( sender : UIButton ) { print ( Click bot\u00f3n de compra ) inApp . lanzarPago () }","title":"Clase ViewController (2)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-3","text":"En el m\u00e9todo compraRecibida() (del protocolo) activamos un bot\u00f3n que da acceso a la pantalla sorpresa. 1 2 3 4 // Implementaci\u00f3n del m\u00e9todo del protocolo InAppDelegate func compraRecibida () { botonSorpresa . hidden = false } Acci\u00f3n para mostrar la pantalla sorpresa: 1 2 3 4 @IBAction func sorpresa ( sender : UIButton ){ performSegueWithIdentifier ( Sorpresa , sender : view ) } }","title":"Clase ViewController (3)"},{"location":"sesion06/sesion06-compras-inapp.html#demo","text":"","title":"Demo"},{"location":"sesion06/sesion06-compras-inapp.html#referencias","text":"Recursos sobre compras In-App In-App Purchase Configuration Guide for iTunes Connect In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Getting Started with In-App purchase Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices","title":"Referencias"},{"location":"sesion06/sesion06-compras-inapp.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"}]}