{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de la asignatura \"Servicios de las Plataformas M\u00f3viles (iOS)\" del Master en Desarrollo de Software para Dispositivos M\u00f3viles. Despliega el men\u00fa de la izquierda para consultar los apuntes.","title":"Home"},{"location":"sesion00/sesion00-introduccion.html","text":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 Planificaci\u00f3n Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App Entregas de pr\u00e1cticas Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: final de la asignatura (27 mayo) Recomendable realizar los ejercicios semana a semana Recursos En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Introducci\u00f3n"},{"location":"sesion00/sesion00-introduccion.html#sesion-0-planificacion-bloque-ios","text":"","title":"Sesi\u00f3n 0:  Planificaci\u00f3n  bloque iOS"},{"location":"sesion00/sesion00-introduccion.html#planificacion","text":"Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App","title":"Planificaci\u00f3n"},{"location":"sesion00/sesion00-introduccion.html#entregas-de-practicas","text":"Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: final de la asignatura (27 mayo) Recomendable realizar los ejercicios semana a semana","title":"Entregas de pr\u00e1cticas"},{"location":"sesion00/sesion00-introduccion.html#recursos","text":"En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App","title":"Recursos"},{"location":"sesion00/sesion00-introduccion.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html","text":"Sesi\u00f3n 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Introducci\u00f3n En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps de iOS usando Test Flight y App Store Connect. Seguridad en las apps La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable. Cuenta de desarrollador de Apple Distintos programas de desarrollo Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el member center de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ : Cuenta de desarrollador Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder a la cuenta de desarrollador , en la que podremos gestionar numerosos elementos que veremos durante el curso. Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store. Equipo de desarrollo En todos los programas de pago de desarrollador de Apple, incluso en los programas individuales, es posible trabajar con un equipo de desarrolladores. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership de la cuenta de desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight. Demo Veremos una demostraci\u00f3n en la que accederemos a la cuenta de desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es) Certificados C\u00f3digo firmado Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma. Identidad de firma Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en la cuenta de desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador. Tipos de certificados Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el member center , Xcode o Acceso a llaveros . Gesti\u00f3n de los certificados en Xcode Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra las dos identidades y nos permite utilizar la que nos interese en cada momento. Creaci\u00f3n e instalaci\u00f3n de certificados Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se descarga de los servidores de Apple e instala autom\u00e1ticamente el certificados de firma. Ejecuci\u00f3n de apps en dispositivos reales Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) correcto que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store. Demo Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode. Instalaci\u00f3n de la identidad de firma Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito. Firma de una app Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app. App ejemplo ToDoList Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Podemos descargar la app de esta direcci\u00f3n y probar a ejecutarla en el simulador. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador. Comprobaci\u00f3n del certificado En la pantalla de Xcode Preferences... Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode . Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros En la aplicaci\u00f3n Acceso a Llaveros y podemos comprobar que se ha instalado el certificado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n . Conexi\u00f3n de un dispositivo real a Xcode Conectamos un dispositivo iOS real al ordenador. En Xcode seleccionamos Window Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo. Prueba en un dispositivo real Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica. Autorizaci\u00f3n al desarrollador en el dispositivo Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app. Archivo y distribuci\u00f3n de la app Seleccionando la opci\u00f3n de Xcode Product Archive se accede al panel de archivo y distribuci\u00f3n de la app La opci\u00f3n de exportar la app est\u00e1 deshabilitado por que estamos registrados con el programa gratuito. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Despliegue de apps en dispositivos de prueba Capacidades de las apps Para poder utilizar servicios avanzados proporcionados por Apple en las apps (como notificaciones push, iCloud o Game Center) es necesario darse de alta de forma individual en el programa de desarrollo de iOS o formar parte de un equipo de desarrollo. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer Support Advanced App Capabilities . Con el programa de desarrollo de la Universidad podemos acceder a m\u00e1s servicios que a los gratuitos, pero no a todos los servicios disponibles. La lista de servicios accesibles son los siguientes: Permisos para las apps Un permiso ( entitlement ) es un elemento de configuraci\u00f3n incluido en la firma digital de la app que le indica al sistema que permita a la app acceder a ciertos recursos o realizar ciertas operaciones. La forma de otorgar los permisos a una app es algo elaborada, para permitir una configuraci\u00f3n flexible y no atar los permisos a una \u00fanica app. El responsable de la cuenta de desarrollador debe crear un identificador denominado App ID y otorgar los permisos a ese identificador. Bundle Identifier Un bundle ID identifica de forma \u00fanica una app. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). La cadena deber\u00eda estar en un formato DNS-inverso y usar un dominio propio de la organizaci\u00f3n. De esta forma se garantiza su unicidad. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hello . Uso del Bundle ID Se utiliza durante el desarrollo para aprovisionar dispositivos y por el sistema operativo cuando la app se distribuye a los clientes. Por ejemplo, los servicios de Game Center o de compras In-App usan el bundle ID para identificar la app cuando utilizan estos servicios. App ID El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el member center . Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con permiso de acceso a iCloud y todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que permite que una o m\u00e1s apps desarrolladas por el equipo accedan a los permisos otorgados. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del APP ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha. Gesti\u00f3n de las capacidades en Xcode En Xcode se deben indicar las capacidades que necesita la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Capabilities . Dependiendo del programa de desarrollo en el que estemos tendremos m\u00e1s o menos capacidades disponibles. Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el member center alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores. Aprovisionamiento de apps Es necesario configurar un perfil de aprovisionamiento para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push) y para configurar dispositivos de prueba en los que podamos ejecutar la app. Con la cuenta de desarrollador gratuita es posible desarrollar aplicaciones, acceder a un n\u00famero limitado de servicios de Apple y probarlas configurando el dispositivo propio como un dispositivo de desarrollo. Pero es una forma muy limitada de prueba porque es necesario conectar f\u00edsicamente el dispositivo al ordenador en el que est\u00e1 Xcode. Es posible ejecutar apps en dispositivos de prueba sin tener que configurarlos como dispositivos de desarrollo usando perfiles de aprovisionamiento . Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad. Distribuci\u00f3n de apps La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran. Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Como ya hemos dicho, Apple permite ejecutar apps en dispositivos registrados mediante el uso de perfiles de aprovisionamiento . Apple tambi\u00e9n permite distribuir una app de forma restringida, s\u00f3lo a los dispositivos particulares de los empleados de una empresa. Para ello es necesario darse de alta en el Apple Developer Enterprise Program y utilizar tambi\u00e9n el perfil de aprovisionamiento apropiado. Perfil de aprovisionamiento Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio ~Library/MobileDevice/Provisioning Profiles . Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode. Es posible consultar su contenido desde el terminal con el comando: 1 security cms -D -i perfil .mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder: Dispositivos de prueba en el perfil de aprovisionamiento El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento ( provisioning profile ) y los permisos ( entitlements ) se usa para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store . Instalaci\u00f3n de la app en un dispositivo de prueba Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. Contiene funcionalidades que se han extra\u00eddo de iTunes. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado. Ejecuci\u00f3n de apps en dispositivos no registrados Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple. Certificados de empresa Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house . Demo Resumen del flujo de trabajo Es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Los dispositivos que se usan para el desarrollo deben ser registrados y a\u00f1adidos en el perfil de aprovisionamiento que uses para firmar la app. Si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode (es lo recomendado), Xcode crea estos elementos de forma autom\u00e1tica. Si perteneces a un equipo, algunos de estos permisos deben ser configurados por el administrador del equipo en la web de desarrollador de Apple. Pasos a seguir: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba. Equipo de desarrollo del programa de Universidad La mayor\u00eda de opciones en el member center ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde el member center o desde Xcode. Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el member center o en la aplicaci\u00f3n de Acceso a llaveros: Firma de la app con el nuevo certificado Para firmar la app con el nuevo certificado dejamos marcada la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma. Seleccionamos el team Universidad de Alicante. Aparecen los siguientes errores porque Xcode no puede realizar autom\u00e1ticamente las actualizaciones que necesita: La cuenta no tiene permisos suficientes para crear un perfil de aprovisionamiento. No existe perfil de aprovisionamiento aplicable al bundle ID de la app. Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el member center e incorporar en ese perfil el certificado del desarrollador. Examinamos los perfiles de aprovisionamiento Podemos examinar los perfiles de aprovisionamiento desde el Member Center o desde Xcode y el terminal En el Member Center tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento. Men\u00fa de opciones Contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps Creaci\u00f3n un App ID desde Member Center S\u00f3lo se puede hacer con el rol administrador. Dispositivos Para a\u00f1adir un dispositivo a un certificado de aprovisionamiento hay que a\u00f1adir su UDID, Unique Device Identifier . Cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9). Desde Xcode se puede obtener en la pantalla de Dispositivos ( Window Devices ). Se pueden registrar en el Member Center hasta 200 UDIDs para probar aplicaciones en desarrollo. Creaci\u00f3n de perfiles de aprovisionamento Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el Member Center y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde Member Center , ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n. Nuevo perfil de aprovisionamiento desde Member Center Firma de la app ToDoList con el perfil de aprovisionamiento creado Una vez creado el perfil de aprovisionamiento ya es posible aplicarlo a la app. Basta con definir un bundle ID compatible con el App ID definido en el perfil. En este caso, al haber definido un App ID \u00fanico (sin el * ) se define como bundle ID el mismo. El perfil de aprovisionamiento correspondiente se descarga autom\u00e1ticamente. Selecci\u00f3n manual del perfil de aprovisionamiento Es posible seleccionar manualmente un perfil de aprovisionamiento del member center eliminando la opci\u00f3n de Xcode de gesti\u00f3n autom\u00e1tica de la firma. Capabilities El perfil de aprovisionamiento que hemos creado permite 3 capabilities: Game Center In-App Purchase Keychain Sharing Es posible activar cualquiera de estos servicios en la app, en el men\u00fa Capabilities . Ahora este men\u00fa muestra m\u00e1s servicios posibles, al pertenecer al equipo de la UA: Activaci\u00f3n del permiso de Game Center Si se activa el permiso de Game Center Xcode se asegurar\u00e1 e que el perfil de aprovisionamiento seleccionado proporcione este permiso. Si no es as\u00ed aparecer\u00e1 un error y el bot\u00f3n Fix Issue. Es posible comprobar el error si se intenta activar el permiso Push Notificacions . Xcode puede arreglar el error creando un nuevo perfil de aprovisionamiento y subi\u00e9ndolo al Member Center . Para ello hay que tener permisos apropiados en la cuenta de desarrollador (ser un administrador del equipo en el caso de una organizaci\u00f3n o el propietario del equipo en el caso de un programa de desarrollo). Exportar la app Seleccionando en Xcode la opci\u00f3n Product Archive ahora ya est\u00e1 activa la opci\u00f3n Export Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Tarda un buen rato en generar el fichero ipa ( iOS App file ). El fichero generado es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento. Instalaci\u00f3n y ejecuci\u00f3n de la app Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2. Distribuci\u00f3n e instalaci\u00f3n de betas online Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple (lo veremos m\u00e1s adelante). Pero este servicio s\u00f3lo est\u00e1 disponible para apps enviadas al App Store. Es necesario para ello una cuenta de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Es lo que se consigue con servicios como el que vamos a ver: Fabric. Fabric Fabric es una plataforma y API que permite una gran cantidad de funcionalidades: distribuci\u00f3n, recopilaci\u00f3n de datos de crashes, recopilaci\u00f3n de estad\u00edsticas de uso, etc. Se trata de una plataforma creada por Twitter y comprada por Google en enero de 2017. Se puede acceder desde esta URL . En este a\u00f1o 2019 Google realizar\u00e1 la integraci\u00f3n del servicio en Firebase. Demo Alta y descarga de Fabric Debemos registrarnos en Fabric con nuestro correo electr\u00f3nico y nuestro nombre. Escribimos como nombre de la organizaci\u00f3n nuestro propio nombre. Hay entrar en el dashboard y descargar e instalar la aplicaci\u00f3n para Mac, movi\u00e9ndola a la carpeta de Aplicaciones. La \u00faltima versi\u00f3n es la 2.7.5. Una vez descargada, hay que registrarse en la aplicaci\u00f3n en ella con la misma cuenta y contrase\u00f1a que en la web. Instalaci\u00f3n de Fabric La aplicaci\u00f3n Fabric nos gu\u00eda paso a paso: Debemos seleccionar el proyecto XCode y a\u00f1adir un Run Script Build Phase . Se selecciona en Xcode Build Phases y en el s\u00edmbolo + se selecciona New Run Script Build Phase . En la opci\u00f3n Run Script se pega el c\u00f3digo que aparece en la aplicaci\u00f3n. Compilamos la aplicaci\u00f3n con la opci\u00f3n Product Build . Se instala el SDK Kit en el proyecto, arrastrando desde la aplicaci\u00f3n al proyecto. Debemos copiar el c\u00f3digo indicado en el fichero AppDelegate.swift . Y volvemos a compilar la aplicaci\u00f3n y la ejecutamos en el simulador. La aplicaci\u00f3n de Fabric detectar\u00e1 que la hemos lanzado y aparecer\u00e1 una pantalla indicando que todo ha ido correctamente. Tambi\u00e9n recibiremos un correo electr\u00f3nico indicando que la app ya se ha subido y est\u00e1 disponible para su distribuci\u00f3n. Distribuci\u00f3n a probadores Debemos seleccionar en Xcode la opci\u00f3n de Product Archive . Cuidado Recuerda que para habilitar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Autom\u00e1ticamente la app aparecer\u00e1 en la aplicaci\u00f3n de Fabric. Podremos activar la distribuci\u00f3n, a\u00f1adiendo los correos electr\u00f3nicos de las personas a las que se les enviar\u00e1. Si el UUID del dispositivo del probador est\u00e1 incluido en el perfil de aprovisionamiento podr\u00e1 ejecutar la app sin problemas. Si no, Fabric obtendr\u00e1 el UUID y nos lo proporcionar\u00e1 para que actualicemos el perfil de aprovisionamiento. Ejecuci\u00f3n de la app por el probador El probador recibe un e-mail que le dirige a una p\u00e1gina web desde la que debe instalar un perfil (que ser\u00e1 el que permitir\u00e1 leer el UUID del dispositivo y comprobar si est\u00e1 incluido en el perfil de aprovisionamiento instalado en la app que se distribuye). Si el dispositivo puede ejecutar la app aparecer\u00e1 un bot\u00f3n para instalarla. La forma de instalarla ser\u00e1 tan sencilla como pulsar ese bot\u00f3n (no hay necesidad de usar iTunes ni Xcode). Si el dispositivo no puede ejecutar la app, aparecer\u00e1 un mensaje indic\u00e1ndolo y nos informar\u00e1 del UUID. Dashboard de Fabric En el dashboard ( https:/fabric.io ) podemos acceder a estad\u00edsticas de descargas e instalaciones, informaci\u00f3n sobre los crashes de nuestra apps, etc. Tambi\u00e9n podemos invitar nuevos probadores y crear un enlace desde el que es posible instalar la app. Cuando se pulsa en el enlace se accede a una p\u00e1gina en la que se pide el e-mail de la persona que va a probar la app. Test Flight Distribuci\u00f3n de apps El proceso de distribuci\u00f3n de apps en el App Store es el siguiente: App Store Connect App Store Connect es el servicio de Apple con el que los desarrolladores pueden organizar: Todas sus apps para poder enviar a prueba versiones beta y subirlas al App Store. Toda la informaci\u00f3n legal y de impuestos. Informaci\u00f3n sobre el estado de los productos, retroalimentaci\u00f3n e informaci\u00f3n de descargas, ventas y ganancias. La plataforma est\u00e1 accesible desde el member center en los programas de pago. No est\u00e1 disponible en el programa de universidad. Tambi\u00e9n se puede acceder desde la URL https://appstoreconnect.apple.com . Nota Hasta el a\u00f1o pasado (2018) iTunes Connect era la plataforma \u00fanica a la que se sub\u00edan todos los productos para su distribuci\u00f3n (apps, ebooks, podcasts, m\u00fasica). A mediados del 2018 Apple divide en dos esa plataforma, creando App Store Connect para gestionar \u00fanicamente apps. Hemos conservado algunas im\u00e1gnes del curso pasado en el caso en sean muy similares a las actuales. En estas im\u00e1genes aparece la cabecera iTunes Connect en lugar de App Store Connect . Pasos para subir una app al App Store desde App Store Connect Crear un registro en App Store Connect, un identificador \u00fanico para el app. Subir una compilaci\u00f3n de la app. Pruebas Beta: probar la app con usuarios de la organizaci\u00f3n o usuarios invitados, usando Test Flight . Completar toda la informaci\u00f3n y enviar la app a revisi\u00f3n de la App Store. Una vez que ha superado la revisi\u00f3n, la app se pone a la venta en la App Store. Analizar anal\u00edticas de la app (de ventas, de uso, etc.) y desarrollar una nueva versi\u00f3n. Subir una compilaci\u00f3n de la app La forma m\u00e1s sencilla de subir una app a App Store Connect es utilizando Xcode. Debes crear un archivo ipa con la opci\u00f3n Product Archive y seleccionar la opci\u00f3n Upload to App Store . Es posible subir distintos builds y gestionarlos todos desde App Store Connect. El identificador de la app es su bundle id . A\u00f1adir informaci\u00f3n de la App Una vez que se ha subido la app, podemos a\u00f1adir informaci\u00f3n sobre ella: Dise\u00f1o de la p\u00e1gina en el App Store En el App Store se muestra distinta informaci\u00f3n sobre la app. Es importante dise\u00f1ar bien esta p\u00e1gina para que sea atractiva para los usuarios y est\u00e9n interesados en descargar la app. App Store Connect se usa para gestionar estos los elementos necesarios para crear la p\u00e1gina de la app en el App Store: nombre de la App, iconos, previsualizaciones (pantallas y v\u00eddeos), descripci\u00f3n, novedades, palabras claves y categor\u00edas. Nuevos usuarios App Store Connect Es posible a\u00f1adir usuarios a la cuenta de App Store Connect. Son usuarios que van a poder trabajar con las apps subidas, realizando funciones limitadas por su funci\u00f3n. No es necesario tener una cuenta de organizaci\u00f3n para poder a\u00f1adir usuarios colaboradores en App Store Connect. Es posible en cuentas de desarrollador individual. Los usuarios a\u00f1adidos podr\u00e1n ser probadores internos en TestFlight. TestFlight TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos. Aprobaci\u00f3n de pruebas externas Una vez subida a App Store Connect la app entra autom\u00e1ticamente en un proceso de aprobaci\u00f3n para que se pueda distribuir externamente una versi\u00f3n beta en TestFlight. La aprobaci\u00f3n suele tardar menos de 1 d\u00eda la primera compilaci\u00f3n y ser casi instant\u00e1nea cada nueva compilaci\u00f3n que se sube. No es necesaria aprobaci\u00f3n para la distribuci\u00f3n de pruebas internas. TestFlight en App Store Connect Demo Vamos a comprobar el funcionamiento de TestFlight, subiendo la app ToDoList, a\u00f1adiendo probadores y comprobando la instalaci\u00f3n de la app en los probadores. Registro de una app en App Store Connect Antes de subir una app al App Store, hay que crear un registro de la misma indicando un identificador \u00fanico (SKU) que puede ser el propio bundle ID y seleccionando el App ID. Subida a App Store Connect con Xcode Una vez creado el registro de la app ya es posible subirla desde Xcode. Compilaciones listas para probar Una vez que se ha subido a App Store Connect y ha pasado un tiempo necesario para que la plataforma prueba que la app puede ser distribuida para pruebas, aparecer\u00e1 con un indicador verde lista para probar. Los n\u00fameros de versi\u00f3n y de compilaci\u00f3n ( build ) son los definidos en Xcode. Ahora la app est\u00e1 lista para que sea probada por los usuarios de prueba internos. Podemos seleccionar la compilaci\u00f3n a distribuir. A\u00f1adir probadores externos y enlace de prueba Podemos tambi\u00e9n a\u00f1adir usuarios de prueba externos y un enlace de prueba que puede ser usado por cualquiera. Para ello es necesario crear un grupo de prueba y volver a solicitar una autorizaci\u00f3n de env\u00edo a pruebas de la app. Debe pasar un tiempo para App Store Connect apruebe la distribuci\u00f3n de prueba. Mientras tanto la compilaci\u00f3n seleccionada aparecer\u00e1 en estado Pendiente de revisi\u00f3n . Una vez aprobada la distribuci\u00f3n es posible crear un enlace para que cualquiera la pueda instalar y probar. TestFlight en los usuarios Los usuarios de prueba reciben un correo avis\u00e1ndoles de que la beta est\u00e1 disponible. Deben instalar la app TestFlight y en la app aparecer\u00e1 un bot\u00f3n que permitir\u00e1 instalar la app en el dispositivo. En este caso no es necesario que el dispositivo est\u00e9 en la lista incluida en el perfil de aprovisionamiento, porque la app est\u00e1 autorizada por Apple para su ejecuci\u00f3n en cualquier dispositivo. Nuevas compilaciones Cuando subimos desde Xcode una nueva compilaci\u00f3n, debemos entrar en el enlace de la compilaci\u00f3n para activar la nueva prueba. TestFlight enviar\u00e1 una notificaci\u00f3n autom\u00e1ticamente a todos los usuarios para que descarguen la nueva versi\u00f3n. Pr\u00e1cticas En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n lo que debes realizar: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA y firmar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Distribuir esta app firmada con el perfil de aprovisionamiento del equipo de la UA usando Fabric. Creaci\u00f3n de la cuenta de desarrollador Apple Deber\u00e1s crear un Apple ID introduciendo tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Activa la autenticaci\u00f3n de doble factor de alguna de las formas definida en este enlace . Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . De esta forma est\u00e1s accediendo al programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo Descarga la app ToDoList . Incluye tu nombre en alguna parte de la interfaz de usuario. F\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Inst\u00e1lala en un dispositivo de desarrollo conectado a Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Configuraci\u00f3n de la cuenta de desarrollador Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos y direcci\u00f3n de e-mail en este fichero Google Docs . Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n podemos entrar en el member center , comprobar que ya est\u00e1s en el programa y probar las distintas opciones disponibles. Firma y despliegue de app con perfil de aprovisionamiento Debes seguir los pasos realizados en la demostraci\u00f3n con la app ToDoList . Nos damos de alta al equipo de la universidad. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba. Distribuci\u00f3n con Fabric Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Entregas Resumen de las pr\u00e1cticas a realizar en esta sesi\u00f3n y entregas a realizar en Moodle. Descarga la app ToDoList (o usa una app tuya que hayas desarrollado) y f\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Modifica la app para que aparezca tu nombre en la interfaz de usuario. Inst\u00e1lala en un dispositivo de desarrollo de Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Firma la app con tu cuenta del equipo de la UA, activa el servicio de Game Center e inst\u00e1lala en otro dispositivo del profesor que est\u00e9 dado de alta en el perfil de aprovisionamiento, pero que no sea el dispositivo de desarrollo de Xcode. Instala la app usando Apple Configurator 2 . Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Guarda las fotograf\u00edas y pantallas en una carpeta, junto con el binario .ipa de la actividad 2, comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 . Bibliograf\u00eda Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Test Flight Documentaci\u00f3n de Fabric","title":"Firma, aprovisionamiento y distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#sesion-1-firma-aprovisionamiento-y-distribucion-de-apps","text":"","title":"Sesi\u00f3n 1:  Firma, aprovisionamiento y  distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#introduccion","text":"En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps de iOS usando Test Flight y App Store Connect.","title":"Introducci\u00f3n"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#seguridad-en-las-apps","text":"La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable.","title":"Seguridad en las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#cuenta-de-desarrollador-de-apple","text":"","title":"Cuenta de desarrollador de Apple"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distintos-programas-de-desarrollo","text":"Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el member center de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ :","title":"Distintos programas de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#cuenta-de-desarrollador","text":"Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder a la cuenta de desarrollador , en la que podremos gestionar numerosos elementos que veremos durante el curso. Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store.","title":"Cuenta de desarrollador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#equipo-de-desarrollo","text":"En todos los programas de pago de desarrollador de Apple, incluso en los programas individuales, es posible trabajar con un equipo de desarrolladores. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership de la cuenta de desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight.","title":"Equipo de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo","text":"Veremos una demostraci\u00f3n en la que accederemos a la cuenta de desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es)","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#certificados","text":"","title":"Certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#codigo-firmado","text":"Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma.","title":"C\u00f3digo firmado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#identidad-de-firma","text":"Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en la cuenta de desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador.","title":"Identidad de firma"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#tipos-de-certificados","text":"Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el member center , Xcode o Acceso a llaveros .","title":"Tipos de certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#gestion-de-los-certificados-en-xcode","text":"Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra las dos identidades y nos permite utilizar la que nos interese en cada momento.","title":"Gesti\u00f3n de los certificados en Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-e-instalacion-de-certificados","text":"Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se descarga de los servidores de Apple e instala autom\u00e1ticamente el certificados de firma.","title":"Creaci\u00f3n e instalaci\u00f3n de certificados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-reales","text":"Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) correcto que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store.","title":"Ejecuci\u00f3n de apps en dispositivos reales"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_1","text":"Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode.","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-la-identidad-de-firma","text":"Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito.","title":"Instalaci\u00f3n de la identidad de firma"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-una-app","text":"Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app.","title":"Firma de una app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-ejemplo-todolist","text":"Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Podemos descargar la app de esta direcci\u00f3n y probar a ejecutarla en el simulador. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador.","title":"App ejemplo ToDoList"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#comprobacion-del-certificado","text":"En la pantalla de Xcode Preferences... Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode .","title":"Comprobaci\u00f3n del certificado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#comprobacion-de-la-identidad-de-firma-en-acceso-a-llaveros","text":"En la aplicaci\u00f3n Acceso a Llaveros y podemos comprobar que se ha instalado el certificado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n .","title":"Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#conexion-de-un-dispositivo-real-a-xcode","text":"Conectamos un dispositivo iOS real al ordenador. En Xcode seleccionamos Window Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo.","title":"Conexi\u00f3n de un dispositivo real a Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#prueba-en-un-dispositivo-real","text":"Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica.","title":"Prueba en un dispositivo real"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#autorizacion-al-desarrollador-en-el-dispositivo","text":"Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app.","title":"Autorizaci\u00f3n al desarrollador en el dispositivo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app","text":"Seleccionando la opci\u00f3n de Xcode Product Archive se accede al panel de archivo y distribuci\u00f3n de la app La opci\u00f3n de exportar la app est\u00e1 deshabilitado por que estamos registrados con el programa gratuito. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita.","title":"Archivo y distribuci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#despliegue-de-apps-en-dispositivos-de-prueba","text":"","title":"Despliegue de apps en dispositivos de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#capacidades-de-las-apps","text":"Para poder utilizar servicios avanzados proporcionados por Apple en las apps (como notificaciones push, iCloud o Game Center) es necesario darse de alta de forma individual en el programa de desarrollo de iOS o formar parte de un equipo de desarrollo. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer Support Advanced App Capabilities . Con el programa de desarrollo de la Universidad podemos acceder a m\u00e1s servicios que a los gratuitos, pero no a todos los servicios disponibles. La lista de servicios accesibles son los siguientes:","title":"Capacidades de las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#permisos-para-las-apps","text":"Un permiso ( entitlement ) es un elemento de configuraci\u00f3n incluido en la firma digital de la app que le indica al sistema que permita a la app acceder a ciertos recursos o realizar ciertas operaciones. La forma de otorgar los permisos a una app es algo elaborada, para permitir una configuraci\u00f3n flexible y no atar los permisos a una \u00fanica app. El responsable de la cuenta de desarrollador debe crear un identificador denominado App ID y otorgar los permisos a ese identificador.","title":"Permisos para las apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#bundle-identifier","text":"Un bundle ID identifica de forma \u00fanica una app. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). La cadena deber\u00eda estar en un formato DNS-inverso y usar un dominio propio de la organizaci\u00f3n. De esta forma se garantiza su unicidad. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hello .","title":"Bundle Identifier"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#uso-del-bundle-id","text":"Se utiliza durante el desarrollo para aprovisionar dispositivos y por el sistema operativo cuando la app se distribuye a los clientes. Por ejemplo, los servicios de Game Center o de compras In-App usan el bundle ID para identificar la app cuando utilizan estos servicios.","title":"Uso del Bundle ID"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-id","text":"El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el member center . Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con permiso de acceso a iCloud y todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que permite que una o m\u00e1s apps desarrolladas por el equipo accedan a los permisos otorgados. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del APP ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha.","title":"App ID"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#gestion-de-las-capacidades-en-xcode","text":"En Xcode se deben indicar las capacidades que necesita la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Capabilities . Dependiendo del programa de desarrollo en el que estemos tendremos m\u00e1s o menos capacidades disponibles. Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el member center alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores.","title":"Gesti\u00f3n de las capacidades en Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#aprovisionamiento-de-apps","text":"Es necesario configurar un perfil de aprovisionamiento para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push) y para configurar dispositivos de prueba en los que podamos ejecutar la app. Con la cuenta de desarrollador gratuita es posible desarrollar aplicaciones, acceder a un n\u00famero limitado de servicios de Apple y probarlas configurando el dispositivo propio como un dispositivo de desarrollo. Pero es una forma muy limitada de prueba porque es necesario conectar f\u00edsicamente el dispositivo al ordenador en el que est\u00e1 Xcode. Es posible ejecutar apps en dispositivos de prueba sin tener que configurarlos como dispositivos de desarrollo usando perfiles de aprovisionamiento . Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad.","title":"Aprovisionamiento de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-de-apps","text":"La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran. Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Como ya hemos dicho, Apple permite ejecutar apps en dispositivos registrados mediante el uso de perfiles de aprovisionamiento . Apple tambi\u00e9n permite distribuir una app de forma restringida, s\u00f3lo a los dispositivos particulares de los empleados de una empresa. Para ello es necesario darse de alta en el Apple Developer Enterprise Program y utilizar tambi\u00e9n el perfil de aprovisionamiento apropiado.","title":"Distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#perfil-de-aprovisionamiento","text":"Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio ~Library/MobileDevice/Provisioning Profiles . Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode. Es posible consultar su contenido desde el terminal con el comando: 1 security cms -D -i perfil .mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder:","title":"Perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dispositivos-de-prueba-en-el-perfil-de-aprovisionamiento","text":"El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento ( provisioning profile ) y los permisos ( entitlements ) se usa para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store .","title":"Dispositivos de prueba en el perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-la-app-en-un-dispositivo-de-prueba","text":"Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. Contiene funcionalidades que se han extra\u00eddo de iTunes. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado.","title":"Instalaci\u00f3n de la app en un dispositivo de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-no-registrados","text":"Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple.","title":"Ejecuci\u00f3n de apps en dispositivos no registrados"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#certificados-de-empresa","text":"Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house .","title":"Certificados de empresa"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_2","text":"","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#resumen-del-flujo-de-trabajo","text":"Es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Los dispositivos que se usan para el desarrollo deben ser registrados y a\u00f1adidos en el perfil de aprovisionamiento que uses para firmar la app. Si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode (es lo recomendado), Xcode crea estos elementos de forma autom\u00e1tica. Si perteneces a un equipo, algunos de estos permisos deben ser configurados por el administrador del equipo en la web de desarrollador de Apple. Pasos a seguir: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba.","title":"Resumen del flujo de trabajo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#equipo-de-desarrollo-del-programa-de-universidad","text":"La mayor\u00eda de opciones en el member center ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde el member center o desde Xcode. Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el member center o en la aplicaci\u00f3n de Acceso a llaveros:","title":"Equipo de desarrollo del programa de Universidad"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-la-app-con-el-nuevo-certificado","text":"Para firmar la app con el nuevo certificado dejamos marcada la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma. Seleccionamos el team Universidad de Alicante. Aparecen los siguientes errores porque Xcode no puede realizar autom\u00e1ticamente las actualizaciones que necesita: La cuenta no tiene permisos suficientes para crear un perfil de aprovisionamiento. No existe perfil de aprovisionamiento aplicable al bundle ID de la app. Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el member center e incorporar en ese perfil el certificado del desarrollador.","title":"Firma de la app con el nuevo certificado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#examinamos-los-perfiles-de-aprovisionamiento","text":"Podemos examinar los perfiles de aprovisionamiento desde el Member Center o desde Xcode y el terminal En el Member Center tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento.","title":"Examinamos los perfiles de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#menu-de-opciones","text":"Contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps","title":"Men\u00fa de opciones"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-un-app-id-desde-member-center","text":"S\u00f3lo se puede hacer con el rol administrador.","title":"Creaci\u00f3n un App ID desde Member Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dispositivos","text":"Para a\u00f1adir un dispositivo a un certificado de aprovisionamiento hay que a\u00f1adir su UDID, Unique Device Identifier . Cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9). Desde Xcode se puede obtener en la pantalla de Dispositivos ( Window Devices ). Se pueden registrar en el Member Center hasta 200 UDIDs para probar aplicaciones en desarrollo.","title":"Dispositivos"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-de-perfiles-de-aprovisionamento","text":"Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el Member Center y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde Member Center , ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n.","title":"Creaci\u00f3n de perfiles de aprovisionamento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevo-perfil-de-aprovisionamiento-desde-member-center","text":"","title":"Nuevo perfil de aprovisionamiento desde Member Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-de-la-app-todolist-con-el-perfil-de-aprovisionamiento-creado","text":"Una vez creado el perfil de aprovisionamiento ya es posible aplicarlo a la app. Basta con definir un bundle ID compatible con el App ID definido en el perfil. En este caso, al haber definido un App ID \u00fanico (sin el * ) se define como bundle ID el mismo. El perfil de aprovisionamiento correspondiente se descarga autom\u00e1ticamente.","title":"Firma de la app ToDoList con el perfil de aprovisionamiento creado"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#seleccion-manual-del-perfil-de-aprovisionamiento","text":"Es posible seleccionar manualmente un perfil de aprovisionamiento del member center eliminando la opci\u00f3n de Xcode de gesti\u00f3n autom\u00e1tica de la firma.","title":"Selecci\u00f3n manual del perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#capabilities","text":"El perfil de aprovisionamiento que hemos creado permite 3 capabilities: Game Center In-App Purchase Keychain Sharing Es posible activar cualquiera de estos servicios en la app, en el men\u00fa Capabilities . Ahora este men\u00fa muestra m\u00e1s servicios posibles, al pertenecer al equipo de la UA:","title":"Capabilities"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#activacion-del-permiso-de-game-center","text":"Si se activa el permiso de Game Center Xcode se asegurar\u00e1 e que el perfil de aprovisionamiento seleccionado proporcione este permiso. Si no es as\u00ed aparecer\u00e1 un error y el bot\u00f3n Fix Issue. Es posible comprobar el error si se intenta activar el permiso Push Notificacions . Xcode puede arreglar el error creando un nuevo perfil de aprovisionamiento y subi\u00e9ndolo al Member Center . Para ello hay que tener permisos apropiados en la cuenta de desarrollador (ser un administrador del equipo en el caso de una organizaci\u00f3n o el propietario del equipo en el caso de un programa de desarrollo).","title":"Activaci\u00f3n del permiso de Game Center"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#exportar-la-app","text":"Seleccionando en Xcode la opci\u00f3n Product Archive ahora ya est\u00e1 activa la opci\u00f3n Export Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Tarda un buen rato en generar el fichero ipa ( iOS App file ). El fichero generado es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento.","title":"Exportar la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-y-ejecucion-de-la-app","text":"Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2.","title":"Instalaci\u00f3n y ejecuci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-e-instalacion-de-betas-online","text":"Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple (lo veremos m\u00e1s adelante). Pero este servicio s\u00f3lo est\u00e1 disponible para apps enviadas al App Store. Es necesario para ello una cuenta de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Es lo que se consigue con servicios como el que vamos a ver: Fabric.","title":"Distribuci\u00f3n e instalaci\u00f3n de betas online"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#fabric","text":"Fabric es una plataforma y API que permite una gran cantidad de funcionalidades: distribuci\u00f3n, recopilaci\u00f3n de datos de crashes, recopilaci\u00f3n de estad\u00edsticas de uso, etc. Se trata de una plataforma creada por Twitter y comprada por Google en enero de 2017. Se puede acceder desde esta URL . En este a\u00f1o 2019 Google realizar\u00e1 la integraci\u00f3n del servicio en Firebase.","title":"Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_3","text":"","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#alta-y-descarga-de-fabric","text":"Debemos registrarnos en Fabric con nuestro correo electr\u00f3nico y nuestro nombre. Escribimos como nombre de la organizaci\u00f3n nuestro propio nombre. Hay entrar en el dashboard y descargar e instalar la aplicaci\u00f3n para Mac, movi\u00e9ndola a la carpeta de Aplicaciones. La \u00faltima versi\u00f3n es la 2.7.5. Una vez descargada, hay que registrarse en la aplicaci\u00f3n en ella con la misma cuenta y contrase\u00f1a que en la web.","title":"Alta y descarga de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#instalacion-de-fabric","text":"La aplicaci\u00f3n Fabric nos gu\u00eda paso a paso: Debemos seleccionar el proyecto XCode y a\u00f1adir un Run Script Build Phase . Se selecciona en Xcode Build Phases y en el s\u00edmbolo + se selecciona New Run Script Build Phase . En la opci\u00f3n Run Script se pega el c\u00f3digo que aparece en la aplicaci\u00f3n. Compilamos la aplicaci\u00f3n con la opci\u00f3n Product Build . Se instala el SDK Kit en el proyecto, arrastrando desde la aplicaci\u00f3n al proyecto. Debemos copiar el c\u00f3digo indicado en el fichero AppDelegate.swift . Y volvemos a compilar la aplicaci\u00f3n y la ejecutamos en el simulador. La aplicaci\u00f3n de Fabric detectar\u00e1 que la hemos lanzado y aparecer\u00e1 una pantalla indicando que todo ha ido correctamente. Tambi\u00e9n recibiremos un correo electr\u00f3nico indicando que la app ya se ha subido y est\u00e1 disponible para su distribuci\u00f3n.","title":"Instalaci\u00f3n de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-a-probadores","text":"Debemos seleccionar en Xcode la opci\u00f3n de Product Archive . Cuidado Recuerda que para habilitar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Autom\u00e1ticamente la app aparecer\u00e1 en la aplicaci\u00f3n de Fabric. Podremos activar la distribuci\u00f3n, a\u00f1adiendo los correos electr\u00f3nicos de las personas a las que se les enviar\u00e1. Si el UUID del dispositivo del probador est\u00e1 incluido en el perfil de aprovisionamiento podr\u00e1 ejecutar la app sin problemas. Si no, Fabric obtendr\u00e1 el UUID y nos lo proporcionar\u00e1 para que actualicemos el perfil de aprovisionamiento.","title":"Distribuci\u00f3n a probadores"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#ejecucion-de-la-app-por-el-probador","text":"El probador recibe un e-mail que le dirige a una p\u00e1gina web desde la que debe instalar un perfil (que ser\u00e1 el que permitir\u00e1 leer el UUID del dispositivo y comprobar si est\u00e1 incluido en el perfil de aprovisionamiento instalado en la app que se distribuye). Si el dispositivo puede ejecutar la app aparecer\u00e1 un bot\u00f3n para instalarla. La forma de instalarla ser\u00e1 tan sencilla como pulsar ese bot\u00f3n (no hay necesidad de usar iTunes ni Xcode). Si el dispositivo no puede ejecutar la app, aparecer\u00e1 un mensaje indic\u00e1ndolo y nos informar\u00e1 del UUID.","title":"Ejecuci\u00f3n de la app por el probador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#dashboard-de-fabric","text":"En el dashboard ( https:/fabric.io ) podemos acceder a estad\u00edsticas de descargas e instalaciones, informaci\u00f3n sobre los crashes de nuestra apps, etc. Tambi\u00e9n podemos invitar nuevos probadores y crear un enlace desde el que es posible instalar la app. Cuando se pulsa en el enlace se accede a una p\u00e1gina en la que se pide el e-mail de la persona que va a probar la app.","title":"Dashboard de Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#test-flight","text":"","title":"Test Flight"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-de-apps_1","text":"El proceso de distribuci\u00f3n de apps en el App Store es el siguiente:","title":"Distribuci\u00f3n de apps"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#app-store-connect","text":"App Store Connect es el servicio de Apple con el que los desarrolladores pueden organizar: Todas sus apps para poder enviar a prueba versiones beta y subirlas al App Store. Toda la informaci\u00f3n legal y de impuestos. Informaci\u00f3n sobre el estado de los productos, retroalimentaci\u00f3n e informaci\u00f3n de descargas, ventas y ganancias. La plataforma est\u00e1 accesible desde el member center en los programas de pago. No est\u00e1 disponible en el programa de universidad. Tambi\u00e9n se puede acceder desde la URL https://appstoreconnect.apple.com . Nota Hasta el a\u00f1o pasado (2018) iTunes Connect era la plataforma \u00fanica a la que se sub\u00edan todos los productos para su distribuci\u00f3n (apps, ebooks, podcasts, m\u00fasica). A mediados del 2018 Apple divide en dos esa plataforma, creando App Store Connect para gestionar \u00fanicamente apps. Hemos conservado algunas im\u00e1gnes del curso pasado en el caso en sean muy similares a las actuales. En estas im\u00e1genes aparece la cabecera iTunes Connect en lugar de App Store Connect .","title":"App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#pasos-para-subir-una-app-al-app-store-desde-app-store-connect","text":"Crear un registro en App Store Connect, un identificador \u00fanico para el app. Subir una compilaci\u00f3n de la app. Pruebas Beta: probar la app con usuarios de la organizaci\u00f3n o usuarios invitados, usando Test Flight . Completar toda la informaci\u00f3n y enviar la app a revisi\u00f3n de la App Store. Una vez que ha superado la revisi\u00f3n, la app se pone a la venta en la App Store. Analizar anal\u00edticas de la app (de ventas, de uso, etc.) y desarrollar una nueva versi\u00f3n.","title":"Pasos para subir una app al App Store desde App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#subir-una-compilacion-de-la-app","text":"La forma m\u00e1s sencilla de subir una app a App Store Connect es utilizando Xcode. Debes crear un archivo ipa con la opci\u00f3n Product Archive y seleccionar la opci\u00f3n Upload to App Store . Es posible subir distintos builds y gestionarlos todos desde App Store Connect. El identificador de la app es su bundle id .","title":"Subir una compilaci\u00f3n de la app"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#anadir-informacion-de-la-app","text":"Una vez que se ha subido la app, podemos a\u00f1adir informaci\u00f3n sobre ella:","title":"A\u00f1adir informaci\u00f3n de la App"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#diseno-de-la-pagina-en-el-app-store","text":"En el App Store se muestra distinta informaci\u00f3n sobre la app. Es importante dise\u00f1ar bien esta p\u00e1gina para que sea atractiva para los usuarios y est\u00e9n interesados en descargar la app. App Store Connect se usa para gestionar estos los elementos necesarios para crear la p\u00e1gina de la app en el App Store: nombre de la App, iconos, previsualizaciones (pantallas y v\u00eddeos), descripci\u00f3n, novedades, palabras claves y categor\u00edas.","title":"Dise\u00f1o de la p\u00e1gina en el App Store"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevos-usuarios-app-store-connect","text":"Es posible a\u00f1adir usuarios a la cuenta de App Store Connect. Son usuarios que van a poder trabajar con las apps subidas, realizando funciones limitadas por su funci\u00f3n. No es necesario tener una cuenta de organizaci\u00f3n para poder a\u00f1adir usuarios colaboradores en App Store Connect. Es posible en cuentas de desarrollador individual. Los usuarios a\u00f1adidos podr\u00e1n ser probadores internos en TestFlight.","title":"Nuevos usuarios App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight","text":"TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos.","title":"TestFlight"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#aprobacion-de-pruebas-externas","text":"Una vez subida a App Store Connect la app entra autom\u00e1ticamente en un proceso de aprobaci\u00f3n para que se pueda distribuir externamente una versi\u00f3n beta en TestFlight. La aprobaci\u00f3n suele tardar menos de 1 d\u00eda la primera compilaci\u00f3n y ser casi instant\u00e1nea cada nueva compilaci\u00f3n que se sube. No es necesaria aprobaci\u00f3n para la distribuci\u00f3n de pruebas internas.","title":"Aprobaci\u00f3n de pruebas externas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight-en-app-store-connect","text":"","title":"TestFlight en App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#demo_4","text":"Vamos a comprobar el funcionamiento de TestFlight, subiendo la app ToDoList, a\u00f1adiendo probadores y comprobando la instalaci\u00f3n de la app en los probadores.","title":"Demo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#registro-de-una-app-en-app-store-connect","text":"Antes de subir una app al App Store, hay que crear un registro de la misma indicando un identificador \u00fanico (SKU) que puede ser el propio bundle ID y seleccionando el App ID.","title":"Registro de una app en App Store Connect"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#subida-a-app-store-connect-con-xcode","text":"Una vez creado el registro de la app ya es posible subirla desde Xcode.","title":"Subida a App Store Connect con Xcode"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#compilaciones-listas-para-probar","text":"Una vez que se ha subido a App Store Connect y ha pasado un tiempo necesario para que la plataforma prueba que la app puede ser distribuida para pruebas, aparecer\u00e1 con un indicador verde lista para probar. Los n\u00fameros de versi\u00f3n y de compilaci\u00f3n ( build ) son los definidos en Xcode. Ahora la app est\u00e1 lista para que sea probada por los usuarios de prueba internos. Podemos seleccionar la compilaci\u00f3n a distribuir.","title":"Compilaciones listas para probar"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#anadir-probadores-externos-y-enlace-de-prueba","text":"Podemos tambi\u00e9n a\u00f1adir usuarios de prueba externos y un enlace de prueba que puede ser usado por cualquiera. Para ello es necesario crear un grupo de prueba y volver a solicitar una autorizaci\u00f3n de env\u00edo a pruebas de la app. Debe pasar un tiempo para App Store Connect apruebe la distribuci\u00f3n de prueba. Mientras tanto la compilaci\u00f3n seleccionada aparecer\u00e1 en estado Pendiente de revisi\u00f3n . Una vez aprobada la distribuci\u00f3n es posible crear un enlace para que cualquiera la pueda instalar y probar.","title":"A\u00f1adir probadores externos y enlace de prueba"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#testflight-en-los-usuarios","text":"Los usuarios de prueba reciben un correo avis\u00e1ndoles de que la beta est\u00e1 disponible. Deben instalar la app TestFlight y en la app aparecer\u00e1 un bot\u00f3n que permitir\u00e1 instalar la app en el dispositivo. En este caso no es necesario que el dispositivo est\u00e9 en la lista incluida en el perfil de aprovisionamiento, porque la app est\u00e1 autorizada por Apple para su ejecuci\u00f3n en cualquier dispositivo.","title":"TestFlight en los usuarios"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#nuevas-compilaciones","text":"Cuando subimos desde Xcode una nueva compilaci\u00f3n, debemos entrar en el enlace de la compilaci\u00f3n para activar la nueva prueba. TestFlight enviar\u00e1 una notificaci\u00f3n autom\u00e1ticamente a todos los usuarios para que descarguen la nueva versi\u00f3n.","title":"Nuevas compilaciones"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#practicas","text":"En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n lo que debes realizar: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA y firmar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Distribuir esta app firmada con el perfil de aprovisionamiento del equipo de la UA usando Fabric.","title":"Pr\u00e1cticas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#creacion-de-la-cuenta-de-desarrollador-apple","text":"Deber\u00e1s crear un Apple ID introduciendo tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Activa la autenticaci\u00f3n de doble factor de alguna de las formas definida en este enlace . Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . De esta forma est\u00e1s accediendo al programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help","title":"Creaci\u00f3n de la cuenta de desarrollador Apple"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-e-instalacion-de-una-app-en-un-dispositivo-de-desarrollo","text":"Descarga la app ToDoList . Incluye tu nombre en alguna parte de la interfaz de usuario. F\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Inst\u00e1lala en un dispositivo de desarrollo conectado a Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n.","title":"Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#configuracion-de-la-cuenta-de-desarrollador","text":"Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos y direcci\u00f3n de e-mail en este fichero Google Docs . Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n podemos entrar en el member center , comprobar que ya est\u00e1s en el programa y probar las distintas opciones disponibles.","title":"Configuraci\u00f3n de la cuenta de desarrollador"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#firma-y-despliegue-de-app-con-perfil-de-aprovisionamiento","text":"Debes seguir los pasos realizados en la demostraci\u00f3n con la app ToDoList . Nos damos de alta al equipo de la universidad. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba.","title":"Firma y despliegue de app con perfil de aprovisionamiento"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#distribucion-con-fabric","text":"Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos.","title":"Distribuci\u00f3n con Fabric"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#entregas","text":"Resumen de las pr\u00e1cticas a realizar en esta sesi\u00f3n y entregas a realizar en Moodle. Descarga la app ToDoList (o usa una app tuya que hayas desarrollado) y f\u00edrmala con tu cuenta gratuita de desarrollador Apple (no la del equipo de la UA). Modifica la app para que aparezca tu nombre en la interfaz de usuario. Inst\u00e1lala en un dispositivo de desarrollo de Xcode y prueba que funciona correctamente. Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Firma la app con tu cuenta del equipo de la UA, activa el servicio de Game Center e inst\u00e1lala en otro dispositivo del profesor que est\u00e9 dado de alta en el perfil de aprovisionamiento, pero que no sea el dispositivo de desarrollo de Xcode. Instala la app usando Apple Configurator 2 . Haz una foto y gu\u00e1rdala como documentaci\u00f3n. Distribuye la app al profesor ( domingo.gallardo@ua.es ) usando Fabric. Captura la pantalla de la web de fabric en la que se muestra que el profesor ha instalado la app. Crea una nueva versi\u00f3n de la app en la que el usuario pueda provocar un crash (consulta c\u00f3mo hacerlo en la documentaci\u00f3n de Crashlytics). Distrib\u00fayela al profesor y captura la pantalla en la que se muestra el n\u00famero de crashes producidos. Guarda las fotograf\u00edas y pantallas en una carpeta, junto con el binario .ipa de la actividad 2, comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 .","title":"Entregas"},{"location":"sesion01/sesion01-firma-aprovisionamiento.html#bibliografia","text":"Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Test Flight Documentaci\u00f3n de Fabric","title":"Bibliograf\u00eda"},{"location":"sesion02/sesion02-notificaciones.html","text":"Sesi\u00f3n 2: Notificaciones En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS. Introducci\u00f3n En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11. Apariencia de las notificaciones Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes Notificaciones ). D\u00f3nde aparecen las notificaciones Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla). Interacci\u00f3n en las notificaciones Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app. Notificaciones locales Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado. Notificaciones remotas Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido. Para qu\u00e9 se usan las notificaciones Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice. Notification service app extensions Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones. Ciclo de vida de la app Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps. API de notificaciones A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones UNUserNotificationCenter La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n. Notifications UI Framework Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications . Preparaci\u00f3n de las notificaciones Registro de los tipos de notificaci\u00f3n Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n. Obtener los ajustes definidos por el usuario El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func applicationWillEnterForeground ( _ application : UIApplication ) { print ( Voy a pedir los settigs ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( Alert enabled ) } else { print ( Alert not enabled ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( Badge enabled ) } else { print ( Badge not enabled ) }}) } Notificaciones locales Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado. Creaci\u00f3n de notificaciones La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? ) Contenido de la notificaci\u00f3n El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: 1 2 3 4 5 let content = UNMutableNotificationContent () content . title = Introduction to Notifications content . subtitle = Session 707 content . body = Woah! These new notifications look amazing! Don\u2019t you agree? content . badge = 1 Media attachments Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) - UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + .png let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( error + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: 1 2 3 4 5 6 if let attachment = UNNotificationAttachment . create ( identifier : prueba , image : UIImage ( named : gatito.png ) ! , options : nil ) { content . attachments = [ attachment ] } Condiciones de disparo de la notificaci\u00f3n Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. 1 2 // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: 1 2 3 4 let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. 1 2 3 4 5 let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : Headquarters ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false ) Creaci\u00f3n de la notificaci\u00f3n local Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: 1 2 3 4 5 6 7 8 9 10 11 let content = UNMutableNotificationContent () content . title = Introducci\u00f3n a Notificaciones content . body = Hablemos sobre notificaciones! content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = peticionEjemplo let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( Error \\( error ) )} Demo Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo. Ejemplo de app: Notificaciones Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones. Manejo de notificaciones Podemos hacer que nuestra app ejecute c\u00f3digo cuando llegue la notificaci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Se implementa con el protocolo UNUserNotificationCenterDelegate . Se suele hacer que el AppDelegate cumpla este protocolo y asignarlo al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:) Mostrar y recibir la notificaci\u00f3n con la app en primer plano En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida. Ejemplo de c\u00f3digo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { ... UNUserNotificationCenter . current (). delegate = self ... } func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificacion \\( notification ) ) // Recuperamos el mensaje en la notificaci\u00f3n let userInfo = notification . request . content . userInfo as ? Dictionary String , String if let s = userInfo ?[ Mensaje ] { print ( Mensaje: \\( s ) ) } else { print ( No he encontrado el mensaje \\n ) } // Mostramos la notificaci\u00f3n completionHandler ([. alert , . sound ]) } App en segundo plano Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local la app s\u00f3lo tiene forma de saber que se ha recibido la notificaci\u00f3n cuando el usuario la pulsa. Cuando el usuario pulsa en cualquier acci\u00f3n de la notificaci\u00f3n, la app pasa a primer plano (se ejecuta el m\u00e9todos applicationWillEnterForeground ) y se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . Si es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante). Acciones Se unifican las acciones y la conducta por defecto en la que el usuario pulsa la notificaci\u00f3n. Ambos casos se manejan con el mismo API. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto . Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction Ejemplo de c\u00f3digo 1 2 3 4 5 6 7 8 9 10 let action1 = UNNotificationAction ( identifier : acepto , title : Acepto , options : []) let action2 = UNNotificationAction ( identifier : otro , title : Otro d\u00eda , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : mensaje , title : Mensaje , options : [], textInputButtonTitle : Enviar , textInputPlaceholder : Comentario ) let category = UNNotificationCategory ( identifier : invitacion , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Las acciones a\u00f1aden a una notificaci\u00f3n actualizando el categoryIdentifier con el identificador apropiado: 1 content . categoryIdentifier = invitacion Aspecto Recepci\u00f3n de la acci\u00f3n La funci\u00f3n userNotificationCenter(_:didReceive:withCompletionHandler:) del protocolo UNUserNotificationCenterDelegate es a la que se llama cuando el usuario pulsa en la opci\u00f3n o en la propia notificaci\u00f3n. Ejemplo (definido en la clase AppDelegate ): 1 2 3 4 5 6 7 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { // Obtener la acci\u00f3n y, en su caso, el texto introducido // a partir del objeto response completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier . Demo Probamos el c\u00f3digo anterior para incluir acciones en la notificaci\u00f3n. Notificaciones remotas ( push ) Objetivo de las notificaciones remotas La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ). Arquitectura de las notificaciones remotas Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos. Arquitectura de seguridad No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs. Secuencia de registro del dispositivo Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs. Token del dispositivo Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo. Env\u00edo de notificaci\u00f3n remota usando el token Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado. Contenido de la notificaci\u00f3n Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple Si se utiliza el API HTTP/2 el tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes. Debe tener el formato de un objeto JSON diccionario (parejas clave, valor). 1 2 3 4 5 6 7 8 9 10 11 { aps : { alert : { title : Introducci\u00f3n a las notificaciones , subtitle : Sesi\u00f3n 707 , body : La nueva API de notificaciones es genial!!! , category : mensaje , }, badge : 1 }, } Contenido de la notificaci\u00f3n (2) El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: Mensaje de alerta a mostrar al usuario Numero a a\u00f1adir en el globo del icono de la app Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. El usuario no recibir\u00e1 ninguna notificaci\u00f3n, pero ver\u00e1 el nuevo contenido la siguiente vez que abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app. Otros ejemplos de payload 1 2 3 4 5 6 7 8 9 { aps : { alert : You got your emails. , badge : 9 , sound : bingbong.aiff }, acme1 : bar , acme2 : 42 } 1 2 3 4 5 6 7 8 9 10 { aps : { alert : { loc-key : GAME_PLAY_REQUEST_FORMAT , loc-args : [ Jenna , Frank ] }, sound : chime.aiff }, acme : foo } Otros ejemplos de payload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { aps : { alert\u201d : { \u201cbody\u201d : Acme message received from Johnny Appleseed\u201d , \u201caction-loc-key\u201d : \u201cVIEW\u201d, actions : [ { \u201cid : \u201cdelete , title : Delete }, { \u201cid : \u201creply-to\u201d, loc-key : \u201cREPLYTO\u201d, loc-args : [\u201cJane ] } ] } badge : 3 , sound : \u201cchime.aiff }, acme-account : jane.appleseed@apple.com , acme-message : message 123456 } Servidores proveedores Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida en la documentaci\u00f3n de Apple . Esta API usa el protocolo HTTP/2 desde diciembre de 2015. La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Otras alternativas, como Parse , que utilizamos en alg\u00fan curso pasado, han ido desapareciendo o han ido cambiando de configuraci\u00f3n. Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal. Demo Pasos necesarios para la demo En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP. Para configurar el script PHP necesitamos: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Para ello necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push. Nuevo App ID en el member center (1) Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n. Nuevo App ID en el member center (2) Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push. Creaci\u00f3n del certificado SSL en el member center (1) Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros Asistente de Certificados Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest . Creaci\u00f3n del certificado SSL en el member center (2) Creaci\u00f3n del certificado SSL en el member center (3) Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest Creaci\u00f3n del perfil de aprovisionamiento Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo. Generaci\u00f3n del fichero .pem (1) Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros, lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs. Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles18) Generaci\u00f3n del fichero .pem (2) Creamos el fichero .pem con el siguiente comando: 1 2 $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Podremos usarlo para enviar la notificaci\u00f3n push al APNs con un script PHP. Obtenci\u00f3n del token del dispositivo Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo. Para ello hemos incluido en la app el c\u00f3digo que imprime el token en la consola una vez recibido del APNs. Repasemos el c\u00f3digo y la configuraci\u00f3n de la app NotificacionesPush . Registro de las notificaciones Igual que con las notificaciones locales, en application(application:didFinishLaunchingWithOptions) se realiza el registro de las notificaciones: 1 2 3 4 5 6 7 8 9 10 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // ... let notificationSettings = UIUserNotificationSettings ( types : [. badge , . sound , . alert ], categories : nil ) application . registerUserNotificationSettings ( notificationSettings ) // ... } Obtenci\u00f3n del token del dispositivo (1) El m\u00e9todo registerForRemoteNotifications es el que se encarga de establecer al conexi\u00f3n con el APNs y solicitar el token de conexi\u00f3n. Se le invoca en el manejador didRegisterUserNotificationSettings al que se llama cuando el usuario ha aceptado recibir notificaciones. 1 2 3 4 5 6 func application ( _ application : UIApplication , didRegister notificationSettings : UIUserNotificationSettings ) { if notificationSettings . types != . none { application . registerForRemoteNotifications () } } Obtenci\u00f3n del token del dispositivo (2) Cuando la app se registra en el APNs, \u00e9ste env\u00eda un token (cadena hexadecimal) que identifica el dispositivo. Se recibe en el siguiente manejador, que lo imprime por la salida est\u00e1ndar. 1 2 3 4 5 6 7 8 9 10 11 12 13 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( Failed to register: , error ) } Probamos la app NotificacionesPush Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs. Ejecuci\u00f3n de NotificacionesPush en un dispositivo La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador. Probamos a enviar notificaciones remotas al dispositivo Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: 1 2 3 $ php apnspush.php Hola mundo desde la UA Connected to APNS Message successfully delivered Recepci\u00f3n de las notificaciones en la app Vamos a ver ahora c\u00f3mo se reciben las notificaciones en la app. La programaci\u00f3n es similar a la ya vista en notificaciones locales, con algunas diferencias: Registro de las notificaciones para solicitar permiso al usuario. Definici\u00f3n de manejadores que se lanzan cuando el usuario pulsa en una notificaci\u00f3n. Nuevo : Registro de la app para notificaciones remotas. Nuevo : Definici\u00f3n de manejador que se lanza cuando llega el token del APNs. Nuevo : Definici\u00f3n de manejador que se lanza cuando llega la notificaci\u00f3n remota. Registro de la app para notificaciones remotas Se debe llamar al m\u00e9todo registerForRemoteNotifications() en el objeto compartido application : 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } La primera vez que la app llama a este m\u00e9todo, contacta con el APNs y solicita el token de dispositivo, que se utilizar\u00e1 como identificador al que enviar las notificaciones remotas. Recepci\u00f3n del token de dispositivo El sistema llama de forma as\u00edncrona a uno de los dos m\u00e9todos siguientes del delegado del app, dependiendo de si ha habido \u00e9xito o no en la obtenci\u00f3n del token: Si ha habido \u00e9xito en la generaci\u00f3n del token el sistema llama al m\u00e9todo application:didRegisterForRemoteNotificationsWithDeviceToken: . En este m\u00e9todo se debe implementar el env\u00edo del token a nuestro servicio de env\u00edo de notificaciones push. 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } Si ha habido error, el sistema llama al m\u00e9todo application:didFailToRegisterForRemoteNotificationsWithError: . App en background Cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 el sistema llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app. El m\u00e9todo se ejecuta estando la app en segundo plano y se utiliza para recuperar informaci\u00f3n del servidor (puede ir en la notificaci\u00f3n o puede la app conectarse al servicio): 1 2 3 4 5 6 7 8 9 func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) - Void ) { print ( Recibida notificaci\u00f3n remota en background ) // Obtenemos la informaci\u00f3n de la notifiaci\u00f3n y actualizamos la app let aps = userInfo [ aps ] as ! [ String : AnyObject ] createNewNewsItem ( aps ) completionHandler ( UIBackgroundFetchResult . newData ) } Para que se llame al m\u00e9todo se debe activar la capability Background Modes Remote Notifications Acciones del usuario sobre la notificaci\u00f3n Una vez recibida, la notificaci\u00f3n funciona igual que una notificaci\u00f3n local: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate . Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . App en primer plano 1 2 3 4 5 6 7 8 9 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificaci\u00f3n primer plano ) let aps = notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] createNewNewsItem ( aps ) // No mostramos la notificaci\u00f3n completionHandler ([]) } Notificaci\u00f3n pulsada por el usuario 1 2 3 4 5 6 7 8 9 10 11 12 13 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { print ( Usuario ha pulsado una notificaci\u00f3n ) let aps = response . notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let contentAvailable = aps [ content-available ] as ? Int , contentAvailable == 1 { print ( Ya se ha actualizado la noticia al ser un background update ) } else { createNewNewsItem ( aps ) } completionHandler () } Pr\u00e1ctica Descarga las apps Notificaciones y NotificacionesPush . Examina su c\u00f3digo y pru\u00e9balas. Ejercicio 1 (5 puntos): Modifica la app ToDoList (o alguna app tuya con la que est\u00e9s trabajando) para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2 (2,5 puntos): Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3 (2,5 puntos): A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n remota. Utiliza el script PHP y el certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas. Referencias Local and Remote Programming Guide UserNotifications Framework Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Notificaciones Push"},{"location":"sesion02/sesion02-notificaciones.html#sesion-2-notificaciones","text":"En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS.","title":"Sesi\u00f3n 2: Notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#introduccion","text":"En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11.","title":"Introducci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#apariencia-de-las-notificaciones","text":"Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes Notificaciones ).","title":"Apariencia de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#donde-aparecen-las-notificaciones","text":"Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla).","title":"D\u00f3nde aparecen las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#interaccion-en-las-notificaciones","text":"Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app.","title":"Interacci\u00f3n en las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-locales","text":"Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado.","title":"Notificaciones locales"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-remotas","text":"Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido.","title":"Notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#para-que-se-usan-las-notificaciones","text":"Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice.","title":"Para qu\u00e9 se usan las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#notification-service-app-extensions","text":"Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones.","title":"Notification service app extensions"},{"location":"sesion02/sesion02-notificaciones.html#ciclo-de-vida-de-la-app","text":"Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps.","title":"Ciclo de vida de la app"},{"location":"sesion02/sesion02-notificaciones.html#api-de-notificaciones","text":"A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones","title":"API de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#unusernotificationcenter","text":"La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n.","title":"UNUserNotificationCenter"},{"location":"sesion02/sesion02-notificaciones.html#notifications-ui-framework","text":"Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications .","title":"Notifications UI Framework"},{"location":"sesion02/sesion02-notificaciones.html#preparacion-de-las-notificaciones","text":"","title":"Preparaci\u00f3n de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#registro-de-los-tipos-de-notificacion","text":"Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n.","title":"Registro de los tipos de notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#obtener-los-ajustes-definidos-por-el-usuario","text":"El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func applicationWillEnterForeground ( _ application : UIApplication ) { print ( Voy a pedir los settigs ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( Alert enabled ) } else { print ( Alert not enabled ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( Badge enabled ) } else { print ( Badge not enabled ) }}) }","title":"Obtener los ajustes definidos por el usuario"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-locales_1","text":"Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado.","title":"Notificaciones locales"},{"location":"sesion02/sesion02-notificaciones.html#creacion-de-notificaciones","text":"La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? )","title":"Creaci\u00f3n de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#contenido-de-la-notificacion","text":"El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: 1 2 3 4 5 let content = UNMutableNotificationContent () content . title = Introduction to Notifications content . subtitle = Session 707 content . body = Woah! These new notifications look amazing! Don\u2019t you agree? content . badge = 1","title":"Contenido de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#media-attachments","text":"Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) - UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + .png let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( error + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: 1 2 3 4 5 6 if let attachment = UNNotificationAttachment . create ( identifier : prueba , image : UIImage ( named : gatito.png ) ! , options : nil ) { content . attachments = [ attachment ] }","title":"Media attachments"},{"location":"sesion02/sesion02-notificaciones.html#condiciones-de-disparo-de-la-notificacion","text":"Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. 1 2 // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: 1 2 3 4 let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. 1 2 3 4 5 let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : Headquarters ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false )","title":"Condiciones de disparo de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#creacion-de-la-notificacion-local","text":"Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: 1 2 3 4 5 6 7 8 9 10 11 let content = UNMutableNotificationContent () content . title = Introducci\u00f3n a Notificaciones content . body = Hablemos sobre notificaciones! content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = peticionEjemplo let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( Error \\( error ) )}","title":"Creaci\u00f3n de la notificaci\u00f3n local"},{"location":"sesion02/sesion02-notificaciones.html#demo","text":"Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo.","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-app-notificaciones","text":"Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones.","title":"Ejemplo de app: Notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#manejo-de-notificaciones","text":"Podemos hacer que nuestra app ejecute c\u00f3digo cuando llegue la notificaci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Se implementa con el protocolo UNUserNotificationCenterDelegate . Se suele hacer que el AppDelegate cumpla este protocolo y asignarlo al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:)","title":"Manejo de notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#mostrar-y-recibir-la-notificacion-con-la-app-en-primer-plano","text":"En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida.","title":"Mostrar y recibir la notificaci\u00f3n con la app en primer plano"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-codigo","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { ... UNUserNotificationCenter . current (). delegate = self ... } func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificacion \\( notification ) ) // Recuperamos el mensaje en la notificaci\u00f3n let userInfo = notification . request . content . userInfo as ? Dictionary String , String if let s = userInfo ?[ Mensaje ] { print ( Mensaje: \\( s ) ) } else { print ( No he encontrado el mensaje \\n ) } // Mostramos la notificaci\u00f3n completionHandler ([. alert , . sound ]) }","title":"Ejemplo de c\u00f3digo"},{"location":"sesion02/sesion02-notificaciones.html#app-en-segundo-plano","text":"Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local la app s\u00f3lo tiene forma de saber que se ha recibido la notificaci\u00f3n cuando el usuario la pulsa. Cuando el usuario pulsa en cualquier acci\u00f3n de la notificaci\u00f3n, la app pasa a primer plano (se ejecuta el m\u00e9todos applicationWillEnterForeground ) y se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . Si es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante).","title":"App en segundo plano"},{"location":"sesion02/sesion02-notificaciones.html#acciones","text":"Se unifican las acciones y la conducta por defecto en la que el usuario pulsa la notificaci\u00f3n. Ambos casos se manejan con el mismo API. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto . Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction","title":"Acciones"},{"location":"sesion02/sesion02-notificaciones.html#ejemplo-de-codigo_1","text":"1 2 3 4 5 6 7 8 9 10 let action1 = UNNotificationAction ( identifier : acepto , title : Acepto , options : []) let action2 = UNNotificationAction ( identifier : otro , title : Otro d\u00eda , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : mensaje , title : Mensaje , options : [], textInputButtonTitle : Enviar , textInputPlaceholder : Comentario ) let category = UNNotificationCategory ( identifier : invitacion , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Las acciones a\u00f1aden a una notificaci\u00f3n actualizando el categoryIdentifier con el identificador apropiado: 1 content . categoryIdentifier = invitacion","title":"Ejemplo de c\u00f3digo"},{"location":"sesion02/sesion02-notificaciones.html#aspecto","text":"","title":"Aspecto"},{"location":"sesion02/sesion02-notificaciones.html#recepcion-de-la-accion","text":"La funci\u00f3n userNotificationCenter(_:didReceive:withCompletionHandler:) del protocolo UNUserNotificationCenterDelegate es a la que se llama cuando el usuario pulsa en la opci\u00f3n o en la propia notificaci\u00f3n. Ejemplo (definido en la clase AppDelegate ): 1 2 3 4 5 6 7 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { // Obtener la acci\u00f3n y, en su caso, el texto introducido // a partir del objeto response completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier .","title":"Recepci\u00f3n de la acci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#demo_1","text":"Probamos el c\u00f3digo anterior para incluir acciones en la notificaci\u00f3n.","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#notificaciones-remotas-push","text":"","title":"Notificaciones remotas (push)"},{"location":"sesion02/sesion02-notificaciones.html#objetivo-de-las-notificaciones-remotas","text":"La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ).","title":"Objetivo de las notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#arquitectura-de-las-notificaciones-remotas","text":"Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos.","title":"Arquitectura de las notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#arquitectura-de-seguridad","text":"No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs.","title":"Arquitectura de seguridad"},{"location":"sesion02/sesion02-notificaciones.html#secuencia-de-registro-del-dispositivo","text":"Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs.","title":"Secuencia de registro del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#token-del-dispositivo","text":"Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo.","title":"Token del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#envio-de-notificacion-remota-usando-el-token","text":"Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado.","title":"Env\u00edo de notificaci\u00f3n remota usando el token"},{"location":"sesion02/sesion02-notificaciones.html#contenido-de-la-notificacion_1","text":"Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple Si se utiliza el API HTTP/2 el tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes. Debe tener el formato de un objeto JSON diccionario (parejas clave, valor). 1 2 3 4 5 6 7 8 9 10 11 { aps : { alert : { title : Introducci\u00f3n a las notificaciones , subtitle : Sesi\u00f3n 707 , body : La nueva API de notificaciones es genial!!! , category : mensaje , }, badge : 1 }, }","title":"Contenido de la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#contenido-de-la-notificacion-2","text":"El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: Mensaje de alerta a mostrar al usuario Numero a a\u00f1adir en el globo del icono de la app Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. El usuario no recibir\u00e1 ninguna notificaci\u00f3n, pero ver\u00e1 el nuevo contenido la siguiente vez que abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app.","title":"Contenido de la notificaci\u00f3n (2)"},{"location":"sesion02/sesion02-notificaciones.html#otros-ejemplos-de-payload","text":"1 2 3 4 5 6 7 8 9 { aps : { alert : You got your emails. , badge : 9 , sound : bingbong.aiff }, acme1 : bar , acme2 : 42 } 1 2 3 4 5 6 7 8 9 10 { aps : { alert : { loc-key : GAME_PLAY_REQUEST_FORMAT , loc-args : [ Jenna , Frank ] }, sound : chime.aiff }, acme : foo }","title":"Otros ejemplos de payload"},{"location":"sesion02/sesion02-notificaciones.html#otros-ejemplos-de-payload_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { aps : { alert\u201d : { \u201cbody\u201d : Acme message received from Johnny Appleseed\u201d , \u201caction-loc-key\u201d : \u201cVIEW\u201d, actions : [ { \u201cid : \u201cdelete , title : Delete }, { \u201cid : \u201creply-to\u201d, loc-key : \u201cREPLYTO\u201d, loc-args : [\u201cJane ] } ] } badge : 3 , sound : \u201cchime.aiff }, acme-account : jane.appleseed@apple.com , acme-message : message 123456 }","title":"Otros ejemplos de payload"},{"location":"sesion02/sesion02-notificaciones.html#servidores-proveedores","text":"Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida en la documentaci\u00f3n de Apple . Esta API usa el protocolo HTTP/2 desde diciembre de 2015. La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Otras alternativas, como Parse , que utilizamos en alg\u00fan curso pasado, han ido desapareciendo o han ido cambiando de configuraci\u00f3n. Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal.","title":"Servidores proveedores"},{"location":"sesion02/sesion02-notificaciones.html#demo_2","text":"","title":"Demo"},{"location":"sesion02/sesion02-notificaciones.html#pasos-necesarios-para-la-demo","text":"En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP. Para configurar el script PHP necesitamos: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Para ello necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push.","title":"Pasos necesarios para la demo"},{"location":"sesion02/sesion02-notificaciones.html#nuevo-app-id-en-el-member-center-1","text":"Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n.","title":"Nuevo App ID en el member center (1)"},{"location":"sesion02/sesion02-notificaciones.html#nuevo-app-id-en-el-member-center-2","text":"Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push.","title":"Nuevo App ID en el member center (2)"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-certificado-ssl-en-el-member-center-1","text":"Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros Asistente de Certificados Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest .","title":"Creaci\u00f3n del certificado SSL en el member center (1)"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-certificado-ssl-en-el-member-center-2","text":"","title":"Creaci\u00f3n del certificado SSL en el member center (2)"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-certificado-ssl-en-el-member-center-3","text":"Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest","title":"Creaci\u00f3n del certificado SSL en el member center (3)"},{"location":"sesion02/sesion02-notificaciones.html#creacion-del-perfil-de-aprovisionamiento","text":"Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"sesion02/sesion02-notificaciones.html#generacion-del-fichero-pem-1","text":"Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros, lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs. Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles18)","title":"Generaci\u00f3n del fichero .pem (1)"},{"location":"sesion02/sesion02-notificaciones.html#generacion-del-fichero-pem-2","text":"Creamos el fichero .pem con el siguiente comando: 1 2 $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Podremos usarlo para enviar la notificaci\u00f3n push al APNs con un script PHP.","title":"Generaci\u00f3n del fichero .pem (2)"},{"location":"sesion02/sesion02-notificaciones.html#obtencion-del-token-del-dispositivo","text":"Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo. Para ello hemos incluido en la app el c\u00f3digo que imprime el token en la consola una vez recibido del APNs. Repasemos el c\u00f3digo y la configuraci\u00f3n de la app NotificacionesPush .","title":"Obtenci\u00f3n del token del dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#registro-de-las-notificaciones","text":"Igual que con las notificaciones locales, en application(application:didFinishLaunchingWithOptions) se realiza el registro de las notificaciones: 1 2 3 4 5 6 7 8 9 10 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // ... let notificationSettings = UIUserNotificationSettings ( types : [. badge , . sound , . alert ], categories : nil ) application . registerUserNotificationSettings ( notificationSettings ) // ... }","title":"Registro de las notificaciones"},{"location":"sesion02/sesion02-notificaciones.html#obtencion-del-token-del-dispositivo-1","text":"El m\u00e9todo registerForRemoteNotifications es el que se encarga de establecer al conexi\u00f3n con el APNs y solicitar el token de conexi\u00f3n. Se le invoca en el manejador didRegisterUserNotificationSettings al que se llama cuando el usuario ha aceptado recibir notificaciones. 1 2 3 4 5 6 func application ( _ application : UIApplication , didRegister notificationSettings : UIUserNotificationSettings ) { if notificationSettings . types != . none { application . registerForRemoteNotifications () } }","title":"Obtenci\u00f3n del token del dispositivo (1)"},{"location":"sesion02/sesion02-notificaciones.html#obtencion-del-token-del-dispositivo-2","text":"Cuando la app se registra en el APNs, \u00e9ste env\u00eda un token (cadena hexadecimal) que identifica el dispositivo. Se recibe en el siguiente manejador, que lo imprime por la salida est\u00e1ndar. 1 2 3 4 5 6 7 8 9 10 11 12 13 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( Failed to register: , error ) }","title":"Obtenci\u00f3n del token del dispositivo (2)"},{"location":"sesion02/sesion02-notificaciones.html#probamos-la-app-notificacionespush","text":"Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs.","title":"Probamos la app NotificacionesPush"},{"location":"sesion02/sesion02-notificaciones.html#ejecucion-de-notificacionespush-en-un-dispositivo","text":"La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador.","title":"Ejecuci\u00f3n de NotificacionesPush en un dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#probamos-a-enviar-notificaciones-remotas-al-dispositivo","text":"Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: 1 2 3 $ php apnspush.php Hola mundo desde la UA Connected to APNS Message successfully delivered","title":"Probamos a enviar notificaciones remotas al dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#recepcion-de-las-notificaciones-en-la-app","text":"Vamos a ver ahora c\u00f3mo se reciben las notificaciones en la app. La programaci\u00f3n es similar a la ya vista en notificaciones locales, con algunas diferencias: Registro de las notificaciones para solicitar permiso al usuario. Definici\u00f3n de manejadores que se lanzan cuando el usuario pulsa en una notificaci\u00f3n. Nuevo : Registro de la app para notificaciones remotas. Nuevo : Definici\u00f3n de manejador que se lanza cuando llega el token del APNs. Nuevo : Definici\u00f3n de manejador que se lanza cuando llega la notificaci\u00f3n remota.","title":"Recepci\u00f3n de las notificaciones en la app"},{"location":"sesion02/sesion02-notificaciones.html#registro-de-la-app-para-notificaciones-remotas","text":"Se debe llamar al m\u00e9todo registerForRemoteNotifications() en el objeto compartido application : 1 2 3 4 5 6 7 8 func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) - Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } La primera vez que la app llama a este m\u00e9todo, contacta con el APNs y solicita el token de dispositivo, que se utilizar\u00e1 como identificador al que enviar las notificaciones remotas.","title":"Registro de la app para notificaciones remotas"},{"location":"sesion02/sesion02-notificaciones.html#recepcion-del-token-de-dispositivo","text":"El sistema llama de forma as\u00edncrona a uno de los dos m\u00e9todos siguientes del delegado del app, dependiendo de si ha habido \u00e9xito o no en la obtenci\u00f3n del token: Si ha habido \u00e9xito en la generaci\u00f3n del token el sistema llama al m\u00e9todo application:didRegisterForRemoteNotificationsWithDeviceToken: . En este m\u00e9todo se debe implementar el env\u00edo del token a nuestro servicio de env\u00edo de notificaciones push. 1 2 3 4 5 6 7 func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = for i in 0. . deviceToken . count { token = token + String ( format : %02.2hhx , arguments : [ deviceToken [ i ]]) } print ( token ) } Si ha habido error, el sistema llama al m\u00e9todo application:didFailToRegisterForRemoteNotificationsWithError: .","title":"Recepci\u00f3n del token de dispositivo"},{"location":"sesion02/sesion02-notificaciones.html#app-en-background","text":"Cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 el sistema llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app. El m\u00e9todo se ejecuta estando la app en segundo plano y se utiliza para recuperar informaci\u00f3n del servidor (puede ir en la notificaci\u00f3n o puede la app conectarse al servicio): 1 2 3 4 5 6 7 8 9 func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) - Void ) { print ( Recibida notificaci\u00f3n remota en background ) // Obtenemos la informaci\u00f3n de la notifiaci\u00f3n y actualizamos la app let aps = userInfo [ aps ] as ! [ String : AnyObject ] createNewNewsItem ( aps ) completionHandler ( UIBackgroundFetchResult . newData ) } Para que se llame al m\u00e9todo se debe activar la capability Background Modes Remote Notifications","title":"App en background"},{"location":"sesion02/sesion02-notificaciones.html#acciones-del-usuario-sobre-la-notificacion","text":"Una vez recibida, la notificaci\u00f3n funciona igual que una notificaci\u00f3n local: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate . Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate .","title":"Acciones del usuario sobre la notificaci\u00f3n"},{"location":"sesion02/sesion02-notificaciones.html#app-en-primer-plano","text":"1 2 3 4 5 6 7 8 9 func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) - Void ) { print ( Recibida notificaci\u00f3n primer plano ) let aps = notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] createNewNewsItem ( aps ) // No mostramos la notificaci\u00f3n completionHandler ([]) }","title":"App en primer plano"},{"location":"sesion02/sesion02-notificaciones.html#notificacion-pulsada-por-el-usuario","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () - Void ) { print ( Usuario ha pulsado una notificaci\u00f3n ) let aps = response . notification . request . content . userInfo [ aps ] as ! [ String : AnyObject ] if let contentAvailable = aps [ content-available ] as ? Int , contentAvailable == 1 { print ( Ya se ha actualizado la noticia al ser un background update ) } else { createNewNewsItem ( aps ) } completionHandler () }","title":"Notificaci\u00f3n pulsada por el usuario"},{"location":"sesion02/sesion02-notificaciones.html#practica","text":"Descarga las apps Notificaciones y NotificacionesPush . Examina su c\u00f3digo y pru\u00e9balas. Ejercicio 1 (5 puntos): Modifica la app ToDoList (o alguna app tuya con la que est\u00e9s trabajando) para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2 (2,5 puntos): Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3 (2,5 puntos): A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n remota. Utiliza el script PHP y el certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas.","title":"Pr\u00e1ctica"},{"location":"sesion02/sesion02-notificaciones.html#referencias","text":"Local and Remote Programming Guide UserNotifications Framework","title":"Referencias"},{"location":"sesion02/sesion02-notificaciones.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"},{"location":"sesion03/sesion03-icloud.html","text":"Sesi\u00f3n 3: iCloud y CloudKit Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 iCloud iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros. Filosof\u00eda de iCloud (para el usuario de iOS) La idea principal tras iCloud es eliminar la sincronizaci\u00f3n expl\u00edcita entre dispositivos. Un usuario nunca necesita pensar sobre la sincronizaci\u00f3n, y la app nunca interact\u00faa directamente con los servidores de iCloud. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud. Para el desarrollador, depende del API de iCloud que se utilice estos cambios son m\u00e1s o menos autom\u00e1ticos. Cuenta iCloud Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID Permite identificarse y mantenerse logeado en el dispositivo Puede activarse desde un Mac, desde un dispositivo iOS, desde la web o desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos . Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos: Recordatorios, Notas, ... El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. Distintas APIs Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit (a partir de iOS 8): nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en registros con diccionarios clave-valor, enfoque muy similar a las tecnolog\u00edas NoSQL. API de transporte que no mantiene un estado local. Basada en peticiones y respuestas as\u00edncronas. Preparaci\u00f3n de aprovisionamiento y permisos para iCloud Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo automaticamente desde XCode. Puedes utilizar el perfil de aprovisionamiento UA ToDoListCloudKit Profile creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.ToDoListCloudKit . Creaci\u00f3n del App ID Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Creamos el permiso (App ID) Master Moviles ToDoListCloudKit que incluye la capacidad de iCloud. Confirmaci\u00f3n del App ID La activaci\u00f3n del permiso de iCloud aparecer\u00e1 en amarillo porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). API de almacenamiento clave-valor Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para acceder a los valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: 1 let iCloudStore = NSUbiquitousKeyValueStore . default M\u00e9todo synchronize 1 func synchronize () - Bool - Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. - Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. - Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. - No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. - Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano. Ejemplo de uso de synchronize al lanzar la app 1 2 3 4 5 6 7 8 9 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { let store = NSUbiquitousKeyValueStore . default if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } return true } Guardar valores en el almac\u00e9n de claves-valor Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: 1 store . set ( Int64 ( 100 ), forKey : puntuacion ) Obtenci\u00f3n de valores del almac\u00e9n de claves-valor Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) bool(forKey: String) dictionary(forKey: String) string(forKey: String) ... Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: 1 let puntuacion = Int ( store . longLong ( forKey : puntuacion )) Par\u00e1metros y resultados del m\u00e9todo: forKey : un String que es la clave en el almac\u00e9n de claves-valor. Devuelve: el valor asociado a la clave o 0 si la clave no existe o no contiene un valor num\u00e9rico Definiendo un observador de cambios Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado. Ejemplo de definici\u00f3n de un observador de la notificaci\u00f3n Registramos una clausura para la notificaci\u00f3n con el nombre NSUbiquitousKeyValueStore.didChangeExternallyNotification en el momento de lanzar la app, y llamamos al m\u00e9todo synchronize() para obtener las parejas de claves-valor m\u00e1s recientes. 1 2 3 4 5 6 7 8 9 10 11 12 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { NotificationCenter . default . addObserver ( forName : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : NSUbiquitousKeyValueStore . default (), queue : OperationQueue . main ) { ( notification ) in let ubiquitousKeyValueStore = notification . object as ! NSUbiquitousKeyValueStore ubiquitousKeyValueStore . synchronize () } } Pr\u00e1ctica: ToDoList con iCloud clave-valor (2) Debes modificar la aplicaci\u00f3n para que se guarden en el almac\u00e9n clave-valor de iCloud del usuario: N\u00famero de tareas terminadas \u00daltima tarea terminada Debes usar la app en el simulador habi\u00e9ndote logeado en iCloud en el propio simulador. Prueba a ejecutar distintas veces la app desde el simulador, incluso a eliminar la aplicaci\u00f3n y volver a instalarla. Deber\u00eda conservarse el n\u00famero de tareas terminadas y el nombre de la \u00faltima. Se borrar\u00e1n las tareas pendientes (las guardaremos en CloudKit en la sesi\u00f3n siguiente). Muestra los datos guardados con una alerta al arrancar la app. CloudKit Introducci\u00f3n a CloudKit CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Acceso a servidores de iCloud. Usa las cuentas iCloud de los usuarios. Bases de datos p\u00fablicas (de la app) y privadas (de cada usuario). Permite datos estructurados y datos bulk . Tecnolog\u00eda de transporte, no proporciona base de datos local. CloudKit trabaja sobre registros en iCloud CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. CloudKit trabaja sobre registros , diccionarios de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros. Registros p\u00fablicos y privados Se pueden guardar registros de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los registros p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los registros privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar registros en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro. Tecnolog\u00eda de transporte CloudKit no proporciona ninguna forma de almacenar datos localmente. Es un servicio para mover datos a y desde iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para iCloud y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen. Elementos de CloudKit Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias Assets Contenedores M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Puedes compartir un contenedor entre varias apps . Existe un contenedor por defecto para cada app, pero puedes crear contenedores adicionales. El identificador por defecto se llama igual que el bundle ID de la app. Los contenedores adicionales deben tener un nombre \u00fanico entre todas las apps de los desarrolladores. Los contenedores no pueden borrarse. Gesti\u00f3n en el member center Una de las opciones del member center permite gestionar contenedores de iCloud. Creamos uno con el identificador iCloud.ua.mastermoviles.ToDoListCloudKit que utilizaremos en la app ToDoList . No es posible borrar contenedores. Asignaci\u00f3n del container al App ID Incluimos en el App ID el contenedor de iCloud anterior. Creaci\u00f3n del perfil de aprovisionamiento Creamos el perfil de aprovisionamiento UA ToDoListCloudKit Profile con el App ID anterior. Actualizaci\u00f3n de capacidades de la app ToDoListCloudKit Dashboard Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. https://icloud.developer.apple.com/dashboard/ Permite: Crear, visualizar, editar y borrar esquemas, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue Dashboard: permisos Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud. Dashboard: tipos de registros Dashboard: logs Clase CKContainer La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta. Caracter\u00edsticas sociales de CloudKit CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente. Caracter\u00edsticas sociales de CloudKit Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente. Ejemplo de c\u00f3digo de caracter\u00edsticas sociales 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let container = CKContainer . default () print ( Container: ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( Permiso concedido: + \\( permissionStatus == CKApplicationPermissionStatus . granted ) )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }}) Bases de datos Bases de datos Bases de datos Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : 1 2 3 let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase Bases de datos Registros Creaci\u00f3n de registros Se definen con la clase CKRecord . Conjunto de parejas clave y valor con un identificador \u00fanico de la clase. CKRecordID Se crean en tiempo de ejecuci\u00f3n indicando un tipo de registro definido por un String . 1 let tareaRecord = CKRecord ( recordType : Artista ) Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): 1 2 3 4 5 6 let nombre = Jonhn Lennon tareaRecord[ artista ] = nombre as NSString let formatter = DateFormatter() formatter.dateFormat = yyyy/MM/dd let fecha = formatter.date(from: 1940/10/09 ) tareaRecord[ fechanacimiento ] = fecha! as NSDate Datos en los registros El protocolo CKRecordValue define los posibles valores que pueden haber en los atributos de los registros: NSString : Cadenas NSNumber : N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior Grabaci\u00f3n de registros Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). 1 2 3 4 privateDB . save ( tareaRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) - Void in print ( Registro: \\( record ) ) print ( Error: \\( error ) )}) Relaciones entre registros: referencias Referencias Clase CKReference El servidor entiende las relaciones Padre Hijo Borrados en cascada Cuidado con los problemas de integridad, ser\u00e1 normal que no existan referencias Se prefieren las referencias hacia atr\u00e1s para modelar las relaciones anteriores Queries Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation . Ejemplo Query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual 1 2 3 4 5 6 7 8 9 10 11 12 13 let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( value : true )) let container = CKContainer . default () let privateDB = container . privateCloudDatabase privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in for result in results ! { if let nombre = result [ nombre ] { print ( Tarea: \\( nombre ) ) let toDoItem = ToDoItem ( nombre : nombre as ! String ) self . toDoItems . append ( toDoItem ) } } }) Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) 1 2 let predicate = NSPredicate ( format : nombre BEGINSWITH Limpiar ) let predicate = NSPredicate ( format : favoriteColors CONTAINS red ) Operaciones con registros obtenidos Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func deleteTarea ( _ nombre : String ) { let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( format : nombre == %@ , argumentArray : [ nombre ])) let container = CKContainer . default () let privateDB = container . privateCloudDatabase privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord privateDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( Error: \\( error ) ) }) } } }) } Suscripciones Posibilidad de hacer consultas \"permanentes\" Ejecutadas en background por el servidor tras cada registro salvado Generan notificaciones push con los resultados CloudKit JS CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) En 2016 Apple ha lanzado un servicio web para acceder a CloudKit usando peticiones REST. Pr\u00e1ctica: ToDoList con iCloud clave-valor (1) Preparaci\u00f3n previa Copia la carpeta ToDoList y ren\u00f3mbrala a ToDoList CloudKit . Elimina las referencias a Fabric y Crashlytics El bundle ID de la app debe ser es.ua.mastermoviles.ToDoListCloudKit y utilizar el perfil de aprovisionamiento UA ToDoListCloudKit Profile . Activa la capability de iCloud clave-valor. Pr\u00e1ctica: ToDoList con iCloud clave-valor (2) Debes modificar la aplicaci\u00f3n para que se guarden en el almac\u00e9n clave-valor de iCloud del usuario: N\u00famero de tareas terminadas \u00daltima tarea terminada Debes usar la app en el simulador habi\u00e9ndote logeado en iCloud en el propio simulador. Prueba a ejecutar distintas veces la app desde el simulador, incluso a eliminar la aplicaci\u00f3n y volver a instalarla. Deber\u00eda conservarse el n\u00famero de tareas terminadas y el nombre de la \u00faltima. Se borrar\u00e1n las tareas pendientes (las guardaremos en CloudKit en la sesi\u00f3n siguiente). Muestra los datos guardados con una alerta al arrancar la app. Pr\u00e1ctica: ToDoList en CloudKit Configuraci\u00f3n de la app: Trabajamos con el proyecto ToDoList CloudKit y el bundle ID es.ua.mastermoviles.ToDoListCloudKit y el perfil de aprovisionamiento UA ToDoListCloudKit Profile . Arregla el storyboard de la app (hay una vista de navegaci\u00f3n de m\u00e1s). Desarrollo de la pr\u00e1ctica: A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. (Opcional): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas. Pista para actualizar la tabla Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoListTableViewController : 1 2 3 DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) Referencias Recursos sobre iCloud Referencia Framework CloudKit iCloud Design Guide CloudKit Quick Start Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Sesion03 icloud"},{"location":"sesion03/sesion03-icloud.html#sesion-3-icloud-y-cloudkit","text":"","title":"Sesi\u00f3n 3: iCloud y CloudKit"},{"location":"sesion03/sesion03-icloud.html#icloud","text":"iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros.","title":"iCloud"},{"location":"sesion03/sesion03-icloud.html#filosofia-de-icloud-para-el-usuario-de-ios","text":"La idea principal tras iCloud es eliminar la sincronizaci\u00f3n expl\u00edcita entre dispositivos. Un usuario nunca necesita pensar sobre la sincronizaci\u00f3n, y la app nunca interact\u00faa directamente con los servidores de iCloud. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud. Para el desarrollador, depende del API de iCloud que se utilice estos cambios son m\u00e1s o menos autom\u00e1ticos.","title":"Filosof\u00eda de iCloud (para el usuario de iOS)"},{"location":"sesion03/sesion03-icloud.html#cuenta-icloud","text":"Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID Permite identificarse y mantenerse logeado en el dispositivo Puede activarse desde un Mac, desde un dispositivo iOS, desde la web o desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos . Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos: Recordatorios, Notas, ... El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n.","title":"Cuenta iCloud"},{"location":"sesion03/sesion03-icloud.html#distintas-apis","text":"Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit (a partir de iOS 8): nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en registros con diccionarios clave-valor, enfoque muy similar a las tecnolog\u00edas NoSQL. API de transporte que no mantiene un estado local. Basada en peticiones y respuestas as\u00edncronas.","title":"Distintas APIs"},{"location":"sesion03/sesion03-icloud.html#preparacion-de-aprovisionamiento-y-permisos-para-icloud","text":"Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo automaticamente desde XCode. Puedes utilizar el perfil de aprovisionamiento UA ToDoListCloudKit Profile creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.ToDoListCloudKit .","title":"Preparaci\u00f3n de aprovisionamiento y permisos para iCloud"},{"location":"sesion03/sesion03-icloud.html#creacion-del-app-id","text":"Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Creamos el permiso (App ID) Master Moviles ToDoListCloudKit que incluye la capacidad de iCloud.","title":"Creaci\u00f3n del App ID"},{"location":"sesion03/sesion03-icloud.html#confirmacion-del-app-id","text":"La activaci\u00f3n del permiso de iCloud aparecer\u00e1 en amarillo porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante).","title":"Confirmaci\u00f3n del App ID"},{"location":"sesion03/sesion03-icloud.html#api-de-almacenamiento-clave-valor","text":"Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para acceder a los valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: 1 let iCloudStore = NSUbiquitousKeyValueStore . default","title":"API de almacenamiento clave-valor"},{"location":"sesion03/sesion03-icloud.html#metodo-synchronize","text":"1 func synchronize () - Bool - Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. - Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. - Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. - No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. - Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano.","title":"M\u00e9todo synchronize"},{"location":"sesion03/sesion03-icloud.html#ejemplo-de-uso-de-synchronize-al-lanzar-la-app","text":"1 2 3 4 5 6 7 8 9 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { let store = NSUbiquitousKeyValueStore . default if ( store . synchronize ()) { print ( Sincronizaci\u00f3n OK ) } else { print ( Problemas en la sincronizaci\u00f3n ) } return true }","title":"Ejemplo de uso de synchronize al lanzar la app"},{"location":"sesion03/sesion03-icloud.html#guardar-valores-en-el-almacen-de-claves-valor","text":"Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: 1 store . set ( Int64 ( 100 ), forKey : puntuacion )","title":"Guardar valores en el almac\u00e9n de claves-valor"},{"location":"sesion03/sesion03-icloud.html#obtencion-de-valores-del-almacen-de-claves-valor","text":"Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) bool(forKey: String) dictionary(forKey: String) string(forKey: String) ... Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: 1 let puntuacion = Int ( store . longLong ( forKey : puntuacion )) Par\u00e1metros y resultados del m\u00e9todo: forKey : un String que es la clave en el almac\u00e9n de claves-valor. Devuelve: el valor asociado a la clave o 0 si la clave no existe o no contiene un valor num\u00e9rico","title":"Obtenci\u00f3n de valores del almac\u00e9n de claves-valor"},{"location":"sesion03/sesion03-icloud.html#definiendo-un-observador-de-cambios","text":"Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado.","title":"Definiendo un observador de cambios"},{"location":"sesion03/sesion03-icloud.html#ejemplo-de-definicion-de-un-observador-de-la-notificacion","text":"Registramos una clausura para la notificaci\u00f3n con el nombre NSUbiquitousKeyValueStore.didChangeExternallyNotification en el momento de lanzar la app, y llamamos al m\u00e9todo synchronize() para obtener las parejas de claves-valor m\u00e1s recientes. 1 2 3 4 5 6 7 8 9 10 11 12 func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { NotificationCenter . default . addObserver ( forName : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : NSUbiquitousKeyValueStore . default (), queue : OperationQueue . main ) { ( notification ) in let ubiquitousKeyValueStore = notification . object as ! NSUbiquitousKeyValueStore ubiquitousKeyValueStore . synchronize () } }","title":"Ejemplo de definici\u00f3n de un observador de la notificaci\u00f3n"},{"location":"sesion03/sesion03-icloud.html#practica-todolist-con-icloud-clave-valor-2","text":"Debes modificar la aplicaci\u00f3n para que se guarden en el almac\u00e9n clave-valor de iCloud del usuario: N\u00famero de tareas terminadas \u00daltima tarea terminada Debes usar la app en el simulador habi\u00e9ndote logeado en iCloud en el propio simulador. Prueba a ejecutar distintas veces la app desde el simulador, incluso a eliminar la aplicaci\u00f3n y volver a instalarla. Deber\u00eda conservarse el n\u00famero de tareas terminadas y el nombre de la \u00faltima. Se borrar\u00e1n las tareas pendientes (las guardaremos en CloudKit en la sesi\u00f3n siguiente). Muestra los datos guardados con una alerta al arrancar la app.","title":"Pr\u00e1ctica: ToDoList con iCloud clave-valor (2)"},{"location":"sesion03/sesion03-icloud.html#cloudkit","text":"","title":"CloudKit"},{"location":"sesion03/sesion03-icloud.html#introduccion-a-cloudkit","text":"CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Acceso a servidores de iCloud. Usa las cuentas iCloud de los usuarios. Bases de datos p\u00fablicas (de la app) y privadas (de cada usuario). Permite datos estructurados y datos bulk . Tecnolog\u00eda de transporte, no proporciona base de datos local.","title":"Introducci\u00f3n a CloudKit"},{"location":"sesion03/sesion03-icloud.html#cloudkit-trabaja-sobre-registros-en-icloud","text":"CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. CloudKit trabaja sobre registros , diccionarios de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros.","title":"CloudKit trabaja sobre registros en iCloud"},{"location":"sesion03/sesion03-icloud.html#registros-publicos-y-privados","text":"Se pueden guardar registros de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los registros p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los registros privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar registros en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro.","title":"Registros p\u00fablicos y privados"},{"location":"sesion03/sesion03-icloud.html#tecnologia-de-transporte","text":"CloudKit no proporciona ninguna forma de almacenar datos localmente. Es un servicio para mover datos a y desde iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para iCloud y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen.","title":"Tecnolog\u00eda de transporte"},{"location":"sesion03/sesion03-icloud.html#elementos-de-cloudkit","text":"Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias Assets","title":"Elementos de CloudKit"},{"location":"sesion03/sesion03-icloud.html#contenedores","text":"M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Puedes compartir un contenedor entre varias apps . Existe un contenedor por defecto para cada app, pero puedes crear contenedores adicionales. El identificador por defecto se llama igual que el bundle ID de la app. Los contenedores adicionales deben tener un nombre \u00fanico entre todas las apps de los desarrolladores. Los contenedores no pueden borrarse.","title":"Contenedores"},{"location":"sesion03/sesion03-icloud.html#gestion-en-el-member-center","text":"Una de las opciones del member center permite gestionar contenedores de iCloud. Creamos uno con el identificador iCloud.ua.mastermoviles.ToDoListCloudKit que utilizaremos en la app ToDoList . No es posible borrar contenedores.","title":"Gesti\u00f3n en el member center"},{"location":"sesion03/sesion03-icloud.html#asignacion-del-container-al-app-id","text":"Incluimos en el App ID el contenedor de iCloud anterior.","title":"Asignaci\u00f3n del container al App ID"},{"location":"sesion03/sesion03-icloud.html#creacion-del-perfil-de-aprovisionamiento","text":"Creamos el perfil de aprovisionamiento UA ToDoListCloudKit Profile con el App ID anterior.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"sesion03/sesion03-icloud.html#actualizacion-de-capacidades-de-la-app-todolistcloudkit","text":"","title":"Actualizaci\u00f3n de capacidades de la app ToDoListCloudKit"},{"location":"sesion03/sesion03-icloud.html#dashboard","text":"Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. https://icloud.developer.apple.com/dashboard/ Permite: Crear, visualizar, editar y borrar esquemas, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue","title":"Dashboard"},{"location":"sesion03/sesion03-icloud.html#dashboard-permisos","text":"Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud.","title":"Dashboard: permisos"},{"location":"sesion03/sesion03-icloud.html#dashboard-tipos-de-registros","text":"","title":"Dashboard: tipos de registros"},{"location":"sesion03/sesion03-icloud.html#dashboard-logs","text":"","title":"Dashboard: logs"},{"location":"sesion03/sesion03-icloud.html#clase-ckcontainer","text":"La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta.","title":"Clase CKContainer"},{"location":"sesion03/sesion03-icloud.html#caracteristicas-sociales-de-cloudkit","text":"CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente.","title":"Caracter\u00edsticas sociales de CloudKit"},{"location":"sesion03/sesion03-icloud.html#caracteristicas-sociales-de-cloudkit_1","text":"Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente.","title":"Caracter\u00edsticas sociales de CloudKit"},{"location":"sesion03/sesion03-icloud.html#ejemplo-de-codigo-de-caracteristicas-sociales","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let container = CKContainer . default () print ( Container: ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( Permiso concedido: + \\( permissionStatus == CKApplicationPermissionStatus . granted ) )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }})","title":"Ejemplo de c\u00f3digo de caracter\u00edsticas sociales"},{"location":"sesion03/sesion03-icloud.html#bases-de-datos","text":"","title":"Bases de datos"},{"location":"sesion03/sesion03-icloud.html#bases-de-datos_1","text":"","title":"Bases de datos"},{"location":"sesion03/sesion03-icloud.html#bases-de-datos_2","text":"Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : 1 2 3 let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase","title":"Bases de datos"},{"location":"sesion03/sesion03-icloud.html#bases-de-datos_3","text":"","title":"Bases de datos"},{"location":"sesion03/sesion03-icloud.html#registros","text":"","title":"Registros"},{"location":"sesion03/sesion03-icloud.html#creacion-de-registros","text":"Se definen con la clase CKRecord . Conjunto de parejas clave y valor con un identificador \u00fanico de la clase. CKRecordID Se crean en tiempo de ejecuci\u00f3n indicando un tipo de registro definido por un String . 1 let tareaRecord = CKRecord ( recordType : Artista ) Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): 1 2 3 4 5 6 let nombre = Jonhn Lennon tareaRecord[ artista ] = nombre as NSString let formatter = DateFormatter() formatter.dateFormat = yyyy/MM/dd let fecha = formatter.date(from: 1940/10/09 ) tareaRecord[ fechanacimiento ] = fecha! as NSDate","title":"Creaci\u00f3n de registros"},{"location":"sesion03/sesion03-icloud.html#datos-en-los-registros","text":"El protocolo CKRecordValue define los posibles valores que pueden haber en los atributos de los registros: NSString : Cadenas NSNumber : N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior","title":"Datos en los registros"},{"location":"sesion03/sesion03-icloud.html#grabacion-de-registros","text":"Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). 1 2 3 4 privateDB . save ( tareaRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) - Void in print ( Registro: \\( record ) ) print ( Error: \\( error ) )})","title":"Grabaci\u00f3n de registros"},{"location":"sesion03/sesion03-icloud.html#relaciones-entre-registros-referencias","text":"","title":"Relaciones entre registros: referencias"},{"location":"sesion03/sesion03-icloud.html#referencias","text":"Clase CKReference El servidor entiende las relaciones Padre Hijo Borrados en cascada Cuidado con los problemas de integridad, ser\u00e1 normal que no existan referencias Se prefieren las referencias hacia atr\u00e1s para modelar las relaciones anteriores","title":"Referencias"},{"location":"sesion03/sesion03-icloud.html#queries","text":"Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation .","title":"Queries"},{"location":"sesion03/sesion03-icloud.html#ejemplo","text":"Query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual 1 2 3 4 5 6 7 8 9 10 11 12 13 let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( value : true )) let container = CKContainer . default () let privateDB = container . privateCloudDatabase privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in for result in results ! { if let nombre = result [ nombre ] { print ( Tarea: \\( nombre ) ) let toDoItem = ToDoItem ( nombre : nombre as ! String ) self . toDoItems . append ( toDoItem ) } } }) Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) 1 2 let predicate = NSPredicate ( format : nombre BEGINSWITH Limpiar ) let predicate = NSPredicate ( format : favoriteColors CONTAINS red )","title":"Ejemplo"},{"location":"sesion03/sesion03-icloud.html#operaciones-con-registros-obtenidos","text":"Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func deleteTarea ( _ nombre : String ) { let query = CKQuery ( recordType : Tarea , predicate : NSPredicate ( format : nombre == %@ , argumentArray : [ nombre ])) let container = CKContainer . default () let privateDB = container . privateCloudDatabase privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord privateDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( Error: \\( error ) ) }) } } }) }","title":"Operaciones con registros obtenidos"},{"location":"sesion03/sesion03-icloud.html#suscripciones","text":"Posibilidad de hacer consultas \"permanentes\" Ejecutadas en background por el servidor tras cada registro salvado Generan notificaciones push con los resultados","title":"Suscripciones"},{"location":"sesion03/sesion03-icloud.html#cloudkit-js","text":"CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) En 2016 Apple ha lanzado un servicio web para acceder a CloudKit usando peticiones REST.","title":"CloudKit JS"},{"location":"sesion03/sesion03-icloud.html#practica-todolist-con-icloud-clave-valor-1","text":"Preparaci\u00f3n previa Copia la carpeta ToDoList y ren\u00f3mbrala a ToDoList CloudKit . Elimina las referencias a Fabric y Crashlytics El bundle ID de la app debe ser es.ua.mastermoviles.ToDoListCloudKit y utilizar el perfil de aprovisionamiento UA ToDoListCloudKit Profile . Activa la capability de iCloud clave-valor.","title":"Pr\u00e1ctica: ToDoList con iCloud clave-valor (1)"},{"location":"sesion03/sesion03-icloud.html#practica-todolist-con-icloud-clave-valor-2_1","text":"Debes modificar la aplicaci\u00f3n para que se guarden en el almac\u00e9n clave-valor de iCloud del usuario: N\u00famero de tareas terminadas \u00daltima tarea terminada Debes usar la app en el simulador habi\u00e9ndote logeado en iCloud en el propio simulador. Prueba a ejecutar distintas veces la app desde el simulador, incluso a eliminar la aplicaci\u00f3n y volver a instalarla. Deber\u00eda conservarse el n\u00famero de tareas terminadas y el nombre de la \u00faltima. Se borrar\u00e1n las tareas pendientes (las guardaremos en CloudKit en la sesi\u00f3n siguiente). Muestra los datos guardados con una alerta al arrancar la app.","title":"Pr\u00e1ctica: ToDoList con iCloud clave-valor (2)"},{"location":"sesion03/sesion03-icloud.html#practica-todolist-en-cloudkit","text":"Configuraci\u00f3n de la app: Trabajamos con el proyecto ToDoList CloudKit y el bundle ID es.ua.mastermoviles.ToDoListCloudKit y el perfil de aprovisionamiento UA ToDoListCloudKit Profile . Arregla el storyboard de la app (hay una vista de navegaci\u00f3n de m\u00e1s). Desarrollo de la pr\u00e1ctica: A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. (Opcional): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas.","title":"Pr\u00e1ctica: ToDoList en CloudKit"},{"location":"sesion03/sesion03-icloud.html#pista-para-actualizar-la-tabla","text":"Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoListTableViewController : 1 2 3 DispatchQueue . main . async ( execute : { self . tableView . reloadData () })","title":"Pista para actualizar la tabla"},{"location":"sesion03/sesion03-icloud.html#referencias_1","text":"Recursos sobre iCloud Referencia Framework CloudKit iCloud Design Guide CloudKit Quick Start","title":"Referencias"},{"location":"sesion03/sesion03-icloud.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"},{"location":"sesion04/sesion04-mapas-localizacion.html","text":"Sesi\u00f3n 4: Mapas y localizaci\u00f3n Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 Aspectos b\u00e1sicos de MapKit Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, ... Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps. Aspectos b\u00e1sicos de MapKit Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir. Geometr\u00eda de los mapas Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: 1 2 let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) Otros puntos Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas. Permisos para activar los mapas en nuestra app Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y las pruebas. A\u00f1adir un mapa en nuestra app La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que implemente el protocolo MKMapViewDelegate . Ejemplo: a\u00f1adir un mapa mediante programa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 30 , width : self . view . frame . width , height : 200 )) self . view . addSubview ( map ) map . delegate = self } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () } } Resultado Inicializaci\u00f3n del mapa Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) let initialLocation = CLLocation ( latitude : alicanteLocation . latitude , longitude : alicanteLocation . longitude ) centerMapOnLocation ( mapView : mapView , loc : initialLocation ) // definida en la siguiente diapositiva } } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado. Centrado del mapa La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, la siguiente funci\u00f3n centra el mapa en una localizaci\u00f3n y muestra una zona de 4 km. de alto y ancho: 1 2 3 4 5 6 7 func centerMapOnLocation ( mapView : MKMapView , loc : CLLocation ) { let regionRadius : CLLocationDistance = 1000 let coordinateRegion = MKCoordinateRegionMakeWithDistance ( loc . coordinate , regionRadius * 4.0 , regionRadius * 4.0 ) mapView . setRegion ( coordinateRegion , animated : true ) } Tipos de mapas La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: 1 2 3 4 5 enum MKMapType : UInt { case standard case satellite case hybrid } Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } } Uso del delegado El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. Ejemplo: 1 2 3 func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) ) } Anotaciones Las anotaciones permite resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n. Clases relacionadas Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa. El protocolo MKAnnotation 1 2 3 var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } - coordinate : coordenadas de la anotaci\u00f3n - title : cadena mostrada en el callout - subtitle : cadena subt\u00edtulo mostrada en el callout El objeto annotation Los objetos annotation son objetos que conforman el protocolo MKAnnotation Un ejemplo sencillo: 1 2 3 4 5 6 7 8 9 10 11 12 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate super . init () } } MKAnnotationView La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image . Permite definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta). Creaci\u00f3n de la anotaci\u00f3n Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa. Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. 1 2 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar. Un ejemplo de vista de anotaci\u00f3n 1 2 3 4 5 6 7 8 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { print ( Devolviendo vista para anotaci\u00f3n: \\( annotation ) ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; } A\u00f1adir anotaciones en el mapa Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): 1 2 let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin ) Elementos en el callout Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure . Im\u00e1genes en las anotaciones Vamos a mostrar im\u00e1genes en la parte izquierda del callout , por ejemplo, thumbnails con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Lo m\u00e1s apropiado es guardar las im\u00e1genes en el objeto annotation . Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : alicante1_thumb.png ) ! } else { self . thumbImage = UIImage ( named : alicante2_thumb.png ) ! } super . init () } } Actualizaci\u00f3n del callout La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 func mapView ( mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { // // el mismo c\u00f3digo que antes // let pin = annotation as ! Pin let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin . thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButtonType . detailDisclosure ) return view } Overlays Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com . Mostrar un overlay Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa. Ejemplo de c\u00f3digo (1) Ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View 1 2 3 4 5 6 7 8 9 10 class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } } Ejemplo de c\u00f3digo (2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } } A\u00f1adido y dibujado del overlay El overlay debe a\u00f1adirse al mapView 1 2 let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: 1 2 3 4 5 6 7 8 9 10 11 12 func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) - MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : overlay_park )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () } Otras caracter\u00edsticas: b\u00fasquedas Otras caracter\u00edsticas: rutas Otras caracter\u00edsticas: 3D Localizaci\u00f3n Localizaci\u00f3n Las apps usan datos de localizaci\u00f3n del dispositivo para m\u00faltiples prop\u00f3sitos, desde redes sociales hasta servicios de navegaci\u00f3n. Los datos de localizaci\u00f3n se obtienen mediante el framework Core Location . La clase principal es CLLocationManager . Este framework proporciona bastantes servicios que puedes usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones te permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda. Activaci\u00f3n de los servicios de localizaci\u00f3n Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS. Solicitar informaci\u00f3n al usuario Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n. Clase CLLocationManager Se debe crear una instancia de la clase CLLocation\u200bManager y guardar una referencia fuerte a ella en la app. Se necesita mantener una referencia fuerte al objeto location manager hasta que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, es insuficiente almacenar una referencia al location manager en una variable local. Para activar la localizaci\u00f3n La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() . C\u00f3digo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ... Monitorizaci\u00f3n de la localizaci\u00f3n Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): 1 2 3 func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones } Clase CLLocation La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description Activaci\u00f3n de la localizaci\u00f3n en el mapa Una vez activado el servicio de localizaci\u00f3n se puede activar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton } Prueba de la localizaci\u00f3n en el simulador Es posible probar los servicios de localizaci\u00f3n desde el simulador Seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug Location Opciones: Ninguna Custom Apple City Bicycle Ride City Run Freeway Ride Pr\u00e1ctica: Mapas (1) Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incluye el View Controller en un Navigation Controller con la opci\u00f3n Editor Embed In Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control. Pr\u00e1ctica: Mapas (2) En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa. Pr\u00e1ctica: Mapas (3) A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n. Pr\u00e1ctica: Mapas (opcional - 2,5 puntos) Implementa un segue que haga aparecer otra vista con un detalle de la foto. Pr\u00e1ctica: Mapas Pista 1 (Segue): 1 2 3 4 5 6 7 8 9 10 11 12 13 func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : DetalleImagen , sender : view ) } override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if segue . identifier == DetalleImagen { if let pin = ( sender as ? MKAnnotationView )?. annotation as ? Pin { if let vc = segue . destination as ? MiImageViewController { vc . imageDetail = pin . thumbImage } } } } Pr\u00e1ctica: Mapas Pista 2 ( ViewController de la vista detalle): 1 2 3 4 5 6 7 8 9 10 11 12 class ImageDetailViewController : UIViewController { @IBOutlet weak var imageView : UIImageView ! var imageDetail : UIImage ? = nil override func viewDidLoad () { super . viewDidLoad () if imageDetail != nil { imageView . image = imageDetail ! } } } Pr\u00e1ctica: Mapas (Localizaci\u00f3n - opcional 2,5 puntos) A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Referencias Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide APIs: Map Kit Framework Reference Core Location Framework Reference Art\u00edculo - pedir autorizaci\u00f3n en uso Art\u00edculo - pedir autorizaci\u00f3n siempre Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Sesi\u00f3n 4: <br/> Mapas y <br/>localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#sesion-4-mapas-y-localizacion","text":"","title":"Sesi\u00f3n 4:  Mapas y localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#aspectos-basicos-de-mapkit","text":"Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, ... Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps.","title":"Aspectos b\u00e1sicos de MapKit"},{"location":"sesion04/sesion04-mapas-localizacion.html#aspectos-basicos-de-mapkit_1","text":"Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir.","title":"Aspectos b\u00e1sicos de MapKit"},{"location":"sesion04/sesion04-mapas-localizacion.html#geometria-de-los-mapas","text":"Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: 1 2 let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 )","title":"Geometr\u00eda de los mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#otros-puntos","text":"Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas.","title":"Otros puntos"},{"location":"sesion04/sesion04-mapas-localizacion.html#permisos-para-activar-los-mapas-en-nuestra-app","text":"Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y las pruebas.","title":"Permisos para activar los mapas en nuestra app"},{"location":"sesion04/sesion04-mapas-localizacion.html#anadir-un-mapa-en-nuestra-app","text":"La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que implemente el protocolo MKMapViewDelegate .","title":"A\u00f1adir un mapa en nuestra app"},{"location":"sesion04/sesion04-mapas-localizacion.html#ejemplo-anadir-un-mapa-mediante-programa","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 30 , width : self . view . frame . width , height : 200 )) self . view . addSubview ( map ) map . delegate = self } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () } }","title":"Ejemplo: a\u00f1adir un mapa mediante programa"},{"location":"sesion04/sesion04-mapas-localizacion.html#resultado","text":"","title":"Resultado"},{"location":"sesion04/sesion04-mapas-localizacion.html#inicializacion-del-mapa","text":"Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) let initialLocation = CLLocation ( latitude : alicanteLocation . latitude , longitude : alicanteLocation . longitude ) centerMapOnLocation ( mapView : mapView , loc : initialLocation ) // definida en la siguiente diapositiva } } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado.","title":"Inicializaci\u00f3n del mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#centrado-del-mapa","text":"La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, la siguiente funci\u00f3n centra el mapa en una localizaci\u00f3n y muestra una zona de 4 km. de alto y ancho: 1 2 3 4 5 6 7 func centerMapOnLocation ( mapView : MKMapView , loc : CLLocation ) { let regionRadius : CLLocationDistance = 1000 let coordinateRegion = MKCoordinateRegionMakeWithDistance ( loc . coordinate , regionRadius * 4.0 , regionRadius * 4.0 ) mapView . setRegion ( coordinateRegion , animated : true ) }","title":"Centrado del mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#tipos-de-mapas","text":"La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: 1 2 3 4 5 enum MKMapType : UInt { case standard case satellite case hybrid }","title":"Tipos de mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#ejemplo-de-seleccion-del-tipo-de-mapa-con-un-segmentedcontrol","text":"Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } }","title":"Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl"},{"location":"sesion04/sesion04-mapas-localizacion.html#uso-del-delegado","text":"El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. Ejemplo: 1 2 3 func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) ) }","title":"Uso del delegado"},{"location":"sesion04/sesion04-mapas-localizacion.html#anotaciones","text":"Las anotaciones permite resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n.","title":"Anotaciones"},{"location":"sesion04/sesion04-mapas-localizacion.html#clases-relacionadas","text":"Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa.","title":"Clases relacionadas"},{"location":"sesion04/sesion04-mapas-localizacion.html#el-protocolo-mkannotation","text":"1 2 3 var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } - coordinate : coordenadas de la anotaci\u00f3n - title : cadena mostrada en el callout - subtitle : cadena subt\u00edtulo mostrada en el callout","title":"El protocolo MKAnnotation"},{"location":"sesion04/sesion04-mapas-localizacion.html#el-objeto-annotation","text":"Los objetos annotation son objetos que conforman el protocolo MKAnnotation Un ejemplo sencillo: 1 2 3 4 5 6 7 8 9 10 11 12 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate super . init () } }","title":"El objeto annotation"},{"location":"sesion04/sesion04-mapas-localizacion.html#mkannotationview","text":"La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image . Permite definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta).","title":"MKAnnotationView"},{"location":"sesion04/sesion04-mapas-localizacion.html#creacion-de-la-anotacion","text":"Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa. Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. 1 2 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar.","title":"Creaci\u00f3n de la anotaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#un-ejemplo-de-vista-de-anotacion","text":"1 2 3 4 5 6 7 8 func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { print ( Devolviendo vista para anotaci\u00f3n: \\( annotation ) ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; }","title":"Un ejemplo de vista de anotaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#anadir-anotaciones-en-el-mapa","text":"Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): 1 2 let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin )","title":"A\u00f1adir anotaciones en el mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#elementos-en-el-callout","text":"Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure .","title":"Elementos en el callout"},{"location":"sesion04/sesion04-mapas-localizacion.html#imagenes-en-las-anotaciones","text":"Vamos a mostrar im\u00e1genes en la parte izquierda del callout , por ejemplo, thumbnails con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Lo m\u00e1s apropiado es guardar las im\u00e1genes en el objeto annotation . Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = Pin \\( num ) self . subtitle = Un bonito lugar self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : alicante1_thumb.png ) ! } else { self . thumbImage = UIImage ( named : alicante2_thumb.png ) ! } super . init () } }","title":"Im\u00e1genes en las anotaciones"},{"location":"sesion04/sesion04-mapas-localizacion.html#actualizacion-del-callout","text":"La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 func mapView ( mapView : MKMapView , viewFor annotation : MKAnnotation ) - MKAnnotationView ? { // // el mismo c\u00f3digo que antes // let pin = annotation as ! Pin let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin . thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButtonType . detailDisclosure ) return view }","title":"Actualizaci\u00f3n del callout"},{"location":"sesion04/sesion04-mapas-localizacion.html#overlays","text":"Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com .","title":"Overlays"},{"location":"sesion04/sesion04-mapas-localizacion.html#mostrar-un-overlay","text":"Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa.","title":"Mostrar un overlay"},{"location":"sesion04/sesion04-mapas-localizacion.html#ejemplo-de-codigo-1","text":"Ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View 1 2 3 4 5 6 7 8 9 10 class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } }","title":"Ejemplo de c\u00f3digo (1)"},{"location":"sesion04/sesion04-mapas-localizacion.html#ejemplo-de-codigo-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } }","title":"Ejemplo de c\u00f3digo (2)"},{"location":"sesion04/sesion04-mapas-localizacion.html#anadido-y-dibujado-del-overlay","text":"El overlay debe a\u00f1adirse al mapView 1 2 let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: 1 2 3 4 5 6 7 8 9 10 11 12 func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) - MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : overlay_park )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () }","title":"A\u00f1adido y dibujado del overlay"},{"location":"sesion04/sesion04-mapas-localizacion.html#otras-caracteristicas-busquedas","text":"","title":"Otras caracter\u00edsticas: b\u00fasquedas"},{"location":"sesion04/sesion04-mapas-localizacion.html#otras-caracteristicas-rutas","text":"","title":"Otras caracter\u00edsticas: rutas"},{"location":"sesion04/sesion04-mapas-localizacion.html#otras-caracteristicas-3d","text":"","title":"Otras caracter\u00edsticas: 3D"},{"location":"sesion04/sesion04-mapas-localizacion.html#localizacion","text":"","title":"Localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#localizacion_1","text":"Las apps usan datos de localizaci\u00f3n del dispositivo para m\u00faltiples prop\u00f3sitos, desde redes sociales hasta servicios de navegaci\u00f3n. Los datos de localizaci\u00f3n se obtienen mediante el framework Core Location . La clase principal es CLLocationManager . Este framework proporciona bastantes servicios que puedes usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones te permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda.","title":"Localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#activacion-de-los-servicios-de-localizacion","text":"Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS.","title":"Activaci\u00f3n de los servicios de localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#solicitar-informacion-al-usuario","text":"Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n.","title":"Solicitar informaci\u00f3n al usuario"},{"location":"sesion04/sesion04-mapas-localizacion.html#clase-cllocationmanager","text":"Se debe crear una instancia de la clase CLLocation\u200bManager y guardar una referencia fuerte a ella en la app. Se necesita mantener una referencia fuerte al objeto location manager hasta que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, es insuficiente almacenar una referencia al location manager en una variable local.","title":"Clase CLLocationManager"},{"location":"sesion04/sesion04-mapas-localizacion.html#para-activar-la-localizacion","text":"La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() .","title":"Para activar la localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#codigo","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) - Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ...","title":"C\u00f3digo"},{"location":"sesion04/sesion04-mapas-localizacion.html#monitorizacion-de-la-localizacion","text":"Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): 1 2 3 func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones }","title":"Monitorizaci\u00f3n de la localizaci\u00f3n"},{"location":"sesion04/sesion04-mapas-localizacion.html#clase-cllocation","text":"La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description","title":"Clase CLLocation"},{"location":"sesion04/sesion04-mapas-localizacion.html#activacion-de-la-localizacion-en-el-mapa","text":"Una vez activado el servicio de localizaci\u00f3n se puede activar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton }","title":"Activaci\u00f3n de la localizaci\u00f3n en el mapa"},{"location":"sesion04/sesion04-mapas-localizacion.html#prueba-de-la-localizacion-en-el-simulador","text":"Es posible probar los servicios de localizaci\u00f3n desde el simulador Seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug Location Opciones: Ninguna Custom Apple City Bicycle Ride City Run Freeway Ride","title":"Prueba de la localizaci\u00f3n en el simulador"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas-1","text":"Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incluye el View Controller en un Navigation Controller con la opci\u00f3n Editor Embed In Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control.","title":"Pr\u00e1ctica: Mapas (1)"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas-2","text":"En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa.","title":"Pr\u00e1ctica: Mapas (2)"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas-3","text":"A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n.","title":"Pr\u00e1ctica: Mapas (3)"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas-opcional-25-puntos","text":"Implementa un segue que haga aparecer otra vista con un detalle de la foto.","title":"Pr\u00e1ctica: Mapas (opcional - 2,5 puntos)"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas","text":"Pista 1 (Segue): 1 2 3 4 5 6 7 8 9 10 11 12 13 func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : DetalleImagen , sender : view ) } override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if segue . identifier == DetalleImagen { if let pin = ( sender as ? MKAnnotationView )?. annotation as ? Pin { if let vc = segue . destination as ? MiImageViewController { vc . imageDetail = pin . thumbImage } } } }","title":"Pr\u00e1ctica: Mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas_1","text":"Pista 2 ( ViewController de la vista detalle): 1 2 3 4 5 6 7 8 9 10 11 12 class ImageDetailViewController : UIViewController { @IBOutlet weak var imageView : UIImageView ! var imageDetail : UIImage ? = nil override func viewDidLoad () { super . viewDidLoad () if imageDetail != nil { imageView . image = imageDetail ! } } }","title":"Pr\u00e1ctica: Mapas"},{"location":"sesion04/sesion04-mapas-localizacion.html#practica-mapas-localizacion-opcional-25-puntos","text":"A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n).","title":"Pr\u00e1ctica: Mapas (Localizaci\u00f3n - opcional 2,5 puntos)"},{"location":"sesion04/sesion04-mapas-localizacion.html#referencias","text":"Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide APIs: Map Kit Framework Reference Core Location Framework Reference Art\u00edculo - pedir autorizaci\u00f3n en uso Art\u00edculo - pedir autorizaci\u00f3n siempre","title":"Referencias"},{"location":"sesion04/sesion04-mapas-localizacion.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"},{"location":"sesion05/sesion05-extensiones.html","text":"Sesi\u00f3n 5: Extensiones Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 Introducci\u00f3n Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo). Ejemplo de extensi\u00f3n: Panel de Hoy (Widgets) Las apps pueden instalar extensiones en el panel de Hoy. Estas extensiones tienen una peque\u00f1a vista que se muestran una sobre otra. Las extensiones pueden tener dos vistas: una est\u00e1ndar y otra ampliada (que se muestra al pulsar Mostrar m\u00e1s ) El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas. Ejemplo de extensi\u00f3n: Compartir Tipos de extensiones Tipos de extensiones: Today Share Actions Custom Keyboard Photo Editing File Provider Document Provider Audio Finder Sync Puntos de extensi\u00f3n Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple . Algunos puntos de extensi\u00f3n Action : Manipular o ver contenido que se origina en una app anfitriona. Document Provider : Proporcionar acceso a y manejar un repositorio de ficheros. Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Editar una foto o v\u00eddeo dentro de la app Fotos. Share : Enviar a una website o compartir contenido con otros. WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch. Ciclo de vida de una app extension Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social. Comunicaci\u00f3n de la app extension Una app extension se comunica principalmente con su app anfitriona. No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora. La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Creaci\u00f3n de extensiones dentro de apps Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n. Se construyen de forma independiente Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador. Notification Service Extension La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. El nuevo target contiene una subclase de la clase UNNotificationServiceExtension que se debe modificar. Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario. Contenedores de la app y la extensi\u00f3n La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando frameworks embebidos compartidos Es posible compartir datos usando grupos de apps, CoreData o sqlite. Framework embebido para compartir c\u00f3digo Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files . Grupos de apps Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Todas las apps y extensiones deben usar ese mismo identificador en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode). Configuraci\u00f3n del grupo de apps Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList App IDs y perfiles de aprovisionamiento A\u00f1adimos el identificador de grupo en los App IDs y actualizamos el perfil de aprovisionamiento. App IDs: ToDoList CloudKit ToDoList Today Extension Perfiles de aprovisionamiento: ToDoListCloudKit Profile ToDoList Today Extension Capabilities Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido. Compartir datos con UserDefaults La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. 1 2 3 4 5 6 7 8 9 10 11 let compartido = UserDefaults ( suiteName : group.app.group.id ) // set valores compartido ?. set ( 1 , forKey : contador ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : contador ) Compartir datos con FileManager La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. 1 2 3 4 5 6 let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : group.com.company.project ) { ... } Demo: Crypticker Se puede descargar desde este enlace , est\u00e1 incluida en el tutorial de raywenderlich.com 3 productos: app, today extension y framework. No hay comunicaci\u00f3n entre la extensi\u00f3n y la app, pero s\u00ed c\u00f3digo compartido: el dibujo de la gr\u00e1fica se realiza con un framework embebido . Examinar c\u00f3mo funcionan la app y la extensi\u00f3n. Pr\u00e1ctica: ToDoList Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y el \u00faltimo. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA. Referencias P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide Tutorial Raywenderlich sobre extensiones Today (Crypticker) Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Sesi\u00f3n 5: <br/> Extensiones"},{"location":"sesion05/sesion05-extensiones.html#sesion-5-extensiones","text":"","title":"Sesi\u00f3n 5:  Extensiones"},{"location":"sesion05/sesion05-extensiones.html#introduccion","text":"Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo).","title":"Introducci\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#ejemplo-de-extension-panel-de-hoy-widgets","text":"Las apps pueden instalar extensiones en el panel de Hoy. Estas extensiones tienen una peque\u00f1a vista que se muestran una sobre otra. Las extensiones pueden tener dos vistas: una est\u00e1ndar y otra ampliada (que se muestra al pulsar Mostrar m\u00e1s ) El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas.","title":"Ejemplo de extensi\u00f3n: Panel de Hoy (Widgets)"},{"location":"sesion05/sesion05-extensiones.html#ejemplo-de-extension-compartir","text":"","title":"Ejemplo de extensi\u00f3n: Compartir"},{"location":"sesion05/sesion05-extensiones.html#tipos-de-extensiones","text":"Tipos de extensiones: Today Share Actions Custom Keyboard Photo Editing File Provider Document Provider Audio Finder Sync","title":"Tipos de extensiones"},{"location":"sesion05/sesion05-extensiones.html#puntos-de-extension","text":"Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple .","title":"Puntos de extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#algunos-puntos-de-extension","text":"Action : Manipular o ver contenido que se origina en una app anfitriona. Document Provider : Proporcionar acceso a y manejar un repositorio de ficheros. Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Editar una foto o v\u00eddeo dentro de la app Fotos. Share : Enviar a una website o compartir contenido con otros. WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch.","title":"Algunos puntos de extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#ciclo-de-vida-de-una-app-extension","text":"Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social.","title":"Ciclo de vida de una app extension"},{"location":"sesion05/sesion05-extensiones.html#comunicacion-de-la-app-extension","text":"Una app extension se comunica principalmente con su app anfitriona. No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora. La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido.","title":"Comunicaci\u00f3n de la app extension"},{"location":"sesion05/sesion05-extensiones.html#creacion-de-extensiones-dentro-de-apps","text":"Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n.","title":"Creaci\u00f3n de extensiones dentro de apps"},{"location":"sesion05/sesion05-extensiones.html#se-construyen-de-forma-independiente","text":"Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador.","title":"Se construyen de forma independiente"},{"location":"sesion05/sesion05-extensiones.html#notification-service-extension","text":"La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. El nuevo target contiene una subclase de la clase UNNotificationServiceExtension que se debe modificar. Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario.","title":"Notification Service Extension"},{"location":"sesion05/sesion05-extensiones.html#contenedores-de-la-app-y-la-extension","text":"La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando frameworks embebidos compartidos Es posible compartir datos usando grupos de apps, CoreData o sqlite.","title":"Contenedores de la app y la extensi\u00f3n"},{"location":"sesion05/sesion05-extensiones.html#framework-embebido-para-compartir-codigo","text":"Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files .","title":"Framework embebido para compartir c\u00f3digo"},{"location":"sesion05/sesion05-extensiones.html#grupos-de-apps","text":"Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Todas las apps y extensiones deben usar ese mismo identificador en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode).","title":"Grupos de apps"},{"location":"sesion05/sesion05-extensiones.html#configuracion-del-grupo-de-apps","text":"Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList","title":"Configuraci\u00f3n del grupo de apps"},{"location":"sesion05/sesion05-extensiones.html#app-ids-y-perfiles-de-aprovisionamiento","text":"A\u00f1adimos el identificador de grupo en los App IDs y actualizamos el perfil de aprovisionamiento. App IDs: ToDoList CloudKit ToDoList Today Extension Perfiles de aprovisionamiento: ToDoListCloudKit Profile ToDoList Today Extension","title":"App IDs y perfiles de aprovisionamiento"},{"location":"sesion05/sesion05-extensiones.html#capabilities","text":"Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido.","title":"Capabilities"},{"location":"sesion05/sesion05-extensiones.html#compartir-datos-con-userdefaults","text":"La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. 1 2 3 4 5 6 7 8 9 10 11 let compartido = UserDefaults ( suiteName : group.app.group.id ) // set valores compartido ?. set ( 1 , forKey : contador ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : contador )","title":"Compartir datos con UserDefaults"},{"location":"sesion05/sesion05-extensiones.html#compartir-datos-con-filemanager","text":"La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. 1 2 3 4 5 6 let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : group.com.company.project ) { ... }","title":"Compartir datos con FileManager"},{"location":"sesion05/sesion05-extensiones.html#demo-crypticker","text":"Se puede descargar desde este enlace , est\u00e1 incluida en el tutorial de raywenderlich.com 3 productos: app, today extension y framework. No hay comunicaci\u00f3n entre la extensi\u00f3n y la app, pero s\u00ed c\u00f3digo compartido: el dibujo de la gr\u00e1fica se realiza con un framework embebido . Examinar c\u00f3mo funcionan la app y la extensi\u00f3n.","title":"Demo: Crypticker"},{"location":"sesion05/sesion05-extensiones.html#practica-todolist","text":"Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y el \u00faltimo. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA.","title":"Pr\u00e1ctica: ToDoList"},{"location":"sesion05/sesion05-extensiones.html#referencias","text":"P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide Tutorial Raywenderlich sobre extensiones Today (Crypticker)","title":"Referencias"},{"location":"sesion05/sesion05-extensiones.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"},{"location":"sesion06/sesion06-compras-inapp.html","text":"Sesi\u00f3n 6: Compras In-App Servicios de las plataformas m\u00f3viles - iOS Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18 \u00bfQu\u00e9 es una compra In-App? Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra. Ejemplos de uso Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium Podemos permitir la subscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line Tipos de compras In-App - Compras No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz. Tipos de compras In-App - Subscripciones Subscripciones auto-renovables Como los no-consumibles, las subscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Subscripciones no-renovables Subscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la subscripci\u00f3n se realizan desde la app (y el servidor). Requisitos para activar las In-App Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador. Contratos \u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla. Servicios a activar en la app Bundle identifier y App Id Configuraci\u00f3n In-App desde iTunes Connect Datos del app Pantalla para a\u00f1adir nuevos In-Apps Seleccionar el tipo de In-App Caracter\u00edsticas del In-App Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple Caracter\u00edsticas del In-App Caracter\u00edsticas del In-App (2) Usuarios de prueba Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba. Aplicaci\u00f3n ejemplo Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en las plantillas en este enlace Aplicaci\u00f3n ejemplo (2) El proceso de compra en un vistazo Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver . Clase auxiliar InApp (1) Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : 1 2 3 protocol InAppDelegate { func compraRecibida () } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . defaultQueue (). addTransactionObserver ( self ) // Cargamos la lista de productos productIdentiferList . append ( ejemplo3 ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () } Clase auxiliar InApp (2) 1 2 3 4 5 6 7 8 9 // M\u00e9todo del delegado al que se llama cuando se han recibido los productos func productsRequest ( request : SKProductsRequest , didReceiveResponse response : SKProductsResponse ) { print ( Hemos recibido \\( response . products . count ) productos ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( Producto invalido id: \\( invalidProductId ) ) } } Clase auxiliar InApp (3) 1 2 3 4 5 6 7 8 9 10 11 12 13 // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count 0 SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . defaultQueue (). addPayment ( pago ) print ( Comprando... ) } else { print ( No existen productos ) } } Clase auxiliar InApp (4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // M\u00e9todo del delegado al que se llama cuando el usuario compra el InApp func paymentQueue ( queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . Purchased : print ( Purchased ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Failed : print ( Failed ) print ( Error de transacci\u00f3n: \\( transaction . error ?. localizedDescription ) ) SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Restored : print ( Restored ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) default : print ( Otro ) } } } Clase ViewController (1) En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () // Instancia de la clase auxiliar InApp override func viewDidLoad () { // Nos hacemos delegados de InApp inApp . delegate = self // Escondemos el bot\u00f3n que da acceso a la pantalla sorpresa botonSorpresa . hidden = true // Comprobamos si el usuario ha comprado antes el inApp // Funciona si el usuario est\u00e1 identificado if NSUserDefaults . standardUserDefaults (). boolForKey ( inAppComprado ) { botonSorpresa . hidden = false } else { botonSorpresa . hidden = true } super . viewDidLoad () } Clase ViewController (2) La acci\u00f3n asociada al bot\u00f3n de compra llama al m\u00e9todo lanzarPago de la instancia de nuestra clase InApp : 1 2 3 4 5 // Acci\u00f3n asociada al bot\u00f3n de compra @IBAction func hazCompra ( sender : UIButton ) { print ( Click bot\u00f3n de compra ) inApp . lanzarPago () } Clase ViewController (3) En el m\u00e9todo compraRecibida() (del protocolo) activamos un bot\u00f3n que da acceso a la pantalla sorpresa. 1 2 3 4 // Implementaci\u00f3n del m\u00e9todo del protocolo InAppDelegate func compraRecibida () { botonSorpresa . hidden = false } Acci\u00f3n para mostrar la pantalla sorpresa: 1 2 3 4 @IBAction func sorpresa ( sender : UIButton ){ performSegueWithIdentifier ( Sorpresa , sender : view ) } } Demo Referencias Recursos sobre compras In-App In-App Purchase Configuration Guide for iTunes Connect In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Getting Started with In-App purchase Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices Master Programaci\u00f3n de Dispositivos M\u00f3viles","title":"Sesi\u00f3n 6: <br/> Compras In-App"},{"location":"sesion06/sesion06-compras-inapp.html#sesion-6-compras-in-app","text":"","title":"Sesi\u00f3n 6:  Compras In-App"},{"location":"sesion06/sesion06-compras-inapp.html#servicios-de-las-plataformas-moviles-ios","text":"Domingo Gallardo - domingo.gallardo@ua.es Departamento Ciencia de la Computaci\u00f3n e Inteligencia Artificial Master Programaci\u00f3n de Dispositivos M\u00f3viles 2017-18","title":"Servicios de las plataformas m\u00f3viles - iOS"},{"location":"sesion06/sesion06-compras-inapp.html#que-es-una-compra-in-app","text":"Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra.","title":"\u00bfQu\u00e9 es una compra In-App?"},{"location":"sesion06/sesion06-compras-inapp.html#ejemplos-de-uso","text":"Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium Podemos permitir la subscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line","title":"Ejemplos de uso"},{"location":"sesion06/sesion06-compras-inapp.html#tipos-de-compras-in-app-compras","text":"No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz.","title":"Tipos de compras In-App - Compras"},{"location":"sesion06/sesion06-compras-inapp.html#tipos-de-compras-in-app-subscripciones","text":"Subscripciones auto-renovables Como los no-consumibles, las subscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Subscripciones no-renovables Subscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la subscripci\u00f3n se realizan desde la app (y el servidor).","title":"Tipos de compras In-App - Subscripciones"},{"location":"sesion06/sesion06-compras-inapp.html#requisitos-para-activar-las-in-app","text":"Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador.","title":"Requisitos para activar las In-App"},{"location":"sesion06/sesion06-compras-inapp.html#contratos","text":"\u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla.","title":"Contratos"},{"location":"sesion06/sesion06-compras-inapp.html#servicios-a-activar-en-la-app","text":"","title":"Servicios a activar en la app"},{"location":"sesion06/sesion06-compras-inapp.html#bundle-identifier-y-app-id","text":"","title":"Bundle identifier y App Id"},{"location":"sesion06/sesion06-compras-inapp.html#configuracion-in-app-desde-itunes-connect","text":"","title":"Configuraci\u00f3n In-App desde iTunes Connect"},{"location":"sesion06/sesion06-compras-inapp.html#datos-del-app","text":"","title":"Datos del app"},{"location":"sesion06/sesion06-compras-inapp.html#pantalla-para-anadir-nuevos-in-apps","text":"","title":"Pantalla para a\u00f1adir nuevos In-Apps"},{"location":"sesion06/sesion06-compras-inapp.html#seleccionar-el-tipo-de-in-app","text":"","title":"Seleccionar el tipo de In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app","text":"Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple","title":"Caracter\u00edsticas del In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app_1","text":"","title":"Caracter\u00edsticas del In-App"},{"location":"sesion06/sesion06-compras-inapp.html#caracteristicas-del-in-app-2","text":"","title":"Caracter\u00edsticas del In-App (2)"},{"location":"sesion06/sesion06-compras-inapp.html#usuarios-de-prueba","text":"Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba.","title":"Usuarios de prueba"},{"location":"sesion06/sesion06-compras-inapp.html#aplicacion-ejemplo","text":"Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en las plantillas en este enlace","title":"Aplicaci\u00f3n ejemplo"},{"location":"sesion06/sesion06-compras-inapp.html#aplicacion-ejemplo-2","text":"","title":"Aplicaci\u00f3n ejemplo (2)"},{"location":"sesion06/sesion06-compras-inapp.html#el-proceso-de-compra-en-un-vistazo","text":"Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver .","title":"El proceso de compra en un vistazo"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-1","text":"Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : 1 2 3 protocol InAppDelegate { func compraRecibida () } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . defaultQueue (). addTransactionObserver ( self ) // Cargamos la lista de productos productIdentiferList . append ( ejemplo3 ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () }","title":"Clase auxiliar InApp (1)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-2","text":"1 2 3 4 5 6 7 8 9 // M\u00e9todo del delegado al que se llama cuando se han recibido los productos func productsRequest ( request : SKProductsRequest , didReceiveResponse response : SKProductsResponse ) { print ( Hemos recibido \\( response . products . count ) productos ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( Producto invalido id: \\( invalidProductId ) ) } }","title":"Clase auxiliar InApp (2)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count 0 SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . defaultQueue (). addPayment ( pago ) print ( Comprando... ) } else { print ( No existen productos ) } }","title":"Clase auxiliar InApp (3)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-auxiliar-inapp-4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // M\u00e9todo del delegado al que se llama cuando el usuario compra el InApp func paymentQueue ( queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . Purchased : print ( Purchased ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Failed : print ( Failed ) print ( Error de transacci\u00f3n: \\( transaction . error ?. localizedDescription ) ) SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) case . Restored : print ( Restored ) delegate ?. compraRecibida () SKPaymentQueue . defaultQueue () . finishTransaction ( transaction ) default : print ( Otro ) } } }","title":"Clase auxiliar InApp (4)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-1","text":"En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () // Instancia de la clase auxiliar InApp override func viewDidLoad () { // Nos hacemos delegados de InApp inApp . delegate = self // Escondemos el bot\u00f3n que da acceso a la pantalla sorpresa botonSorpresa . hidden = true // Comprobamos si el usuario ha comprado antes el inApp // Funciona si el usuario est\u00e1 identificado if NSUserDefaults . standardUserDefaults (). boolForKey ( inAppComprado ) { botonSorpresa . hidden = false } else { botonSorpresa . hidden = true } super . viewDidLoad () }","title":"Clase ViewController (1)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-2","text":"La acci\u00f3n asociada al bot\u00f3n de compra llama al m\u00e9todo lanzarPago de la instancia de nuestra clase InApp : 1 2 3 4 5 // Acci\u00f3n asociada al bot\u00f3n de compra @IBAction func hazCompra ( sender : UIButton ) { print ( Click bot\u00f3n de compra ) inApp . lanzarPago () }","title":"Clase ViewController (2)"},{"location":"sesion06/sesion06-compras-inapp.html#clase-viewcontroller-3","text":"En el m\u00e9todo compraRecibida() (del protocolo) activamos un bot\u00f3n que da acceso a la pantalla sorpresa. 1 2 3 4 // Implementaci\u00f3n del m\u00e9todo del protocolo InAppDelegate func compraRecibida () { botonSorpresa . hidden = false } Acci\u00f3n para mostrar la pantalla sorpresa: 1 2 3 4 @IBAction func sorpresa ( sender : UIButton ){ performSegueWithIdentifier ( Sorpresa , sender : view ) } }","title":"Clase ViewController (3)"},{"location":"sesion06/sesion06-compras-inapp.html#demo","text":"","title":"Demo"},{"location":"sesion06/sesion06-compras-inapp.html#referencias","text":"Recursos sobre compras In-App In-App Purchase Configuration Guide for iTunes Connect In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Getting Started with In-App purchase Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices","title":"Referencias"},{"location":"sesion06/sesion06-compras-inapp.html#master-programacion-de-dispositivos-moviles","text":"","title":"Master Programaci\u00f3n  de Dispositivos M\u00f3viles"}]}