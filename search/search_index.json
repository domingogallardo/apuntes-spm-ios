{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Sitio web con los apuntes de la asignatura \"Servicios de las Plataformas M\u00f3viles (iOS)\" del Master en Desarrollo de Software para Dispositivos M\u00f3viles. Despliega el men\u00fa de la izquierda para consultar los apuntes.","title":"Index"},{"location":"practicas/anuncios/anuncios.html","text":"Pr\u00e1ctica 5: Anuncios (Opcional) \u00b6 Esta pr\u00e1ctica es opcional. En la pr\u00e1ctica deber\u00e1s a\u00f1adir anuncios a la app ToDo . Debes a\u00f1adir un banner en la parte inferior de la lista de tareas. El anuncio del banner debe cambiar cada vez que se vuelve a esta lista desde la pantalla con el resumen de tareas completadas. Una de cada cinco veces que se vuelva a esta lista de tareas debe mostrarse un anuncio intersticial. En la pantalla del resumen de tareas completadas debes poner un bot\u00f3n que abra una alerta para quitar los anuncios. Una vez que el usuario lo confirme dejar\u00e1n de mostrarse anuncios en la app.","title":"Pr\u00e1ctica 5"},{"location":"practicas/anuncios/anuncios.html#practica-5-anuncios-opcional","text":"Esta pr\u00e1ctica es opcional. En la pr\u00e1ctica deber\u00e1s a\u00f1adir anuncios a la app ToDo . Debes a\u00f1adir un banner en la parte inferior de la lista de tareas. El anuncio del banner debe cambiar cada vez que se vuelve a esta lista desde la pantalla con el resumen de tareas completadas. Una de cada cinco veces que se vuelva a esta lista de tareas debe mostrarse un anuncio intersticial. En la pantalla del resumen de tareas completadas debes poner un bot\u00f3n que abra una alerta para quitar los anuncios. Una vez que el usuario lo confirme dejar\u00e1n de mostrarse anuncios en la app.","title":"Pr\u00e1ctica 5: Anuncios (Opcional)"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html","text":"Pr\u00e1ctica 1: Firma, aprovisionamiento y distribuci\u00f3n de apps \u00b6 En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n los objetivos generales de esta pr\u00e1ctica: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA. Firmar y exportar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Configurar en la aplicaci\u00f3n una capacidad y seleccionar un perfil del equipo de desarrollo de la UA que permita esta capacidad. 1. Antes de empezar la clase presencial \u00b6 Antes de la clase presencial deber\u00e1s mirar los tres v\u00eddeos con demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n 1. Una vez vistas estas demostraciones, debes leer los siguientes apartados del tema de teor\u00eda: Introducci\u00f3n : Resumen de lo que vamos a ver en este tema e introducci\u00f3n breve a la importancia de la seguridad en la plataforma de Apple. Cuenta de desarrollador de Apple : Explicaci\u00f3n de los distintos tipo de programas de desarrollo en la plataforma Apple y caracter\u00edsticas de cada uno. Certificado de firma de apps : Explicaci\u00f3n del funcionamiento del certificado de desarrollador para la firma de apps. Una app s\u00f3lo puede instalarse en un dispositivo si ha sido previamente firmada con un certificado de un desarrollador registrado. Capacidades de las aps : Para usar las capacidades proporcionadas por la plataforma de desarrollo Apple es necesario configurar una autorizaci\u00f3n usando un App ID. Despliegue de apps : para desplegar una app en un dispositivo de prueba es necesario instalar en ella un perfil de aprovisionamiento que contenga los permisos para acceder a las capacidades y los dispositivos autorizados en los que la app puede instalarse. 2. Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo \u00b6 Deber\u00e1s crear un Apple ID y darte de alta como desarrollador. Si ya lo tienes, no hace falta que hagas nada. Para crear un Apple ID, puedes introducir tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . Accede a tu portal de desarrollador. Ser\u00e1 el portal del programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help Descarga la app ToDo . Y sigue los pasos de la demostraci\u00f3n para crear el certificado gratuito de desarrollador, cambiar el bundle ID de la app a un identificador tuyo, firmar la app, comprobar el certificado y probar la app en tu dispositivo de desarrollo (si lo tienes). Incluye tu nombre en la pantalla en la que aparece el n\u00famero de tareas terminadas (a la que se accede pulsando en el bot\u00f3n Done ). Captura la pantalla de Xcode en la que se muestra el bundle ID y el equipo que realiza la firma. Captura tambi\u00e9n una instant\u00e1nea con la app ejecut\u00e1ndose en el dispositivo mostrando la pantalla con tu nombre. Si no tienes dispositivo, hazlo con la ejecuci\u00f3n del simulador. Comprueba que aparece un error cuando intentas exportar la app. Captura la pantalla de Xcode. 2. Configuraci\u00f3n de la cuenta de desarrollador \u00b6 Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos, direcci\u00f3n de e-mail en este fichero Google Docs . Escribe tambi\u00e9n el ID del dispositivo (o dispositivos) que desees incorporar al portal del equipo de la UA. Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n entra en el portal del desarrollador , comprueba que ya est\u00e1s en el programa de la UA y prueba las distintas opciones disponibles. 3. Firma y despliegue de app con perfil de aprovisionamiento \u00b6 Sigue los pasos de la demo y ejercicio de teor\u00eda, realizando lo siguiente: Cambia el bundle ID y firma la app con el perfil gen\u00e9rico. Captura la pantalla de Xcode en la que se muestre. Comprueba que es posible exportar la app utilizando el perfil gen\u00e9rico. Captura la pantalla. Comprueba que aparece un error cuando intentas a\u00f1adir la capacidad Game Center usando el perfil gen\u00e9rico. Captura la pantalla. Comprueba en el portal del desarrollador de la UA que el profesor ha creado el App ID y el perfil de aprovisionamiento Master Moviles ToDo con la autorizaci\u00f3n para configurar en la app la capacidad Game Center . Captura las pantallas con las p\u00e1ginas del portal del desarrollador de la UA mostr\u00e1ndolos (incluye en las pantallas toda la ventana del navegador, para que aparezca tu usuario en la parte superior derecha). Instala en la app el perfil Master Moviles ToDo y a\u00f1ade la capacidad Game Center . Comprueba que Xcode no da ning\u00fan error y captura la pantalla. Exporta la app, creando un binario .ipa. Si tienes alg\u00fan dispositivo iOS, instala el fichero .ipa obtenido usando Apple Configurator 2. El UUID del dispositivo deber\u00e1 estar incluido en el perfil de aprovisionamiento. Captura una pantalla de la aplicaci\u00f3n Apple Configurator 2 instalando la app en el dispositivo. Comprueba que la app funciona correctamente. Entregas \u00b6 Crea una carpeta y guarda en ella lo siguiente: Todas las capturas de pantalla. Binario .ipa exportado en el \u00faltimo paso. Carpeta con el proyecto completo. Comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 .","title":"Pr\u00e1ctica 1"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#practica-1-firma-aprovisionamiento-y-distribucion-de-apps","text":"En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales. Resumimos a continuaci\u00f3n los objetivos generales de esta pr\u00e1ctica: Firmar una app con tu cuenta gratuita e instalarla en un dispositivo configurado como dispositivo de desarrollo. Darte de alta en el equipo de desarrollo de la UA. Firmar y exportar la app usando un perfil de aprovisionamiento que te permite instalarla en cualquier dispositivo autorizado en el perfil. Configurar en la aplicaci\u00f3n una capacidad y seleccionar un perfil del equipo de desarrollo de la UA que permita esta capacidad.","title":"Pr\u00e1ctica 1: Firma, aprovisionamiento y  distribuci\u00f3n de apps"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#1-antes-de-empezar-la-clase-presencial","text":"Antes de la clase presencial deber\u00e1s mirar los tres v\u00eddeos con demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n 1. Una vez vistas estas demostraciones, debes leer los siguientes apartados del tema de teor\u00eda: Introducci\u00f3n : Resumen de lo que vamos a ver en este tema e introducci\u00f3n breve a la importancia de la seguridad en la plataforma de Apple. Cuenta de desarrollador de Apple : Explicaci\u00f3n de los distintos tipo de programas de desarrollo en la plataforma Apple y caracter\u00edsticas de cada uno. Certificado de firma de apps : Explicaci\u00f3n del funcionamiento del certificado de desarrollador para la firma de apps. Una app s\u00f3lo puede instalarse en un dispositivo si ha sido previamente firmada con un certificado de un desarrollador registrado. Capacidades de las aps : Para usar las capacidades proporcionadas por la plataforma de desarrollo Apple es necesario configurar una autorizaci\u00f3n usando un App ID. Despliegue de apps : para desplegar una app en un dispositivo de prueba es necesario instalar en ella un perfil de aprovisionamiento que contenga los permisos para acceder a las capacidades y los dispositivos autorizados en los que la app puede instalarse.","title":"1. Antes de empezar la clase presencial"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#2-firma-e-instalacion-de-una-app-en-un-dispositivo-de-desarrollo","text":"Deber\u00e1s crear un Apple ID y darte de alta como desarrollador. Si ya lo tienes, no hace falta que hagas nada. Para crear un Apple ID, puedes introducir tus datos en este enlace . Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador. Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com/register/ . Accede a tu portal de desarrollador. Ser\u00e1 el portal del programa gratuito. Este programa permite acceder a las herramientas de desarrollo, la documentaci\u00f3n y acceso limitado a ciertas capacidades (incluido probar aplicaciones en dispositivos conectados a Xcode). Explora las distintas opciones que permite la cuenta: Documentation Downloads Forums Bug reporter Help Descarga la app ToDo . Y sigue los pasos de la demostraci\u00f3n para crear el certificado gratuito de desarrollador, cambiar el bundle ID de la app a un identificador tuyo, firmar la app, comprobar el certificado y probar la app en tu dispositivo de desarrollo (si lo tienes). Incluye tu nombre en la pantalla en la que aparece el n\u00famero de tareas terminadas (a la que se accede pulsando en el bot\u00f3n Done ). Captura la pantalla de Xcode en la que se muestra el bundle ID y el equipo que realiza la firma. Captura tambi\u00e9n una instant\u00e1nea con la app ejecut\u00e1ndose en el dispositivo mostrando la pantalla con tu nombre. Si no tienes dispositivo, hazlo con la ejecuci\u00f3n del simulador. Comprueba que aparece un error cuando intentas exportar la app. Captura la pantalla de Xcode.","title":"2. Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#2-configuracion-de-la-cuenta-de-desarrollador","text":"Para la inscripci\u00f3n en el equipo de desarrollo de la universidad escribe tu nombre, apellidos, direcci\u00f3n de e-mail en este fichero Google Docs . Escribe tambi\u00e9n el ID del dispositivo (o dispositivos) que desees incorporar al portal del equipo de la UA. Una vez que te a\u00f1adamos al equipo de la UA recibir\u00e1s en el correo electr\u00f3nico un mensaje con un c\u00f3digo de invitaci\u00f3n. Pincha en \u00e9l e introduce all\u00ed tu Apple ID. Una vez aceptada la invitaci\u00f3n entra en el portal del desarrollador , comprueba que ya est\u00e1s en el programa de la UA y prueba las distintas opciones disponibles.","title":"2. Configuraci\u00f3n de la cuenta de desarrollador"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#3-firma-y-despliegue-de-app-con-perfil-de-aprovisionamiento","text":"Sigue los pasos de la demo y ejercicio de teor\u00eda, realizando lo siguiente: Cambia el bundle ID y firma la app con el perfil gen\u00e9rico. Captura la pantalla de Xcode en la que se muestre. Comprueba que es posible exportar la app utilizando el perfil gen\u00e9rico. Captura la pantalla. Comprueba que aparece un error cuando intentas a\u00f1adir la capacidad Game Center usando el perfil gen\u00e9rico. Captura la pantalla. Comprueba en el portal del desarrollador de la UA que el profesor ha creado el App ID y el perfil de aprovisionamiento Master Moviles ToDo con la autorizaci\u00f3n para configurar en la app la capacidad Game Center . Captura las pantallas con las p\u00e1ginas del portal del desarrollador de la UA mostr\u00e1ndolos (incluye en las pantallas toda la ventana del navegador, para que aparezca tu usuario en la parte superior derecha). Instala en la app el perfil Master Moviles ToDo y a\u00f1ade la capacidad Game Center . Comprueba que Xcode no da ning\u00fan error y captura la pantalla. Exporta la app, creando un binario .ipa. Si tienes alg\u00fan dispositivo iOS, instala el fichero .ipa obtenido usando Apple Configurator 2. El UUID del dispositivo deber\u00e1 estar incluido en el perfil de aprovisionamiento. Captura una pantalla de la aplicaci\u00f3n Apple Configurator 2 instalando la app en el dispositivo. Comprueba que la app funciona correctamente.","title":"3. Firma y despliegue de app con perfil de aprovisionamiento"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#entregas","text":"Crea una carpeta y guarda en ella lo siguiente: Todas las capturas de pantalla. Binario .ipa exportado en el \u00faltimo paso. Carpeta con el proyecto completo. Comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1 .","title":"Entregas"},{"location":"practicas/extesiones/extensiones.html","text":"Pr\u00e1ctica 5: Extensiones \u00b6 Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y nombre del \u00faltimo de ellos. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA. Parte opcional Implementa una vista ampliada de la extensi\u00f3n que permita al usuario ver m\u00e1s datos de la lista de tareas por hacer.","title":"Pr\u00e1ctica 5: Extensiones"},{"location":"practicas/extesiones/extensiones.html#practica-5-extensiones","text":"Implementar una extensi\u00f3n Today en la app ToDoList. En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de \u00edtems completados y nombre del \u00faltimo de ellos. Para comunicar los datos entre la app y la extensi\u00f3n debes usar el UserDefaults compartido en el grupo de apps. Puedes consultar los nombres del grupo de apps y de los bundle identifiers asociados a los App Ids en el member center de la UA. Parte opcional Implementa una vista ampliada de la extensi\u00f3n que permita al usuario ver m\u00e1s datos de la lista de tareas por hacer.","title":"Pr\u00e1ctica 5: Extensiones"},{"location":"practicas/icloud/icloud.html","text":"Pr\u00e1ctica 4: iCloud y CloudKit \u00b6 Seguimos trabajando con el proyecto ToDo y el bundle ID es.ua.mastermoviles.ToDo y el perfil de aprovisionamiento Master Moviles ToDo (lo hemos actualizado para que incluya el permiso de acceso a CloudKit y al contenedor iCloud.es.ua.mastermoviles.ToDo ). Actualiza en Xcode el permiso para utilizar iCloud, con clave-valor y con CloudKit. iCloud clave-valor \u00b6 Modifica la app ToDo para que el n\u00famero de \u00edtems terminados se guarde en iCloud del usuario, usando iCloud clave-valor. ToDo en CloudKit \u00b6 A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. En el contenedor de CloudKit se ha a\u00f1adido el tipo de registro Tarea con el campo texto con los \u00edndices Queryable , Searchable , Sortable . ( Opcional ): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Al a\u00f1adir una tarea debes permitir la opci\u00f3n de hacerlo en la base de datos p\u00fablica. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas. ( Opcional ): A\u00f1ade una funcionalidad en la que se recargue la tabla con los datos de iCloud cuando se tire de la tabla hacia abajo. Pista para actualizar la tabla \u00b6 Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoTableViewController : DispatchQueue . main . async ( execute : { self . tableView . reloadData () })","title":"Pr\u00e1ctica 4"},{"location":"practicas/icloud/icloud.html#practica-4-icloud-y-cloudkit","text":"Seguimos trabajando con el proyecto ToDo y el bundle ID es.ua.mastermoviles.ToDo y el perfil de aprovisionamiento Master Moviles ToDo (lo hemos actualizado para que incluya el permiso de acceso a CloudKit y al contenedor iCloud.es.ua.mastermoviles.ToDo ). Actualiza en Xcode el permiso para utilizar iCloud, con clave-valor y con CloudKit.","title":"Pr\u00e1ctica 4: iCloud y CloudKit"},{"location":"practicas/icloud/icloud.html#icloud-clave-valor","text":"Modifica la app ToDo para que el n\u00famero de \u00edtems terminados se guarde en iCloud del usuario, usando iCloud clave-valor.","title":"iCloud clave-valor"},{"location":"practicas/icloud/icloud.html#todo-en-cloudkit","text":"A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes se guarden y recuperen de la base de datos privada de CloudKit. En el contenedor de CloudKit se ha a\u00f1adido el tipo de registro Tarea con el campo texto con los \u00edndices Queryable , Searchable , Sortable . ( Opcional ): Utiliza la base de datos p\u00fablica para publicar tareas compartidas por todos los usuarios de la app. Al a\u00f1adir una tarea debes permitir la opci\u00f3n de hacerlo en la base de datos p\u00fablica. Muestra el texto de las tareas p\u00fablicas en un color diferente en el listado de tareas. ( Opcional ): A\u00f1ade una funcionalidad en la que se recargue la tabla con los datos de iCloud cuando se tire de la tabla hacia abajo.","title":"ToDo en CloudKit"},{"location":"practicas/icloud/icloud.html#pista-para-actualizar-la-tabla","text":"Los callbacks en los que se reciben los resultados de las queries son as\u00edncronos y se procesan en hilos secundarios. Si actualizamos los datos de la tabla en un callback de este tipo, la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no interact\u00fae con la tabla. Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en el hijo principal con este c\u00f3digo en alg\u00fan lugar del ToDoTableViewController : DispatchQueue . main . async ( execute : { self . tableView . reloadData () })","title":"Pista para actualizar la tabla"},{"location":"practicas/mapas/mapas-localizacion.html","text":"Pr\u00e1ctica 2: Mapas y localizaci\u00f3n \u00b6 Lee los siguientes apartados de los apuntes de teor\u00eda : desde Aspectos b\u00e1sicos de MapKit hasta Uso del delegado (incluido). Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incl\u00fayelo en un Navigation Controller con la opci\u00f3n Editor > Embed In > Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control. Lee los siguientes apartados apuntes de teor\u00eda : desde Anotaciones hasta Elementos en el callout (incluido). En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa. A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n. Parte opcional 1 Implementa un segue que haga aparecer otra vista con un detalle de la foto. Puedes definir un segue haciendo control click desde un view controller hasta otro. Despu\u00e9s debes dar un identificador al segue. Por ejemplo DetalleImagen . Parte opcional 2 Lee los siguientes apartados de los apuntes de teor\u00eda : desde Geocoding hasta Conversi\u00f3n de placemarks en localizaciones (incluido). Implementa una llamada al servicio de geolocalizaci\u00f3n que coloque como subt\u00edtulo del Pin el pa\u00eds en el que se ha colocado el mismo. Parte opcional 3 Lee el siguiente apartado de los apuntes de teor\u00eda : Localizaci\u00f3n . A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) ) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Si la anotaci\u00f3n que se quiere mostrar no es de tipo Pin debes poner la vista a nil para que se use la vista por defecto (el c\u00edrculo). Comprime el proyecto y entr\u00e9galo en la entrega correspondiente de Moodle.","title":"Pr\u00e1ctica 2"},{"location":"practicas/mapas/mapas-localizacion.html#practica-2-mapas-y-localizacion","text":"Lee los siguientes apartados de los apuntes de teor\u00eda : desde Aspectos b\u00e1sicos de MapKit hasta Uso del delegado (incluido). Debes crear la app es.ua.mastermoviles.Mapas . Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incl\u00fayelo en un Navigation Controller con la opci\u00f3n Editor > Embed In > Navigation Controller . A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores Mapa y Sat\u00e9lite , con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control. Lee los siguientes apartados apuntes de teor\u00eda : desde Anotaciones hasta Elementos en el callout (incluido). En el Storyboard a\u00f1ade un Bar Button Item en la parte derecha de la barra de navegaci\u00f3n. Ll\u00e1malo Pin y enl\u00e1zalo con una acci\u00f3n en el ViewController que a\u00f1ada una anotaci\u00f3n en el mapa. A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar. A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n. Parte opcional 1 Implementa un segue que haga aparecer otra vista con un detalle de la foto. Puedes definir un segue haciendo control click desde un view controller hasta otro. Despu\u00e9s debes dar un identificador al segue. Por ejemplo DetalleImagen . Parte opcional 2 Lee los siguientes apartados de los apuntes de teor\u00eda : desde Geocoding hasta Conversi\u00f3n de placemarks en localizaciones (incluido). Implementa una llamada al servicio de geolocalizaci\u00f3n que coloque como subt\u00edtulo del Pin el pa\u00eds en el que se ha colocado el mismo. Parte opcional 3 Lee el siguiente apartado de los apuntes de teor\u00eda : Localizaci\u00f3n . A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador. A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n. Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n actual del dispositivo. Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una anotaci\u00f3n ( mapView(_:viewFor:) ) porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Si la anotaci\u00f3n que se quiere mostrar no es de tipo Pin debes poner la vista a nil para que se use la vista por defecto (el c\u00edrculo). Comprime el proyecto y entr\u00e9galo en la entrega correspondiente de Moodle.","title":"Pr\u00e1ctica 2: Mapas y localizaci\u00f3n"},{"location":"practicas/notificaciones/notificaciones.html","text":"Pr\u00e1ctica 3: Notificaciones \u00b6 Descarga las apps Notificaciones y NotificacionesPush , revisa su c\u00f3digo y sus permisos y pru\u00e9balas. La primera puedes probarla en el simulador. La segunda deber\u00e1s probarla ejecut\u00e1ndola en un dispositivo real y enviando notificaciones remotas tal y como hemos hecho en la demo. Ejercicio 1: Modifica la app ToDoList para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2 (para los que no tienen dispositivo f\u00edsico iOS): Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3 (para los que tienen dispositivo f\u00edsico iOS): A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n silenciosa enviada con una notificaci\u00f3n push. Utiliza el script PHP y este certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas.","title":"Pr\u00e1ctica 3"},{"location":"practicas/notificaciones/notificaciones.html#practica-3-notificaciones","text":"Descarga las apps Notificaciones y NotificacionesPush , revisa su c\u00f3digo y sus permisos y pru\u00e9balas. La primera puedes probarla en el simulador. La segunda deber\u00e1s probarla ejecut\u00e1ndola en un dispositivo real y enviando notificaciones remotas tal y como hemos hecho en la demo. Ejercicio 1: Modifica la app ToDoList para que genere notificaciones locales. En la app ToDoList puedes hacerlo con un bot\u00f3n en la pantalla con el n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el intervalo de 10 segundos que contenga alguna imagen y acciones. Y visualizar la acci\u00f3n que el usuario ha realizado sobre la notificaci\u00f3n, lanzando una alerta la siguiente vez que se abra la app que informe de la acci\u00f3n escogida. Ejercicio 2 (para los que no tienen dispositivo f\u00edsico iOS): Implementa una notificaci\u00f3n basada en el calendario, en la que dejes al usuario seleccionar la hora y minuto en la que aparezca una notificaci\u00f3n informando del n\u00famero de tareas terminadas. Ejercicio 3 (para los que tienen dispositivo f\u00edsico iOS): A\u00f1ade la posiblidad de a\u00f1adir una nueva tarea en la lista de tareas pendientes mediante una notificaci\u00f3n silenciosa enviada con una notificaci\u00f3n push. Utiliza el script PHP y este certificado para generar la notificaci\u00f3n. Deber\u00e1s utilizar un dispositivo real para realizar las pruebas. Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas.","title":"Pr\u00e1ctica 3: Notificaciones"},{"location":"teoria/anuncios/anuncios.html","text":"Anuncios y compras In-App \u00b6 Anuncios \u00b6 Redes de anuncios \u00b6 x Hasta 2016 Apple hab\u00eda explotado iAD, una red de anuncios propia, con su propia API, orientada espec\u00edficamente a apps iOS. Durante varios a\u00f1os hab\u00eda intentado competir con las redes m\u00e1s populares como AdMob (Google). Al final no consigui\u00f3 destacar y la red se cerr\u00f3 en junio de 2016. Desde entonces los desarrolladores iOS tienen que escoger entre distintas redes existentes: AdMob (Google) Unity Ads Facebook Ads Amazon Ads Cada red tiene su propia API, aunque son todas ellas muy similares. API de AdMob \u00b6 Vamos a ver la red AdMob de Google , por ser la m\u00e1s popular. Vamos a explicar AdMob sin Firebase , para hacer m\u00e1s ligera la app y tener que depender del n\u00famero m\u00ednimo de librer\u00edas. Alta en AdMob \u00b6 Lo primero que tenemos que hacer para probar los anuncios y el API de AdMob es crear una cuenta de AdMob y registrar una aplicaci\u00f3n . Una vez dado de alta y creada la aplicaci\u00f3n, tendr\u00e1s un n\u00famero de registro de la aplicaci\u00f3n del estilo ca-app-pub-6502933536055889~6323740433 Puedes encontrar tu ID de aplicaci\u00f3n en la interfaz de AdMob. Importar el SDK de anuncios para m\u00f3viles \u00b6 La forma m\u00e1s sencilla de importar el SDK a un proyecto iOS es mediante CocoaPods . Utilizando la instalaci\u00f3n de Ruby que viene por defecto en MacOS para instalar CocoaPods basta con hacer: $ sudo gem install cocoapods Supongamos que vamos a trabajar con la app ToDoList. En el directorio ra\u00edz del proyecto debes crear el fichero Podfile , con el contenido: target 'ToDoList' do pod 'Google-Mobile-Ads-SDK' end Despu\u00e9s, desde l\u00ednea de comando y estando en el directorio ra\u00edz del proyecto, debes ejecutar: $ pod install --repo-update Se descargar\u00e1n las librer\u00edas necesarias y se crear\u00e1 un fichero ToDoList.xcworkspace que es el que debes abrir con Xcode. Al abrir este fichero Xcode abrir\u00e1 una configuraci\u00f3n de workspace en la que pueden existir m\u00e1s de un proyecto. Es la configuraci\u00f3n que se usa para trabajar con CocoaPods. Actualizar el fichero Info.plist \u00b6 A\u00f1ade una clave GADApplicationIdentifier con un valor de cadena igual a tu ID de aplicaci\u00f3n de AdMob al archivo Info.plist de tu aplicaci\u00f3n. Puedes encontrar tu ID de la aplicaci\u00f3n en la interfaz de AdMob. Puedes hacerlo editando el fichero: <key> GADApplicationIdentifier </key> <string> ca-app-pub-6502933536055889~6323740433 </string> O usando la interfaz de Xcode: Inicializaci\u00f3n del API \u00b6 Antes de cargar anuncios, debemos inicializar el SDK de anuncios de Google para m\u00f3viles llamando al m\u00e9todo start(ompletionHandler:) de GADMobileAds.sharedInstance() , que inicializa el SDK y hace una retrollamada al controlador de finalizaci\u00f3n una vez que la inicializaci\u00f3n se ha completado, o bien despu\u00e9s de un tiempo de espera de 30 segundos. Solo es necesario hacerlo una vez, preferiblemente al iniciar la aplicaci\u00f3n. La llamada debe realizarse lo m\u00e1s pronto posible. A continuaci\u00f3n, tienes un ejemplo de c\u00f3mo llamar al m\u00e9todo startWithCompletionHandler: en tu AppDelegate: Ejemplo de AppDelegate.swift (fragmento) import GoogleMobileAds @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. GADMobileAds . sharedInstance (). start ( completionHandler : nil ) return true } } Selecci\u00f3n del formato de anuncio \u00b6 Tras importar e inicializar el SDK de anuncios para m\u00f3viles, podemos descargar un anuncio. AdMob ofrece diversos formatos de anuncios, y debemos elegir uno de ellos, el que mejor se ajuste a la experiencia de los usuarios de nuesra aplicaci\u00f3n. Dos de los m\u00e1s usados son de tipo banner y de tipo interstiticial . Banner Los anuncios de banner son anuncios rectangulares de imagen o de texto que ocupan parte de la pantalla de una aplicaci\u00f3n. Permanecen en pantalla mientras los usuarios interact\u00faan con la aplicaci\u00f3n y pueden actualizarse autom\u00e1ticamente despu\u00e9s de un cierto periodo de tiempo. Si es la primera vez que utilizamos la publicidad para m\u00f3viles, son un excelente punto de partida. Existen distintos tama\u00f1os de banners, que podemos seleccionar con su identificador: Tama\u00f1o Descripci\u00f3n Disponibilidad Identificador 320x50 Banner Tel\u00e9fonos y tablets kGADAdSizeBanner 320x100 Banner grande Tel\u00e9fonos y tablets kGADAdSizeLargeBanner 300x250 Rect\u00e1ngulo mediano Tel\u00e9fonos y tablets kGADAdSizeMediumRectangle 468x60 Banner de tama\u00f1o completo Tablets kGADAdSizeFullBanner 728x90 Leaderboard Tablets kGADAdSizeLeaderboard Intersticial Los intersticiales son anuncios que ocupan toda la pantalla y cubren la interfaz de una aplicaci\u00f3n hasta que el usuario los cierra. El mejor momento para usarlos son las pausas naturales de una aplicaci\u00f3n. Por ejemplo, al pasar de un nivel a otro en un juego o despu\u00e9s de completar una tarea. Veamos el c\u00f3digo para implementar un anuncio de cada uno de estos tipos. Implementaci\u00f3n de un banner \u00b6 Cuando probemos las aplicaciones debemos usar siempre anuncios de prueba en lugar de anuncios reales. De lo contrario, Google podr\u00eda suspender nuestra cuenta de AdMob. La forma m\u00e1s sencilla de cargar anuncios de prueba es mediante el ID de bloque de anuncios de prueba que Google ha creado para banners de iOS: ca-app-pub-3940256099942544/2934735716 . Cuando publiquemos la app s\u00f3lo hay que sustituir este ID por el ID real. Los anuncios de banner se muestran en objetos GADBannerView , por lo que lo primero que debemos hacer para integrarlos es incluir un objeto GADBannerView en nuestra jerarqu\u00eda de vistas. Debemos actualizar las propiedades de este objeto: rootViewController : controlador de vistas que se utiliza para mostrar una superposici\u00f3n cuando se hace clic en el anuncio. Como valor, normalmente se le da el controlador que contiene el GADBannerView . adUnitID : el objeto GADBannerView debe cargar anuncios procedentes de este ID de bloque de anuncios. delegate : delegado que implementa el protocolo GADBannerViewDelegate que define las funciones en las que se reciben los eventos del ciclo de vida de los anuncios. Tras configurar el GADBannerView y sus propiedades podemos cargar un anuncio. Para ello, se llama al m\u00e9todo loadRequest pasando un objeto GADRequest . Por ejemplo, el siguiente c\u00f3digo crea un objeto GADBannerView de tama\u00f1o 320x50 e inicializa las propiedades anteriores: import UIKit import GoogleMobileAds class ViewController : UIViewController , GADBannerViewDelegate { var bannerView : GADBannerView ! override func viewDidLoad () { super . viewDidLoad () bannerView = GADBannerView ( adSize : kGADAdSizeBanner ) bannerView . adUnitID = \"ca-app-pub-3940256099942544/2934735716\" bannerView . rootViewController = self bannerView . load ( GADRequest ()) bannerView . delegate = self } ... } En el siguiente m\u00e9todo addBannerViewToView(_:) se a\u00f1ade la vista del anuncio, aline\u00e1ndose con la parte inferior del \u00e1rea segura de pantalla: func addBannerViewToView ( _ bannerView : GADBannerView ) { bannerView . translatesAutoresizingMaskIntoConstraints = false view . addSubview ( bannerView ) view . addConstraints ( [ NSLayoutConstraint ( item : bannerView , attribute : . bottom , relatedBy : . equal , toItem : view . safeAreaLayoutGuide , attribute : . bottom , multiplier : 1 , constant : 0 ), NSLayoutConstraint ( item : bannerView , attribute : . centerX , relatedBy : . equal , toItem : view , attribute : . centerX , multiplier : 1 , constant : 0 ) ]) } Por \u00faltimo, es recomendable realizar la llamada a la funci\u00f3n anterior que incorpora el GADBannerView a la jerarqu\u00eda de vistas despu\u00e9s de haber recibido un anuncio. Para ello, se usa la funci\u00f3n del delegado adViewDidReceiveAd : /// Tells the delegate an ad request loaded an ad. func adViewDidReceiveAd ( _ bannerView : GADBannerView ) { print ( \"adViewDidReceiveAd\" ) addBannerViewToView ( bannerView ) } Podemos implementar el resto de funciones del delegado, con sentencias print para depurar cuando se produce cada evento: /// Tells the delegate an ad request failed. func adView ( _ bannerView : GADBannerView , didFailToReceiveAdWithError error : GADRequestError ) { print ( \"adView:didFailToReceiveAdWithError: \\( error . localizedDescription ) \" ) } /// Tells the delegate that a full-screen view will be presented in response /// to the user clicking on an ad. func adViewWillPresentScreen ( _ bannerView : GADBannerView ) { print ( \"adViewWillPresentScreen\" ) } /// Tells the delegate that the full-screen view will be dismissed. func adViewWillDismissScreen ( _ bannerView : GADBannerView ) { print ( \"adViewWillDismissScreen\" ) } /// Tells the delegate that the full-screen view has been dismissed. func adViewDidDismissScreen ( _ bannerView : GADBannerView ) { print ( \"adViewDidDismissScreen\" ) } /// Tells the delegate that a user click will open another app (such as /// the App Store), backgrounding the current app. func adViewWillLeaveApplication ( _ bannerView : GADBannerView ) { print ( \"adViewWillLeaveApplication\" ) } Implementaci\u00f3n de un interstitial \u00b6 Los anuncios intersticiales los solicitan y muestran los objetos GADInterstitial . Debemos crear una instancia y asignar el ID de su bloque de anuncios. Podemos cargar anuncios de prueba de tipo Interstitial usando el ID ca-app-pub-3940256099942544/4411468910 . Por ejemplo, aqu\u00ed se muestra c\u00f3mo crear un GADInterstitial en el m\u00e9todo viewDidLoad de un UIViewController . Hacemos tambi\u00e9n que el interstitial lance una petici\u00f3n para cargar una anuncio, y definimos como delegado el view controller . Para ello el view controller debe cumplir el protocolo GADInterstitialDelegate . import UIKit import GoogleMobileAds class ViewController : UIViewController , GADInterstitialDelegate { var interstitial : GADInterstitial ! override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. interstitial = GADInterstitial ( adUnitID : \"ca-app-pub-3940256099942544/4411468910\" ) interstitial . load ( GADRequest ()) interstitial . delegate = self } ... } GADInterstitial es un objeto de un solo uso que, al cargarse, muestra un anuncio intersticial. Para que una aplicaci\u00f3n muestre varios anuncios intersticiales, es necesario crear un GADInterstitial para cada uno de ellos (lo veremos m\u00e1s adelante). Para mostrar un intersticial, podemos verificar la propiedad isReady en GADInterstitial para asegurarnos de que ha terminado de cargarse y, despu\u00e9s, debemos llamar a presentFromRootViewController pas\u00e1ndole el view controller actual como view controller ra\u00edz: ... if interstitial . isReady { interstitial . present ( fromRootViewController : self ) } else { print ( \"El anuncio no est\u00e1 disponible\" ) } } Al igual que hac\u00edamos en el banner podemos realizar esta llamada en la funci\u00f3n del delegado interstitialDidReceiveAd : /// Tells the delegate an ad request succeeded. func interstitialDidReceiveAd ( _ ad : GADInterstitial ) { print ( \"interstitialDidReceiveAd\" ) interstitial . present ( fromRootViewController : self ) } El resto de funciones del delegado son las siguientes: /// Tells the delegate an ad request failed. func interstitial ( _ ad : GADInterstitial , didFailToReceiveAdWithError error : GADRequestError ) { print ( \"interstitial:didFailToReceiveAdWithError: \\( error . localizedDescription ) \" ) } /// Tells the delegate that an interstitial will be presented. func interstitialWillPresentScreen ( _ ad : GADInterstitial ) { print ( \"interstitialWillPresentScreen\" ) } /// Tells the delegate the interstitial is to be animated off the screen. func interstitialWillDismissScreen ( _ ad : GADInterstitial ) { print ( \"interstitialWillDismissScreen\" ) } /// Tells the delegate the interstitial had been animated off the screen. func interstitialDidDismissScreen ( _ ad : GADInterstitial ) { print ( \"interstitialDidDismissScreen\" ) } /// Tells the delegate that a user click will open another app /// (such as the App Store), backgrounding the current app. func interstitialWillLeaveApplication ( _ ad : GADInterstitial ) { print ( \"interstitialWillLeaveApplication\" ) } Tal y como hemos comentado el GADInterstitial es un objeto de un solo uso. Eso significa que una vez que se muestra un intersticial, hasBeenUsed devuelve el valor true y el intersticial no se puede usar para cargar otro anuncio. Para solicitar otro, deberemos crear un nuevo objeto GADInterstitial . Si intentamos reutilizar un objeto intersticial, aparecer\u00e1 el mensaje \"Request Error: Will not send request because interstitial object has been used\" El mejor lugar para asignar otro intersticial es en el m\u00e9todo interstitialDidDismissScreen del delegado GADInterstitialDelegate , para que el siguiente intersticial comience a cargarse tan pronto como se cierre el anterior. Podemos refactorizar la creaci\u00f3n del interstiticial en una funci\u00f3n aparte, y llamar a esa funci\u00f3n desde viewDidLoad y desde interstitialDidDismissScreen : override func viewDidLoad () { super . viewDidLoad () interstitial = createAndLoadInterstitial () } func createAndLoadInterstitial () -> GADInterstitial { var interstitial = GADInterstitial ( adUnitID : \"ca-app-pub-3940256099942544/4411468910\" ) interstitial . delegate = self interstitial . load ( GADRequest ()) return interstitial } func interstitialDidDismissScreen ( _ ad : GADInterstitial ) { interstitial = createAndLoadInterstitial () } Demo: Aplicaci\u00f3n de prueba \u00b6 Puedes descargarte una aplicaci\u00f3n de prueba en la que se muestra el funcionamiento b\u00e1sico de AdMob. Se debe ejecutar la app en un dispositivo real, ya que AdMob no funciona en el simulador. Tambi\u00e9n debes darte de alta en AdMob, registrar una aplicaci\u00f3n e incluir el n\u00famero de registro en el fichero Info.plist . Referencias \u00b6 Google AdMob SDK para iOS","title":"5. Anuncios"},{"location":"teoria/anuncios/anuncios.html#anuncios-y-compras-in-app","text":"","title":"Anuncios y compras In-App"},{"location":"teoria/anuncios/anuncios.html#anuncios","text":"","title":"Anuncios"},{"location":"teoria/anuncios/anuncios.html#redes-de-anuncios","text":"x Hasta 2016 Apple hab\u00eda explotado iAD, una red de anuncios propia, con su propia API, orientada espec\u00edficamente a apps iOS. Durante varios a\u00f1os hab\u00eda intentado competir con las redes m\u00e1s populares como AdMob (Google). Al final no consigui\u00f3 destacar y la red se cerr\u00f3 en junio de 2016. Desde entonces los desarrolladores iOS tienen que escoger entre distintas redes existentes: AdMob (Google) Unity Ads Facebook Ads Amazon Ads Cada red tiene su propia API, aunque son todas ellas muy similares.","title":"Redes de anuncios"},{"location":"teoria/anuncios/anuncios.html#api-de-admob","text":"Vamos a ver la red AdMob de Google , por ser la m\u00e1s popular. Vamos a explicar AdMob sin Firebase , para hacer m\u00e1s ligera la app y tener que depender del n\u00famero m\u00ednimo de librer\u00edas.","title":"API de AdMob"},{"location":"teoria/anuncios/anuncios.html#alta-en-admob","text":"Lo primero que tenemos que hacer para probar los anuncios y el API de AdMob es crear una cuenta de AdMob y registrar una aplicaci\u00f3n . Una vez dado de alta y creada la aplicaci\u00f3n, tendr\u00e1s un n\u00famero de registro de la aplicaci\u00f3n del estilo ca-app-pub-6502933536055889~6323740433 Puedes encontrar tu ID de aplicaci\u00f3n en la interfaz de AdMob.","title":"Alta en AdMob"},{"location":"teoria/anuncios/anuncios.html#importar-el-sdk-de-anuncios-para-moviles","text":"La forma m\u00e1s sencilla de importar el SDK a un proyecto iOS es mediante CocoaPods . Utilizando la instalaci\u00f3n de Ruby que viene por defecto en MacOS para instalar CocoaPods basta con hacer: $ sudo gem install cocoapods Supongamos que vamos a trabajar con la app ToDoList. En el directorio ra\u00edz del proyecto debes crear el fichero Podfile , con el contenido: target 'ToDoList' do pod 'Google-Mobile-Ads-SDK' end Despu\u00e9s, desde l\u00ednea de comando y estando en el directorio ra\u00edz del proyecto, debes ejecutar: $ pod install --repo-update Se descargar\u00e1n las librer\u00edas necesarias y se crear\u00e1 un fichero ToDoList.xcworkspace que es el que debes abrir con Xcode. Al abrir este fichero Xcode abrir\u00e1 una configuraci\u00f3n de workspace en la que pueden existir m\u00e1s de un proyecto. Es la configuraci\u00f3n que se usa para trabajar con CocoaPods.","title":"Importar el SDK de anuncios para m\u00f3viles"},{"location":"teoria/anuncios/anuncios.html#actualizar-el-fichero-infoplist","text":"A\u00f1ade una clave GADApplicationIdentifier con un valor de cadena igual a tu ID de aplicaci\u00f3n de AdMob al archivo Info.plist de tu aplicaci\u00f3n. Puedes encontrar tu ID de la aplicaci\u00f3n en la interfaz de AdMob. Puedes hacerlo editando el fichero: <key> GADApplicationIdentifier </key> <string> ca-app-pub-6502933536055889~6323740433 </string> O usando la interfaz de Xcode:","title":"Actualizar el fichero Info.plist"},{"location":"teoria/anuncios/anuncios.html#inicializacion-del-api","text":"Antes de cargar anuncios, debemos inicializar el SDK de anuncios de Google para m\u00f3viles llamando al m\u00e9todo start(ompletionHandler:) de GADMobileAds.sharedInstance() , que inicializa el SDK y hace una retrollamada al controlador de finalizaci\u00f3n una vez que la inicializaci\u00f3n se ha completado, o bien despu\u00e9s de un tiempo de espera de 30 segundos. Solo es necesario hacerlo una vez, preferiblemente al iniciar la aplicaci\u00f3n. La llamada debe realizarse lo m\u00e1s pronto posible. A continuaci\u00f3n, tienes un ejemplo de c\u00f3mo llamar al m\u00e9todo startWithCompletionHandler: en tu AppDelegate: Ejemplo de AppDelegate.swift (fragmento) import GoogleMobileAds @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. GADMobileAds . sharedInstance (). start ( completionHandler : nil ) return true } }","title":"Inicializaci\u00f3n del API"},{"location":"teoria/anuncios/anuncios.html#seleccion-del-formato-de-anuncio","text":"Tras importar e inicializar el SDK de anuncios para m\u00f3viles, podemos descargar un anuncio. AdMob ofrece diversos formatos de anuncios, y debemos elegir uno de ellos, el que mejor se ajuste a la experiencia de los usuarios de nuesra aplicaci\u00f3n. Dos de los m\u00e1s usados son de tipo banner y de tipo interstiticial . Banner Los anuncios de banner son anuncios rectangulares de imagen o de texto que ocupan parte de la pantalla de una aplicaci\u00f3n. Permanecen en pantalla mientras los usuarios interact\u00faan con la aplicaci\u00f3n y pueden actualizarse autom\u00e1ticamente despu\u00e9s de un cierto periodo de tiempo. Si es la primera vez que utilizamos la publicidad para m\u00f3viles, son un excelente punto de partida. Existen distintos tama\u00f1os de banners, que podemos seleccionar con su identificador: Tama\u00f1o Descripci\u00f3n Disponibilidad Identificador 320x50 Banner Tel\u00e9fonos y tablets kGADAdSizeBanner 320x100 Banner grande Tel\u00e9fonos y tablets kGADAdSizeLargeBanner 300x250 Rect\u00e1ngulo mediano Tel\u00e9fonos y tablets kGADAdSizeMediumRectangle 468x60 Banner de tama\u00f1o completo Tablets kGADAdSizeFullBanner 728x90 Leaderboard Tablets kGADAdSizeLeaderboard Intersticial Los intersticiales son anuncios que ocupan toda la pantalla y cubren la interfaz de una aplicaci\u00f3n hasta que el usuario los cierra. El mejor momento para usarlos son las pausas naturales de una aplicaci\u00f3n. Por ejemplo, al pasar de un nivel a otro en un juego o despu\u00e9s de completar una tarea. Veamos el c\u00f3digo para implementar un anuncio de cada uno de estos tipos.","title":"Selecci\u00f3n del formato de anuncio"},{"location":"teoria/anuncios/anuncios.html#implementacion-de-un-banner","text":"Cuando probemos las aplicaciones debemos usar siempre anuncios de prueba en lugar de anuncios reales. De lo contrario, Google podr\u00eda suspender nuestra cuenta de AdMob. La forma m\u00e1s sencilla de cargar anuncios de prueba es mediante el ID de bloque de anuncios de prueba que Google ha creado para banners de iOS: ca-app-pub-3940256099942544/2934735716 . Cuando publiquemos la app s\u00f3lo hay que sustituir este ID por el ID real. Los anuncios de banner se muestran en objetos GADBannerView , por lo que lo primero que debemos hacer para integrarlos es incluir un objeto GADBannerView en nuestra jerarqu\u00eda de vistas. Debemos actualizar las propiedades de este objeto: rootViewController : controlador de vistas que se utiliza para mostrar una superposici\u00f3n cuando se hace clic en el anuncio. Como valor, normalmente se le da el controlador que contiene el GADBannerView . adUnitID : el objeto GADBannerView debe cargar anuncios procedentes de este ID de bloque de anuncios. delegate : delegado que implementa el protocolo GADBannerViewDelegate que define las funciones en las que se reciben los eventos del ciclo de vida de los anuncios. Tras configurar el GADBannerView y sus propiedades podemos cargar un anuncio. Para ello, se llama al m\u00e9todo loadRequest pasando un objeto GADRequest . Por ejemplo, el siguiente c\u00f3digo crea un objeto GADBannerView de tama\u00f1o 320x50 e inicializa las propiedades anteriores: import UIKit import GoogleMobileAds class ViewController : UIViewController , GADBannerViewDelegate { var bannerView : GADBannerView ! override func viewDidLoad () { super . viewDidLoad () bannerView = GADBannerView ( adSize : kGADAdSizeBanner ) bannerView . adUnitID = \"ca-app-pub-3940256099942544/2934735716\" bannerView . rootViewController = self bannerView . load ( GADRequest ()) bannerView . delegate = self } ... } En el siguiente m\u00e9todo addBannerViewToView(_:) se a\u00f1ade la vista del anuncio, aline\u00e1ndose con la parte inferior del \u00e1rea segura de pantalla: func addBannerViewToView ( _ bannerView : GADBannerView ) { bannerView . translatesAutoresizingMaskIntoConstraints = false view . addSubview ( bannerView ) view . addConstraints ( [ NSLayoutConstraint ( item : bannerView , attribute : . bottom , relatedBy : . equal , toItem : view . safeAreaLayoutGuide , attribute : . bottom , multiplier : 1 , constant : 0 ), NSLayoutConstraint ( item : bannerView , attribute : . centerX , relatedBy : . equal , toItem : view , attribute : . centerX , multiplier : 1 , constant : 0 ) ]) } Por \u00faltimo, es recomendable realizar la llamada a la funci\u00f3n anterior que incorpora el GADBannerView a la jerarqu\u00eda de vistas despu\u00e9s de haber recibido un anuncio. Para ello, se usa la funci\u00f3n del delegado adViewDidReceiveAd : /// Tells the delegate an ad request loaded an ad. func adViewDidReceiveAd ( _ bannerView : GADBannerView ) { print ( \"adViewDidReceiveAd\" ) addBannerViewToView ( bannerView ) } Podemos implementar el resto de funciones del delegado, con sentencias print para depurar cuando se produce cada evento: /// Tells the delegate an ad request failed. func adView ( _ bannerView : GADBannerView , didFailToReceiveAdWithError error : GADRequestError ) { print ( \"adView:didFailToReceiveAdWithError: \\( error . localizedDescription ) \" ) } /// Tells the delegate that a full-screen view will be presented in response /// to the user clicking on an ad. func adViewWillPresentScreen ( _ bannerView : GADBannerView ) { print ( \"adViewWillPresentScreen\" ) } /// Tells the delegate that the full-screen view will be dismissed. func adViewWillDismissScreen ( _ bannerView : GADBannerView ) { print ( \"adViewWillDismissScreen\" ) } /// Tells the delegate that the full-screen view has been dismissed. func adViewDidDismissScreen ( _ bannerView : GADBannerView ) { print ( \"adViewDidDismissScreen\" ) } /// Tells the delegate that a user click will open another app (such as /// the App Store), backgrounding the current app. func adViewWillLeaveApplication ( _ bannerView : GADBannerView ) { print ( \"adViewWillLeaveApplication\" ) }","title":"Implementaci\u00f3n de un banner"},{"location":"teoria/anuncios/anuncios.html#implementacion-de-un-interstitial","text":"Los anuncios intersticiales los solicitan y muestran los objetos GADInterstitial . Debemos crear una instancia y asignar el ID de su bloque de anuncios. Podemos cargar anuncios de prueba de tipo Interstitial usando el ID ca-app-pub-3940256099942544/4411468910 . Por ejemplo, aqu\u00ed se muestra c\u00f3mo crear un GADInterstitial en el m\u00e9todo viewDidLoad de un UIViewController . Hacemos tambi\u00e9n que el interstitial lance una petici\u00f3n para cargar una anuncio, y definimos como delegado el view controller . Para ello el view controller debe cumplir el protocolo GADInterstitialDelegate . import UIKit import GoogleMobileAds class ViewController : UIViewController , GADInterstitialDelegate { var interstitial : GADInterstitial ! override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. interstitial = GADInterstitial ( adUnitID : \"ca-app-pub-3940256099942544/4411468910\" ) interstitial . load ( GADRequest ()) interstitial . delegate = self } ... } GADInterstitial es un objeto de un solo uso que, al cargarse, muestra un anuncio intersticial. Para que una aplicaci\u00f3n muestre varios anuncios intersticiales, es necesario crear un GADInterstitial para cada uno de ellos (lo veremos m\u00e1s adelante). Para mostrar un intersticial, podemos verificar la propiedad isReady en GADInterstitial para asegurarnos de que ha terminado de cargarse y, despu\u00e9s, debemos llamar a presentFromRootViewController pas\u00e1ndole el view controller actual como view controller ra\u00edz: ... if interstitial . isReady { interstitial . present ( fromRootViewController : self ) } else { print ( \"El anuncio no est\u00e1 disponible\" ) } } Al igual que hac\u00edamos en el banner podemos realizar esta llamada en la funci\u00f3n del delegado interstitialDidReceiveAd : /// Tells the delegate an ad request succeeded. func interstitialDidReceiveAd ( _ ad : GADInterstitial ) { print ( \"interstitialDidReceiveAd\" ) interstitial . present ( fromRootViewController : self ) } El resto de funciones del delegado son las siguientes: /// Tells the delegate an ad request failed. func interstitial ( _ ad : GADInterstitial , didFailToReceiveAdWithError error : GADRequestError ) { print ( \"interstitial:didFailToReceiveAdWithError: \\( error . localizedDescription ) \" ) } /// Tells the delegate that an interstitial will be presented. func interstitialWillPresentScreen ( _ ad : GADInterstitial ) { print ( \"interstitialWillPresentScreen\" ) } /// Tells the delegate the interstitial is to be animated off the screen. func interstitialWillDismissScreen ( _ ad : GADInterstitial ) { print ( \"interstitialWillDismissScreen\" ) } /// Tells the delegate the interstitial had been animated off the screen. func interstitialDidDismissScreen ( _ ad : GADInterstitial ) { print ( \"interstitialDidDismissScreen\" ) } /// Tells the delegate that a user click will open another app /// (such as the App Store), backgrounding the current app. func interstitialWillLeaveApplication ( _ ad : GADInterstitial ) { print ( \"interstitialWillLeaveApplication\" ) } Tal y como hemos comentado el GADInterstitial es un objeto de un solo uso. Eso significa que una vez que se muestra un intersticial, hasBeenUsed devuelve el valor true y el intersticial no se puede usar para cargar otro anuncio. Para solicitar otro, deberemos crear un nuevo objeto GADInterstitial . Si intentamos reutilizar un objeto intersticial, aparecer\u00e1 el mensaje \"Request Error: Will not send request because interstitial object has been used\" El mejor lugar para asignar otro intersticial es en el m\u00e9todo interstitialDidDismissScreen del delegado GADInterstitialDelegate , para que el siguiente intersticial comience a cargarse tan pronto como se cierre el anterior. Podemos refactorizar la creaci\u00f3n del interstiticial en una funci\u00f3n aparte, y llamar a esa funci\u00f3n desde viewDidLoad y desde interstitialDidDismissScreen : override func viewDidLoad () { super . viewDidLoad () interstitial = createAndLoadInterstitial () } func createAndLoadInterstitial () -> GADInterstitial { var interstitial = GADInterstitial ( adUnitID : \"ca-app-pub-3940256099942544/4411468910\" ) interstitial . delegate = self interstitial . load ( GADRequest ()) return interstitial } func interstitialDidDismissScreen ( _ ad : GADInterstitial ) { interstitial = createAndLoadInterstitial () }","title":"Implementaci\u00f3n de un interstitial"},{"location":"teoria/anuncios/anuncios.html#demo-aplicacion-de-prueba","text":"Puedes descargarte una aplicaci\u00f3n de prueba en la que se muestra el funcionamiento b\u00e1sico de AdMob. Se debe ejecutar la app en un dispositivo real, ya que AdMob no funciona en el simulador. Tambi\u00e9n debes darte de alta en AdMob, registrar una aplicaci\u00f3n e incluir el n\u00famero de registro en el fichero Info.plist .","title":"Demo: Aplicaci\u00f3n de prueba"},{"location":"teoria/anuncios/anuncios.html#referencias","text":"Google AdMob SDK para iOS","title":"Referencias"},{"location":"teoria/compras-in-app/compras-in-app.html","text":"Compras In-App \u00b6 Conceptos de compras In-App \u00b6 \u00bfQu\u00e9 es una compra In-App? \u00b6 Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit : StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra. Ejemplos de uso \u00b6 Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium. Podemos permitir la suscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line Tipos de compras In-App - Compras \u00b6 No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz. Tipos de compras In-App - Suscripciones \u00b6 Suscripciones auto-renovables Como los no-consumibles, las suscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Suscripciones no-renovables Suscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la suscripci\u00f3n se realizan desde la app (y el servidor). Requisitos para activar las In-App \u00b6 Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador. Contratos \u00b6 \u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla. Servicios a activar en la app \u00b6 Bundle identifier y App Id \u00b6 Configuraci\u00f3n In-App desde iTunes Connect \u00b6 Datos del app \u00b6 Pantalla para a\u00f1adir nuevos In-Apps \u00b6 Seleccionar el tipo de In-App \u00b6 Caracter\u00edsticas del In-App \u00b6 Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple Caracter\u00edsticas del In-App \u00b6 Usuarios de prueba \u00b6 Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba. Demo \u00b6 Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en este enlace C\u00f3digo para implementar las compras In-App \u00b6 El proceso de compra en un vistazo \u00b6 Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver . Clase auxiliar InApp \u00b6 Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : import Foundation import StoreKit protocol InAppDelegate { func compraRecibida () } class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . default (). add ( self ) // Cargamos la lista de productos productIdentiferList . append ( \"ejemplo3\" ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () } // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count > 0 && SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . default (). add ( pago ) print ( \"Comprando...\" ) } else { print ( \"No existen productos\" ) } } // M\u00e9todo al que se llama cuando el usuario compra el InApp func paymentQueue ( _ queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . purchased : print ( \"Purchased\" ) delegate ?. compraRecibida () SKPaymentQueue . default (). finishTransaction ( transaction ) case . failed : print ( \"Failed\" ) print ( \"Error de transacci\u00f3n: \\( String ( describing : transaction . error ?. localizedDescription )) \" ) SKPaymentQueue . default (). finishTransaction ( transaction ) case . restored : print ( \"Restored\" ) delegate ?. compraRecibida () SKPaymentQueue . default (). finishTransaction ( transaction ) default : print ( \"Otro\" ) } } } // M\u00e9todo al que se llama cuando se han recibido los productos func productsRequest ( _ request : SKProductsRequest , didReceive response : SKProductsResponse ) { print ( \"Hemos recibido \\( response . products . count ) productos\" ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( \"Producto invalido id: \\( invalidProductId ) \" ) } } } Clase ViewController \u00b6 En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. import UIKit class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () override func viewDidLoad () { // Actualizamos el delgado de inApp con la propia // instacia, para que se llame al m\u00e9todo compraRecibida inApp . delegate = self // Escondemos el bot\u00f3n sorpresa, que s\u00f3lo estar\u00e1 visible // para los que hagan la compra botonSorpresa . isHidden = true // Comprobamos si hemos comprado antes el inApp if UserDefaults . standard . bool ( forKey : \"inAppComprado\" ) { botonSorpresa . isHidden = false } else { botonSorpresa . isHidden = true } super . viewDidLoad () } // M\u00e9todo del protocolo al que se va a llamar cuando se reciba // la compra. Hacemos visible el bot\u00f3n sorpresa. func compraRecibida () { botonSorpresa . isHidden = false } // La acci\u00f3n asociada al bot\u00f3n de compra llama // al m\u00e9todo lanzarPago de la instancia de nuestra // clase InApp @IBAction func hazCompra ( _ sender : UIButton ) { print ( \"Click bot\u00f3n de compra\" ) inApp . lanzarPago () } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () // Dispose of any resources that can be recreated. } // Acci\u00f3n para mostrar la pantalla sorpresa @IBAction func sorpresa ( _ sender : UIButton ){ performSegue ( withIdentifier : \"Sorpresa\" , sender : view ) } } Referencias \u00b6 P\u00e1gina resumen Apple Developer App Store Connect - In-App purchase In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices","title":"6. Compras InApp"},{"location":"teoria/compras-in-app/compras-in-app.html#compras-in-app","text":"","title":"Compras In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#conceptos-de-compras-in-app","text":"","title":"Conceptos de compras In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#que-es-una-compra-in-app","text":"Permite vender directamente una funcionalidad dentro de una app. Los datos de la compra (precio, identificador) se definen en iTunes Connect. Se implementa con el API StoreKit : StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del acceso seguro del App Store. La app recibe la confirmaci\u00f3n de la compra y debe desbloquear din\u00e1micamente la funcionalidad. La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa nueva funcionalidad, aunque el usuario siempre puede recuperar la compra.","title":"\u00bfQu\u00e9 es una compra In-App?"},{"location":"teoria/compras-in-app/compras-in-app.html#ejemplos-de-uso","text":"Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad Por ejemplo: Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades adicionales premium. Podemos permitir la suscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar Ofertas de niveles adicionales en juegos Compras de mercanc\u00edas virtuales en juegos on-line","title":"Ejemplos de uso"},{"location":"teoria/compras-in-app/compras-in-app.html#tipos-de-compras-in-app-compras","text":"No-consumibles \u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario. Ejemplos: libros, niveles de un juego, funcionalidades premium de un app. Consumibles \u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app. Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz.","title":"Tipos de compras In-App - Compras"},{"location":"teoria/compras-in-app/compras-in-app.html#tipos-de-compras-in-app-suscripciones","text":"Suscripciones auto-renovables Como los no-consumibles, las suscripciones permanecen disponibles en todos los dispositivos. Tienen una fecha de expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la compra. Suscripciones no-renovables Suscripciones en las que no se entrega contenido peri\u00f3dico. Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas. Suele acompa\u00f1arse de una cuenta de usuario en un servidor. La duraci\u00f3n y la expiraci\u00f3n de la suscripci\u00f3n se realizan desde la app (y el servidor).","title":"Tipos de compras In-App - Suscripciones"},{"location":"teoria/compras-in-app/compras-in-app.html#requisitos-para-activar-las-in-app","text":"Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago. Es necesario acceso a iTunes Connect para configurar las compras. No es posible hacerlo con el equipo de la universidad. Haremos una demo con una cuenta de desarrollador.","title":"Requisitos para activar las In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#contratos","text":"\u00a1Cuidado! : Para poder probar las compras In-App hay que tener todos los contratos en regla.","title":"Contratos"},{"location":"teoria/compras-in-app/compras-in-app.html#servicios-a-activar-en-la-app","text":"","title":"Servicios a activar en la app"},{"location":"teoria/compras-in-app/compras-in-app.html#bundle-identifier-y-app-id","text":"","title":"Bundle identifier y App Id"},{"location":"teoria/compras-in-app/compras-in-app.html#configuracion-in-app-desde-itunes-connect","text":"","title":"Configuraci\u00f3n In-App desde iTunes Connect"},{"location":"teoria/compras-in-app/compras-in-app.html#datos-del-app","text":"","title":"Datos del app"},{"location":"teoria/compras-in-app/compras-in-app.html#pantalla-para-anadir-nuevos-in-apps","text":"","title":"Pantalla para a\u00f1adir nuevos In-Apps"},{"location":"teoria/compras-in-app/compras-in-app.html#seleccionar-el-tipo-de-in-app","text":"","title":"Seleccionar el tipo de In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#caracteristicas-del-in-app","text":"Nombre de referencia: aparece en la ventana de compra ID del producto: identificador del In-App para reconocerlo en el app Precio Datos para la revisi\u00f3n de Apple","title":"Caracter\u00edsticas del In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#caracteristicas-del-in-app_1","text":"","title":"Caracter\u00edsticas del In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#usuarios-de-prueba","text":"Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect. En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba.","title":"Usuarios de prueba"},{"location":"teoria/compras-in-app/compras-in-app.html#demo","text":"Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App. Est\u00e1 disponible en este enlace","title":"Demo"},{"location":"teoria/compras-in-app/compras-in-app.html#codigo-para-implementar-las-compras-in-app","text":"","title":"C\u00f3digo para implementar las compras In-App"},{"location":"teoria/compras-in-app/compras-in-app.html#el-proceso-de-compra-en-un-vistazo","text":"Debemos implementar los protocolos SKProductsRequestDelegate y SKPaymentTransactionObserver .","title":"El proceso de compra en un vistazo"},{"location":"teoria/compras-in-app/compras-in-app.html#clase-auxiliar-inapp","text":"Creamos un protocolo InAppDelegate y una clase InApp donde gestionaremos la interacci\u00f3n con StoreKit : import Foundation import StoreKit protocol InAppDelegate { func compraRecibida () } class InApp : NSObject , SKProductsRequestDelegate , SKPaymentTransactionObserver { var productDetailsList : [ SKProduct ] = [] var productIdentiferList : [ String ] = [] var delegate : InAppDelegate ? override init () { super . init () SKPaymentQueue . default (). add ( self ) // Cargamos la lista de productos productIdentiferList . append ( \"ejemplo3\" ) let request = SKProductsRequest . init ( productIdentifiers : Set ( productIdentiferList )) request . delegate = self request . start () } // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario func lanzarPago () { if ( self . productDetailsList . count > 0 && SKPaymentQueue . canMakePayments ()) { let producto = productDetailsList [ 0 ] let pago = SKPayment ( product : producto ) SKPaymentQueue . default (). add ( pago ) print ( \"Comprando...\" ) } else { print ( \"No existen productos\" ) } } // M\u00e9todo al que se llama cuando el usuario compra el InApp func paymentQueue ( _ queue : SKPaymentQueue , updatedTransactions transactions : [ SKPaymentTransaction ]) { for transaction in transactions { switch transaction . transactionState { case . purchased : print ( \"Purchased\" ) delegate ?. compraRecibida () SKPaymentQueue . default (). finishTransaction ( transaction ) case . failed : print ( \"Failed\" ) print ( \"Error de transacci\u00f3n: \\( String ( describing : transaction . error ?. localizedDescription )) \" ) SKPaymentQueue . default (). finishTransaction ( transaction ) case . restored : print ( \"Restored\" ) delegate ?. compraRecibida () SKPaymentQueue . default (). finishTransaction ( transaction ) default : print ( \"Otro\" ) } } } // M\u00e9todo al que se llama cuando se han recibido los productos func productsRequest ( _ request : SKProductsRequest , didReceive response : SKProductsResponse ) { print ( \"Hemos recibido \\( response . products . count ) productos\" ) productDetailsList = response . products for invalidProductId in response . invalidProductIdentifiers { print ( \"Producto invalido id: \\( invalidProductId ) \" ) } } }","title":"Clase auxiliar InApp"},{"location":"teoria/compras-in-app/compras-in-app.html#clase-viewcontroller","text":"En la clase ViewController adoptamos nuestro protocolo InAppDelegate y definimos su m\u00e9todo compraRecibida() al que se va a llamar cuando se haya recibido y validado la compra. import UIKit class ViewController : UIViewController , InAppDelegate { @IBOutlet weak var botonSorpresa : UIButton ! let inApp = InApp () override func viewDidLoad () { // Actualizamos el delgado de inApp con la propia // instacia, para que se llame al m\u00e9todo compraRecibida inApp . delegate = self // Escondemos el bot\u00f3n sorpresa, que s\u00f3lo estar\u00e1 visible // para los que hagan la compra botonSorpresa . isHidden = true // Comprobamos si hemos comprado antes el inApp if UserDefaults . standard . bool ( forKey : \"inAppComprado\" ) { botonSorpresa . isHidden = false } else { botonSorpresa . isHidden = true } super . viewDidLoad () } // M\u00e9todo del protocolo al que se va a llamar cuando se reciba // la compra. Hacemos visible el bot\u00f3n sorpresa. func compraRecibida () { botonSorpresa . isHidden = false } // La acci\u00f3n asociada al bot\u00f3n de compra llama // al m\u00e9todo lanzarPago de la instancia de nuestra // clase InApp @IBAction func hazCompra ( _ sender : UIButton ) { print ( \"Click bot\u00f3n de compra\" ) inApp . lanzarPago () } override func didReceiveMemoryWarning () { super . didReceiveMemoryWarning () // Dispose of any resources that can be recreated. } // Acci\u00f3n para mostrar la pantalla sorpresa @IBAction func sorpresa ( _ sender : UIButton ){ performSegue ( withIdentifier : \"Sorpresa\" , sender : view ) } }","title":"Clase ViewController"},{"location":"teoria/compras-in-app/compras-in-app.html#referencias","text":"P\u00e1gina resumen Apple Developer App Store Connect - In-App purchase In-App Purchase Programming Guide Receipt Validation Programming Guide StoreKit Framework Reference Technical Note: Adding In-App Purchase to your iOS and OS X Applications Technical Note: In-App Purchase Best Practices","title":"Referencias"},{"location":"teoria/extensiones/extensiones.html","text":"Extensiones \u00b6 Conceptos b\u00e1sicos \u00b6 Introducci\u00f3n \u00b6 Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo). Targets \u00b6 Las extensiones se incluyen en el proyecto como targets adicionales que acompa\u00f1an a la app principal. Un target especifica un producto a construir por Xcode. Por ejemplo, si cuando creamos un proyecto escogemos a\u00f1adir tests unitarios y de UI, Xcode introduce autom\u00e1ticamente estos targets, adem\u00e1s de la app principal. Para a\u00f1adir manualmente un nuevo target al proyecto podemos seleccionar el bot\u00f3n + en la parte de abajo o la opci\u00f3n Editor > Add Target... . Podemos seleccionar el target y especificar sus caracter\u00edsticas en el panel principal. Hay que especificar los mismos elementos que para una app principal (de hecho los targets son como mini apps): Bundle Id, versi\u00f3n, build Certificado y perfil de aprovisionamiento Permisos ( capabilities ) Configuraci\u00f3n y reglas del build Esquema \u00b6 Cada target tiene una configuraci\u00f3n autom\u00e1tica de construcci\u00f3n definida por su esquema ( schema ). Un esquema es una colecci\u00f3n de configuraciones que especifican las acciones a realizar para la compilaci\u00f3n del target y el entorno ejecutable a usar para lanzar el producto. Cuando abrimos o creamos un proyecto, Xcode crea autom\u00e1ticamente un esquema para cada target . El men\u00fa de esquemas se puede usar para cambiar el esquema activo y el destino. Podemos usar tambi\u00e9n el men\u00fa de esquemas para crear, editar y gestionar esquemas y para a\u00f1adir y descartar simuladores. Los esquemas y los destinos son distintos. Los destinos especifican d\u00f3nde instalar la app (dispositivos f\u00edsicos y simuladores). Los esquemas especifican los ajustes para compilar, ejecutar, testear, monitorizar, analizar y archivar el proyecto. Estos ajustes se pueden configurar en la opci\u00f3n de editar esquema. Ejemplo de extensi\u00f3n: Compartir \u00b6 Veamos un ejemplo concreto, la extensi\u00f3n Compartir ( Share Extension ). Muchas aplicaciones proporcionan el punto de extensi\u00f3n Compartir, en el que se pueden instalar extensiones de tipo Share Extension . Por ejemplo, en la siguiente imagen vemos como se puede acceder a la opci\u00f3n de compartir en una p\u00e1gina del navegador Safari y c\u00f3mo el usuario puede acceder a las extensiones que se han a\u00f1adido. La extensi\u00f3n Compartir hereda un ViewController por defecto de tipo SLComposeServiceViewController que contiene entre otros: Un campo de texto que puede editar el usuario, Una previsualizaci\u00f3n del objeto a compartir Los botones Cancel y Post La extensi\u00f3n puede configurar algunos aspectos de este ViewController . Por ejemplo, puede a\u00f1adir una opci\u00f3n en la parte inferior en la que el usuario pueda seleccionar d\u00f3nde compartir. Por ejemplo, esto se hace en la extensi\u00f3n adaptada por la app Recordatorios , en la que se da la opci\u00f3n de seleccionar el recordatorio en el que se quiere a\u00f1adir la p\u00e1gina. SLComposeServiceViewController \u00b6 Cuando creamos una extensi\u00f3n (m\u00e1s adelante haremos una demostraci\u00f3n) Xcode crea una plantilla inicial de c\u00f3digo. En el caso de una extensi\u00f3n Compartir la plantilla define un view controller hijo de SLComposeServiceViewController en el que podemos configurar el funcionamiento de la extensi\u00f3n. import UIKit import Social class ShareViewController : SLComposeServiceViewController { override func isContentValid () -> Bool { // Do validation of contentText and/or NSExtensionContext // attachments here return true } override func didSelectPost () { // This is called after the user selects Post. Do the // upload of contentText and/or NSExtensionContext // attachments. // Inform the host that we're done, so it un-blocks its UI. // Note: Alternatively you could call super's -didSelectPost, // which will similarly complete the extension context. self . extensionContext !. completeRequest ( returningItems : [], completionHandler : nil ) } override func configurationItems () -> [ Any ] ! { // To add configuration options via table cells at the // bottom of the sheet, return an array of // SLComposeSheetConfigurationItem here. return [] } } Extension Context \u00b6 La aplicaci\u00f3n que invoca a la extensi\u00f3n crea un objeto de tipo NSExtensionContext que se guarda en la variable extensionContext del SLComposeServiceViewController . Este objeto contiene la informaci\u00f3n del \u00edtem o \u00edtems que el usuario a seleccionado para compartir en su propiedad inputItems : var inputItems : [Any] Creaci\u00f3n de extensiones dentro de apps \u00b6 Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor > Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n. Se construyen de forma independiente \u00b6 Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador. Demo: Extensi\u00f3n Compartir \u00b6 Vamos a crear una extensi\u00f3n Compartir desde cero. Creamos un proyecto nuevo llamado PruebaExtension y a\u00f1adimos un nuevo target . Elegimos el tipo de extensi\u00f3n Share Extension : Escribimos como nombre del producto Compartir y aceptamos activar el esquema Compartir . Comprobamos los dos productos existentes, el c\u00f3digo de cada uno de ellos, y los esquemas. A\u00f1adimos en el storyboard de la app principal una etiqueta que deber\u00e1 aparecer cuando la app est\u00e9 lanzada en el simulador. A\u00f1adimos c\u00f3digo en el view controller creado por defecto para la extensi\u00f3n en el que imprimimos algunos mensajes en la salida est\u00e1ndar. Podemos instalar y depurar la extensi\u00f3n seleccionando el esquema y ejecut\u00e1ndolo. Aparece un panel en el que tenemos que seleccionar la app compa\u00f1era de la extensi\u00f3n (cualquier extensi\u00f3n debe instalarse junto con una app principal). Podemos escoger cualquier app de las ya instaladas. Lo m\u00e1s normal es que instalemos primero la app principal y despu\u00e9s ejecutemos la extensi\u00f3n usando esta app. Cuando se lance la app principal, ya se habr\u00e1 cargado la extensi\u00f3n. Abrimos Safari, por ejemplo, y escogemos la opci\u00f3n compartir . Comprobamos si la extensi\u00f3n est\u00e1 habilitada. Pulsamos la extensi\u00f3n Compartir y vemos c\u00f3mo se activa su view controller y como aparecen en la consola los mensajes que hemos a\u00f1adido en el c\u00f3digo. Tipos de extensiones \u00b6 Puntos de extensi\u00f3n \u00b6 Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple . Algunos de los tipos de extensiones que proporciona el sistema: Actions : Permite manipular contenido de la app original Audio Unit : Permite generar o modificar un stream de audio Custom Keyboard : Permite reemplazar el teclado del sistema con un teclado customizado Document Provider : Permite acceder y gestionar un repositorio de ficheros Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Permite editar una foto o un v\u00eddeo en la app Fotos Share : Permite enviar a un sitio web o compartir contenido con otros Today : Permite a\u00f1adir widgets en el panel de Hoy WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch. Xcode permite a\u00f1adir un target que implementa cualquiera de las extensiones anteriores, creando el c\u00f3digo y la configuraci\u00f3n inicial de la misma. Un ejemplo del aspecto de las extensiones Custom Keyboard y Photo Editing : Propiedades de la extensi\u00f3n \u00b6 Todos los aspectos relacionados con la configuraci\u00f3n de la extensi\u00f3n, incluido su tipo, se definen en propiedades en el fichero Info.plist . Por ejemplo, la extensi\u00f3n Share a\u00f1adida en la demostraci\u00f3n se crea con las siguientes propiedades: <key> NSExtension </key> <dict> <key> NSExtensionAttributes </key> <dict> <key> NSExtensionActivationRule </key> <string> TRUEPREDICATE </string> </dict> <key> NSExtensionMainStoryboard </key> <string> MainInterface </string> <key> NSExtensionPointIdentifier </key> <string> com.apple.share-services </string> </dict> La propiedad NSExtensionPointIdentifier es la que define el tipo de extensi\u00f3n y el punto de extensi\u00f3n. Como vemos, en el caso de una extensi\u00f3n de tipo Share es com.apple.share-services . Panel Today \u00b6 Veamos algunas caracter\u00edsticas de otro tipo de extensi\u00f3n, la Today Extension . En iOS los usuarios pueden visualizar un panel especial, denominado Today , en el que es posible instalar extensiones. Se accede a este panel con un gesto de deslizar hacia la derecha, incluso con el dispositivo bloqueado. Las extensiones tienen una peque\u00f1a vista que se muestran apiladas una sobre otra. Tambi\u00e9n se puede acceder a una segunda vista ampliada al pulsar Mostrar m\u00e1s . El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas. Notification Service Extension \u00b6 Veamos un \u00faltimo ejemplo de extensi\u00f3n, la Notification Service Extension . La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. En este caso Xcode no genera ninguna vista ni controller, s\u00f3lo una clase NotificationService que extiende UNNotificationServiceExtension y que debemos modificar. import UserNotifications class NotificationService : UNNotificationServiceExtension { var contentHandler : (( UNNotificationContent ) -> Void )? var bestAttemptContent : UNMutableNotificationContent ? override func didReceive ( _ request : UNNotificationRequest , withContentHandler contentHandler : @ escaping ( UNNotificationContent ) -> Void ) { self . contentHandler = contentHandler bestAttemptContent = ( request . content . mutableCopy () as ? UNMutableNotificationContent ) if let bestAttemptContent = bestAttemptContent { // Modify the notification content here... bestAttemptContent . title = \" \\( bestAttemptContent . title ) [modified]\" contentHandler ( bestAttemptContent ) } } override func serviceExtensionTimeWillExpire () { // Called just before the extension will be terminated by // the system. // Use this as an opportunity to deliver your \"best attempt\" // at modified content, otherwise the original push payload // will be used. if let contentHandler = contentHandler , let bestAttemptContent = bestAttemptContent { contentHandler ( bestAttemptContent ) } } } Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario. Funcionamiento de una extensi\u00f3n \u00b6 Ciclo de vida de una extension \u00b6 Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. Si la extensi\u00f3n tiene un ViewController , el sistema llama al m\u00e9todo viewDidLoad() para inicializar la vista y permitir que el usuario interaccione con ella. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social. Comunicaci\u00f3n de la app extension \u00b6 Una app extension se comunica principalmente con su app anfitriona (la app desde la que se lanza la extensi\u00f3n). No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Como ya hemos visto, un objeto del tipo NSExtensionContext . Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora. Comunicaci\u00f3n entre la app y la extensi\u00f3n \u00b6 La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Veamos posibles formas de hacerlo. La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando: frameworks embebidos compartidos grupos de apps a trav\u00e9s de una persistencia com\u00fan, usando CoreData o sqlite Framework embebido para compartir c\u00f3digo \u00b6 Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files . Grupos de apps \u00b6 Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Tambi\u00e9n lo puede crear autom\u00e1ticamente Xcode en la opci\u00f3n App Groups en las capabilities . Todas las apps y extensiones deben usar ese mismo identificador de grupo en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode). Configuraci\u00f3n del grupo de apps \u00b6 Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList App IDs y perfiles de aprovisionamiento \u00b6 Para la pr\u00e1ctica actualizamos los App IDs y los perfiles de aprovisionamiento, creando el App ID y el perfil Master Moviles ToDoList Extension y a\u00f1adiendo el identificador de grupo compartido entre este App Id y el Master Moviles ToDoList . App IDs: Master Moviles ToDoList con el bundle ID es.ua.mastermoviles.ToDoList ToDoList Today Extension con el bundle ID es.ua.mastermoviles.ToDoList.Hecho Perfiles de aprovisionamiento: Master Moviles ToDoList ToDoList Today Extension Capabilities \u00b6 Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido. Compartir datos con UserDefaults \u00b6 La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. let compartido = UserDefaults ( suiteName : \"group.app.group.id\" ) // set valores compartido ?. set ( 1 , forKey : \"contador\" ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : \"contador\" ) Compartir datos con FileManager \u00b6 La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : \"group.com.company.project\" ) { ... } Demo: CustomNotes \u00b6 Veamos un ejemplo completo de extensi\u00f3n de tipo Share Extension , la app CustomNotes , adaptada de una versi\u00f3n original hecha con Swift 3 y disponible en github . La aplicaci\u00f3n original se describe en este art\u00edculo de Medium . Se ha modificado la app original, simplific\u00e1ndola y adapt\u00e1ndola a Swift 5. La puedes descargar desde este enlace . Algunas caracter\u00edsticas interesantes: Utiliza Core Data para guardar las notas. Define un grupo de app compartido entre la extensi\u00f3n y la app en el que se guardan los datos. Permite seleccionar la nota en la que se guarda el texto a compartir. Examinamos c\u00f3mo funcionan la app y la extensi\u00f3n. Referencias \u00b6 P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide","title":"Extensiones"},{"location":"teoria/extensiones/extensiones.html#extensiones","text":"","title":"Extensiones"},{"location":"teoria/extensiones/extensiones.html#conceptos-basicos","text":"","title":"Conceptos b\u00e1sicos"},{"location":"teoria/extensiones/extensiones.html#introduccion","text":"Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps. Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web. Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario. En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo).","title":"Introducci\u00f3n"},{"location":"teoria/extensiones/extensiones.html#targets","text":"Las extensiones se incluyen en el proyecto como targets adicionales que acompa\u00f1an a la app principal. Un target especifica un producto a construir por Xcode. Por ejemplo, si cuando creamos un proyecto escogemos a\u00f1adir tests unitarios y de UI, Xcode introduce autom\u00e1ticamente estos targets, adem\u00e1s de la app principal. Para a\u00f1adir manualmente un nuevo target al proyecto podemos seleccionar el bot\u00f3n + en la parte de abajo o la opci\u00f3n Editor > Add Target... . Podemos seleccionar el target y especificar sus caracter\u00edsticas en el panel principal. Hay que especificar los mismos elementos que para una app principal (de hecho los targets son como mini apps): Bundle Id, versi\u00f3n, build Certificado y perfil de aprovisionamiento Permisos ( capabilities ) Configuraci\u00f3n y reglas del build","title":"Targets"},{"location":"teoria/extensiones/extensiones.html#esquema","text":"Cada target tiene una configuraci\u00f3n autom\u00e1tica de construcci\u00f3n definida por su esquema ( schema ). Un esquema es una colecci\u00f3n de configuraciones que especifican las acciones a realizar para la compilaci\u00f3n del target y el entorno ejecutable a usar para lanzar el producto. Cuando abrimos o creamos un proyecto, Xcode crea autom\u00e1ticamente un esquema para cada target . El men\u00fa de esquemas se puede usar para cambiar el esquema activo y el destino. Podemos usar tambi\u00e9n el men\u00fa de esquemas para crear, editar y gestionar esquemas y para a\u00f1adir y descartar simuladores. Los esquemas y los destinos son distintos. Los destinos especifican d\u00f3nde instalar la app (dispositivos f\u00edsicos y simuladores). Los esquemas especifican los ajustes para compilar, ejecutar, testear, monitorizar, analizar y archivar el proyecto. Estos ajustes se pueden configurar en la opci\u00f3n de editar esquema.","title":"Esquema"},{"location":"teoria/extensiones/extensiones.html#ejemplo-de-extension-compartir","text":"Veamos un ejemplo concreto, la extensi\u00f3n Compartir ( Share Extension ). Muchas aplicaciones proporcionan el punto de extensi\u00f3n Compartir, en el que se pueden instalar extensiones de tipo Share Extension . Por ejemplo, en la siguiente imagen vemos como se puede acceder a la opci\u00f3n de compartir en una p\u00e1gina del navegador Safari y c\u00f3mo el usuario puede acceder a las extensiones que se han a\u00f1adido. La extensi\u00f3n Compartir hereda un ViewController por defecto de tipo SLComposeServiceViewController que contiene entre otros: Un campo de texto que puede editar el usuario, Una previsualizaci\u00f3n del objeto a compartir Los botones Cancel y Post La extensi\u00f3n puede configurar algunos aspectos de este ViewController . Por ejemplo, puede a\u00f1adir una opci\u00f3n en la parte inferior en la que el usuario pueda seleccionar d\u00f3nde compartir. Por ejemplo, esto se hace en la extensi\u00f3n adaptada por la app Recordatorios , en la que se da la opci\u00f3n de seleccionar el recordatorio en el que se quiere a\u00f1adir la p\u00e1gina.","title":"Ejemplo de extensi\u00f3n: Compartir"},{"location":"teoria/extensiones/extensiones.html#slcomposeserviceviewcontroller","text":"Cuando creamos una extensi\u00f3n (m\u00e1s adelante haremos una demostraci\u00f3n) Xcode crea una plantilla inicial de c\u00f3digo. En el caso de una extensi\u00f3n Compartir la plantilla define un view controller hijo de SLComposeServiceViewController en el que podemos configurar el funcionamiento de la extensi\u00f3n. import UIKit import Social class ShareViewController : SLComposeServiceViewController { override func isContentValid () -> Bool { // Do validation of contentText and/or NSExtensionContext // attachments here return true } override func didSelectPost () { // This is called after the user selects Post. Do the // upload of contentText and/or NSExtensionContext // attachments. // Inform the host that we're done, so it un-blocks its UI. // Note: Alternatively you could call super's -didSelectPost, // which will similarly complete the extension context. self . extensionContext !. completeRequest ( returningItems : [], completionHandler : nil ) } override func configurationItems () -> [ Any ] ! { // To add configuration options via table cells at the // bottom of the sheet, return an array of // SLComposeSheetConfigurationItem here. return [] } }","title":"SLComposeServiceViewController"},{"location":"teoria/extensiones/extensiones.html#extension-context","text":"La aplicaci\u00f3n que invoca a la extensi\u00f3n crea un objeto de tipo NSExtensionContext que se guarda en la variable extensionContext del SLComposeServiceViewController . Este objeto contiene la informaci\u00f3n del \u00edtem o \u00edtems que el usuario a seleccionado para compartir en su propiedad inputItems : var inputItems : [Any]","title":"Extension Context"},{"location":"teoria/extensiones/extensiones.html#creacion-de-extensiones-dentro-de-apps","text":"Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor > Add Target... Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n.","title":"Creaci\u00f3n de extensiones dentro de apps"},{"location":"teoria/extensiones/extensiones.html#se-construyen-de-forma-independiente","text":"Las extensiones se compilan de forma independiente de la app. Tienen su propio bundle id , capabilities , perfil de aprovisionamiento, etc. En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: es.ua.mastermoviles.ToDoListCloudKit.Hecho . Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador.","title":"Se construyen de forma independiente"},{"location":"teoria/extensiones/extensiones.html#demo-extension-compartir","text":"Vamos a crear una extensi\u00f3n Compartir desde cero. Creamos un proyecto nuevo llamado PruebaExtension y a\u00f1adimos un nuevo target . Elegimos el tipo de extensi\u00f3n Share Extension : Escribimos como nombre del producto Compartir y aceptamos activar el esquema Compartir . Comprobamos los dos productos existentes, el c\u00f3digo de cada uno de ellos, y los esquemas. A\u00f1adimos en el storyboard de la app principal una etiqueta que deber\u00e1 aparecer cuando la app est\u00e9 lanzada en el simulador. A\u00f1adimos c\u00f3digo en el view controller creado por defecto para la extensi\u00f3n en el que imprimimos algunos mensajes en la salida est\u00e1ndar. Podemos instalar y depurar la extensi\u00f3n seleccionando el esquema y ejecut\u00e1ndolo. Aparece un panel en el que tenemos que seleccionar la app compa\u00f1era de la extensi\u00f3n (cualquier extensi\u00f3n debe instalarse junto con una app principal). Podemos escoger cualquier app de las ya instaladas. Lo m\u00e1s normal es que instalemos primero la app principal y despu\u00e9s ejecutemos la extensi\u00f3n usando esta app. Cuando se lance la app principal, ya se habr\u00e1 cargado la extensi\u00f3n. Abrimos Safari, por ejemplo, y escogemos la opci\u00f3n compartir . Comprobamos si la extensi\u00f3n est\u00e1 habilitada. Pulsamos la extensi\u00f3n Compartir y vemos c\u00f3mo se activa su view controller y como aparecen en la consola los mensajes que hemos a\u00f1adido en el c\u00f3digo.","title":"Demo: Extensi\u00f3n Compartir"},{"location":"teoria/extensiones/extensiones.html#tipos-de-extensiones","text":"","title":"Tipos de extensiones"},{"location":"teoria/extensiones/extensiones.html#puntos-de-extension","text":"Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema. Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo. Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar. Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple . Algunos de los tipos de extensiones que proporciona el sistema: Actions : Permite manipular contenido de la app original Audio Unit : Permite generar o modificar un stream de audio Custom Keyboard : Permite reemplazar el teclado del sistema con un teclado customizado Document Provider : Permite acceder y gestionar un repositorio de ficheros Intents : Manejar tareas relacionadas con la integraci\u00f3n con Siri. Photo Editing : Permite editar una foto o un v\u00eddeo en la app Fotos Share : Permite enviar a un sitio web o compartir contenido con otros Today : Permite a\u00f1adir widgets en el panel de Hoy WatchKit App : Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch. Xcode permite a\u00f1adir un target que implementa cualquiera de las extensiones anteriores, creando el c\u00f3digo y la configuraci\u00f3n inicial de la misma. Un ejemplo del aspecto de las extensiones Custom Keyboard y Photo Editing :","title":"Puntos de extensi\u00f3n"},{"location":"teoria/extensiones/extensiones.html#propiedades-de-la-extension","text":"Todos los aspectos relacionados con la configuraci\u00f3n de la extensi\u00f3n, incluido su tipo, se definen en propiedades en el fichero Info.plist . Por ejemplo, la extensi\u00f3n Share a\u00f1adida en la demostraci\u00f3n se crea con las siguientes propiedades: <key> NSExtension </key> <dict> <key> NSExtensionAttributes </key> <dict> <key> NSExtensionActivationRule </key> <string> TRUEPREDICATE </string> </dict> <key> NSExtensionMainStoryboard </key> <string> MainInterface </string> <key> NSExtensionPointIdentifier </key> <string> com.apple.share-services </string> </dict> La propiedad NSExtensionPointIdentifier es la que define el tipo de extensi\u00f3n y el punto de extensi\u00f3n. Como vemos, en el caso de una extensi\u00f3n de tipo Share es com.apple.share-services .","title":"Propiedades de la extensi\u00f3n"},{"location":"teoria/extensiones/extensiones.html#panel-today","text":"Veamos algunas caracter\u00edsticas de otro tipo de extensi\u00f3n, la Today Extension . En iOS los usuarios pueden visualizar un panel especial, denominado Today , en el que es posible instalar extensiones. Se accede a este panel con un gesto de deslizar hacia la derecha, incluso con el dispositivo bloqueado. Las extensiones tienen una peque\u00f1a vista que se muestran apiladas una sobre otra. Tambi\u00e9n se puede acceder a una segunda vista ampliada al pulsar Mostrar m\u00e1s . El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas.","title":"Panel Today"},{"location":"teoria/extensiones/extensiones.html#notification-service-extension","text":"Veamos un \u00faltimo ejemplo de extensi\u00f3n, la Notification Service Extension . La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada. Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. En este caso Xcode no genera ninguna vista ni controller, s\u00f3lo una clase NotificationService que extiende UNNotificationServiceExtension y que debemos modificar. import UserNotifications class NotificationService : UNNotificationServiceExtension { var contentHandler : (( UNNotificationContent ) -> Void )? var bestAttemptContent : UNMutableNotificationContent ? override func didReceive ( _ request : UNNotificationRequest , withContentHandler contentHandler : @ escaping ( UNNotificationContent ) -> Void ) { self . contentHandler = contentHandler bestAttemptContent = ( request . content . mutableCopy () as ? UNMutableNotificationContent ) if let bestAttemptContent = bestAttemptContent { // Modify the notification content here... bestAttemptContent . title = \" \\( bestAttemptContent . title ) [modified]\" contentHandler ( bestAttemptContent ) } } override func serviceExtensionTimeWillExpire () { // Called just before the extension will be terminated by // the system. // Use this as an opportunity to deliver your \"best attempt\" // at modified content, otherwise the original push payload // will be used. if let contentHandler = contentHandler , let bestAttemptContent = bestAttemptContent { contentHandler ( bestAttemptContent ) } } } Se debe usar el m\u00e9todo didReceiveNotificationRequest:withContentHandler: para crear un nuevo objeto UNMutableNotificationContent en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales. Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario.","title":"Notification Service Extension"},{"location":"teoria/extensiones/extensiones.html#funcionamiento-de-una-extension","text":"","title":"Funcionamiento de una extensi\u00f3n"},{"location":"teoria/extensiones/extensiones.html#ciclo-de-vida-de-una-extension","text":"Las app extensi\u00f3n tienen un ciclo de vida muy corto. Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. Si la extensi\u00f3n tiene un ViewController , el sistema llama al m\u00e9todo viewDidLoad() para inicializar la vista y permitir que el usuario interaccione con ella. La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona. Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social.","title":"Ciclo de vida de una extension"},{"location":"teoria/extensiones/extensiones.html#comunicacion-de-la-app-extension","text":"Una app extension se comunica principalmente con su app anfitriona (la app desde la que se lanza la extensi\u00f3n). No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo. El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Como ya hemos visto, un objeto del tipo NSExtensionContext . Una extensi\u00f3n de tipo Today (y ninguna otra) puede pedir al sistema que abra la app contenedora.","title":"Comunicaci\u00f3n de la app extension"},{"location":"teoria/extensiones/extensiones.html#comunicacion-entre-la-app-y-la-extension","text":"La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Veamos posibles formas de hacerlo. La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores. Es posible compartir c\u00f3digo usando: frameworks embebidos compartidos grupos de apps a trav\u00e9s de una persistencia com\u00fan, usando CoreData o sqlite","title":"Comunicaci\u00f3n entre la app y la extensi\u00f3n"},{"location":"teoria/extensiones/extensiones.html#framework-embebido-para-compartir-codigo","text":"Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora. Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora. Para crear un framework embebido se debe seleccionar \"Frameworks\" como destino en la fase de construcci\u00f3n Copy Files .","title":"Framework embebido para compartir c\u00f3digo"},{"location":"teoria/extensiones/extensiones.html#grupos-de-apps","text":"Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como: UserDefaults compartido Ficheros compartidos Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Tambi\u00e9n lo puede crear autom\u00e1ticamente Xcode en la opci\u00f3n App Groups en las capabilities . Todas las apps y extensiones deben usar ese mismo identificador de grupo en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode).","title":"Grupos de apps"},{"location":"teoria/extensiones/extensiones.html#configuracion-del-grupo-de-apps","text":"Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n. Creamos para la pr\u00e1ctica el grupo group.ua.mastermoviles.ToDoList","title":"Configuraci\u00f3n del grupo de apps"},{"location":"teoria/extensiones/extensiones.html#app-ids-y-perfiles-de-aprovisionamiento","text":"Para la pr\u00e1ctica actualizamos los App IDs y los perfiles de aprovisionamiento, creando el App ID y el perfil Master Moviles ToDoList Extension y a\u00f1adiendo el identificador de grupo compartido entre este App Id y el Master Moviles ToDoList . App IDs: Master Moviles ToDoList con el bundle ID es.ua.mastermoviles.ToDoList ToDoList Today Extension con el bundle ID es.ua.mastermoviles.ToDoList.Hecho Perfiles de aprovisionamiento: Master Moviles ToDoList ToDoList Today Extension","title":"App IDs y perfiles de aprovisionamiento"},{"location":"teoria/extensiones/extensiones.html#capabilities","text":"Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido.","title":"Capabilities"},{"location":"teoria/extensiones/extensiones.html#compartir-datos-con-userdefaults","text":"La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves. let compartido = UserDefaults ( suiteName : \"group.app.group.id\" ) // set valores compartido ?. set ( 1 , forKey : \"contador\" ) compartido ?. synchronize () // get valores compartido ?. synchronize (); let contador = compartido ?. integer ( forKey : \"contador\" )","title":"Compartir datos con UserDefaults"},{"location":"teoria/extensiones/extensiones.html#compartir-datos-con-filemanager","text":"La clase FileManager contiene el m\u00e9todo containerURL al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros. Es posible crear ficheros compartidos con todas las apps del grupo en este directorio. let fileManager = FileManager . default if let containerURL = fileManager . containerURL ( forSecurityApplicationGroupIdentifier : \"group.com.company.project\" ) { ... }","title":"Compartir datos con FileManager"},{"location":"teoria/extensiones/extensiones.html#demo-customnotes","text":"Veamos un ejemplo completo de extensi\u00f3n de tipo Share Extension , la app CustomNotes , adaptada de una versi\u00f3n original hecha con Swift 3 y disponible en github . La aplicaci\u00f3n original se describe en este art\u00edculo de Medium . Se ha modificado la app original, simplific\u00e1ndola y adapt\u00e1ndola a Swift 5. La puedes descargar desde este enlace . Algunas caracter\u00edsticas interesantes: Utiliza Core Data para guardar las notas. Define un grupo de app compartido entre la extensi\u00f3n y la app en el que se guardan los datos. Permite seleccionar la nota en la que se guarda el texto a compartir. Examinamos c\u00f3mo funcionan la app y la extensi\u00f3n.","title":"Demo: CustomNotes"},{"location":"teoria/extensiones/extensiones.html#referencias","text":"P\u00e1gina de principal de Apple: App Extensions App Extensions Programming Guide","title":"Referencias"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html","text":"Firma, aprovisionamiento y distribuci\u00f3n de apps \u00b6 Introducci\u00f3n \u00b6 En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps usando Test Flight y App Store Connect. Seguridad en las apps \u00b6 La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Al arrancar la aplicaci\u00f3n el sistema se asegura de que el c\u00f3digo de la app no ha sido modificado desde la \u00faltima vez que fue instalada o actualizada. Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . Para publicar una app en el App Store, es necesario haberla firmado. De esta forma, toda app que nos instalemos en nuestros dispositivos ha sido desarrollada por una persona f\u00edsica u organizaci\u00f3n identificable. A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable. Cuenta de desarrollador de Apple \u00b6 Distintos programas de desarrollo \u00b6 Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el portal del desarrollador ( member center ) de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ : Equipo de desarrollo \u00b6 En los programas de pago de desarrollador de Apple es posible trabajar con un equipo de desarrolladores. No es necesario darse de alta como organizaci\u00f3n para componer un equipo. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership del portal del desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight. Tambi\u00e9n se pueden configurar estas opciones en el programa universitario. Demo \u00b6 Veremos una demostraci\u00f3n en la que accederemos al portal del desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es) Perfil gratuito \u00b6 Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder al portal del desarrollador . Con esta cuenta gratuita podremos comenzar a desarrollar apps y probarlas en nuestro dispositivo de desarrollo. Pero este desarrollo estar\u00e1 limitado. No podremos distribuirlas a m\u00e1s dispositivos ni utilizar servicios avanzados de Apple. Miembro del equipo de la UA \u00b6 Si a\u00f1adimos nuestra cuenta al equipo de la Universidad de Alicante, podremos gestionar servicios y capacidades adicionales. Esta es la cuenta que usaremos durante la asignatura. En el men\u00fa de la izquierda podemos comprobar que hay opciones adicionales a la cuenta gratuita. Miembro de pago \u00b6 Por \u00faltimo, si usamos una cuenta de pago, tenemos opciones adicionales: Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store. Fin de la demo \u00b6 Certificados \u00b6 C\u00f3digo firmado \u00b6 Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma. Identidad de firma \u00b6 Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado es creado por Xcode al a\u00f1adir la cuenta de usuario y se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en el portal del desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador. Tipos de certificados \u00b6 Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el portal del desarrollador, Xcode o Acceso a llaveros . Gesti\u00f3n de los certificados en Xcode \u00b6 Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra los dos equipos y nos permite utilizar el que nos interese en cada momento. Creaci\u00f3n e instalaci\u00f3n de certificados \u00b6 Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se conecta a los servidores de Apple e instala autom\u00e1ticamente el certificado de firma. Ejecuci\u00f3n de apps en dispositivos reales \u00b6 Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) compatible con el bundle identifier de la app que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store. Demo \u00b6 Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode, usando el perfil de desarrollador de la cuenta gratuita de Apple y despu\u00e9s usando el perfil de desarrollador del equipo de la Universidad de Alicante. Instalaci\u00f3n de la identidad de firma \u00b6 Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode > Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito. Firma de una app \u00b6 Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing & Capabilities . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app. App ejemplo ToDo \u00b6 Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador. Comprobaci\u00f3n del certificado \u00b6 En la pantalla de Xcode > Preferences... > Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode . Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros \u00b6 En la aplicaci\u00f3n Acceso a Llaveros podemos comprobar que el certificado se ha instalado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n . Conexi\u00f3n de un dispositivo de desarrollo a Xcode \u00b6 Una vez que se ha firmado la aplicaci\u00f3n es posible ejecutarla en un dispositivo de desarrollo conectado a Xcode. Comenzamos conectando el dispositivo iOS al ordenador. Se debe aceptar en el dispositivo un mensaje en el que se pide confirmaci\u00f3n para confiar en el ordenador. Despu\u00e9s, en Xcode seleccionamos Window > Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo. Prueba en un dispositivo real \u00b6 Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica. Autorizaci\u00f3n al desarrollador en el dispositivo \u00b6 Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app. Archivo y distribuci\u00f3n de la app \u00b6 Seleccionando la opci\u00f3n de Xcode Product > Archive se accede al panel de archivo y distribuci\u00f3n de la app Sin embargo, al estar registrado en el programa gratuito no es posible seleccionar ninguna forma de distribuci\u00f3n de la app. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. Firma con el equipo de la UA \u00b6 Podemos firmar con el equipo de la UA cambiando el bundle ID, seleccionando el Team Universidad de Alicante . Al seleccionar el equipo Universidad de Alicante Xcode selecciona nuestro certificado espec\u00edfico asociado al equipo de la UA y firma con \u00e9l la aplicaci\u00f3n. Podemos instalar cualquier perfil de aprovisionamiento creado en el equipo de la UA que sea compatible con el bundle ID. Para ello desmarcamos la opci\u00f3n Automatically manage signing y descargamos el perfil que nos interese. Un perfil de aprovisionamiento contiene un listado de capacidades que podemos activar en la app y un listado de dispositivos en los que podemos ejecutarla. M\u00e1s adelante explicaremos esto con m\u00e1s detalle. Podemos seleccionar el perfil denominado Gen\u00e9rico : Una vez instalado el perfil de aprovisionamiento, la configuraci\u00f3n de firma de la app queda como se muestra en la siguiente imagen: Archivo y distribuci\u00f3n de la app \u00b6 Ahora ya podemos exportar la app y ejecutarla en cualquier dispositivo registrado en el perfil que acabamos de instalar. Para ello debemos seleccionar Product > Archive y la opci\u00f3n Development . Se crea una carpeta que contiene el fichero .ipa que puede instalarse en cualquier dispositivo incluido en el perfil de aprovisionamiento (aunque no sea un dispositivo de desarrollo). Podemos instalar la app en un dispositivo conectando el dispositivo al Mac y usando el programa de Apple Apple Configurator 2 . Fin de la demo \u00b6 Capacidades de las apps \u00b6 Apple proporciona un conjunto de servicios para ser utilizados por las apps. Apple denomina a estos servicios como Capabilities . Para que una app pueda utilizar cualquiera de estas capabilities debe autorizarse su uso desde la cuenta de desarrollo o desde Xcode. Dependiendo del tipo de cuenta de desarrollo es posible utilizar unas capabilities y otras. Por ejemplo, podemos utilizar el servicio de mapas o el API de Health Kit con el programa gratuito, pero necesitamos el programa de la universidad para poder utilizar servicios iCloud o notificaciones push. Y existen capabilities avanzadas que s\u00f3lo pueden ser usadas con el programa de pago. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer > Support > Advanced App Capabilities . Podemos explorar en Xcode el listado de capabilities que podemos a\u00f1adir a nuestra app, accediendo desde la pantalla de Signing & Capabilities a la opci\u00f3n + Capability . Con el programa gratuito podemos usar el siguiente listado de capabilities : Con el programa de pago podemos acceder a todos los servicios proporcionados por Apple: Bundle Identifier \u00b6 Un bundle ID es una cadena que identifica de forma \u00fanica una app. Cuando definimos el bundle ID de un proyecto, Apple lo registra y no permite que ning\u00fan otro desarrollador utilice ese mismo ID. Si intentamos registrar un bundle ID que otro desarrollador ya ha usado Xcode nos informa de un error. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). Una forma de que no existan demasiadas colisiones en los bundle ID es usar un formato DNS-inverso con el nombre de la app y el dominio de nuestra organizaci\u00f3n. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hola . Tambi\u00e9n podr\u00edamos usar nuestro nombre y el nombre de la app (si nadie ha registrado una app con un nombre id\u00e9ntico al nuestro): domingogallardo.Hola . La forma de comprobar la disponibilidad del bundle ID es intentar firmar la app en la pantalla Signing & Capabilities de Xcode. Al escribir el bundle ID y pulsar Enter Xcode intenta firmar la app y da un error si el bundle ID ya est\u00e1 cogido. Uso del Bundle ID \u00b6 Ya que el bundle ID identifica una app de forma \u00fanica, \u00e9ste se utiliza en varias fases de su configuraci\u00f3n. En concreto, se usa en el proceso de aprovisionamiento de la app y en la configuraci\u00f3n de los permisos y capacidades a los que la app puede acceder. Cuando configuramos los permisos para que la app pueda utilizar determinados servicios debemos indicar a qu\u00e9 bundle IDs otorgamos esos permisos. Esto lo hacemos como el App ID . App ID \u00b6 El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el portal del desarrollador. Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con la capability de acceso a iCloud. De esta forma, todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que es el que finalmente hay que instalar en la app y permite que \u00e9sta acceda a los permisos otorgados. Adem\u00e1s, el perfil de aprovisionamiento tambi\u00e9n contendr\u00e1 los identificadores de los dispositivos de prueba en los que la app podr\u00e1 ejecutarse. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del App ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha. Gesti\u00f3n de las capacidades en Xcode \u00b6 Como se ha comentado anteriormente, podemos acceder en Xcode a las capabilities que queremos autorizar en la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Signing & Capabilities y pulsar en + Capability . Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el portal del desarrollador alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores. Demo \u00b6 Vamos a comprobar el uso de las capacidades ( capabilities ) en la app ToDo. Si pulsamos en + Capability veremos que podemos a\u00f1adir un amplio conjunto de capacidades a la app. Son muchas m\u00e1s que en el perfil gratuito, por estar firmando la app con la cuenta de desarrollador del equipo de la UA. Pero para poder utilizar la capacidad, \u00e9sta debe estar autorizada por el perfil de aprovisionamiento. Y el perfil de aprovisionamiento Gen\u00e9rico no autoriza ninguna. Lo podemos comprobar seleccionando por ejemplo Game Center . Veremos el siguiente mensaje de error, que el perfil Gen\u00e9rico no autoriza la capacidad Game Center . Podemos ver los perfiles en la web del desarrollador del equipo de la UA, y buscar un perfil que autorice esa capacidad. Vemos que el perfil Master Moviles ToDo contiene las capacidades Game Center , iCloud , In-App Purchase y Push Notifications . Y que el App ID autoriza su uso al bundle ID es.ua.mastermoviles.ToDo . Cambiamos el bundle ID de la app a es.ua.mastermoviles.ToDo . Ese mismo identificador puede ser usado por distintos programadores, siempre que est\u00e9n en el mismo equipo. En este caso, en el equipo de la UA. Descargamos el perfil Master Moviles ToDo . Y podemos comprobar que ahora ya no da ning\u00fan error el uso de la capacidad Game Center . Al exportar la app tenemos que seleccionar manualmente el perfil correcto: Fin de la demo \u00b6 Despliegue de apps en dispositivos de prueba \u00b6 Hemos visto que cuando estamos desarrollando una app podemos desplegarla en el dispositivo de desarrollo usando Xcode. Una vez terminada, y antes de publicarla en la App Store, debemos distribuirla en dispositivos de usuarios prueba para que realicen pruebas m\u00e1s extensas. Es posible hacerlo declarando los dispositivos de prueba en el portal del desarrollador y a\u00f1adi\u00e9ndolos al perfil de aprovisionamiento de la app. Vamos a ver estos conceptos. Caracter\u00edsticas del dispositivo \u00b6 Cuando compilamos una app podemos especificar ciertas caracter\u00edsticas necesarias que debe tener el dispositivo en el que va a correr la app. En el apartado Deployment Info de XCode, disponible en la pantalla Target > General podemos definir: Tipo de dispositivo: iPhone, iPad o Mac (utilizando Mac Catalyst ) Sistema operativo m\u00ednimo: versi\u00f3n de OS m\u00ednima necesaria de los dispositivos en los que se va a instalar nuestra app. Caracter\u00edsticas de la interfaz de usuario y de la orientaci\u00f3n del dispositivo Distribuci\u00f3n de apps \u00b6 La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran. Aprovisionamiento de apps \u00b6 Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Apple permite tambi\u00e9n distribuir apps de forma restringida, declarando los dispositivos en el portal del desarrollador e incorpor\u00e1ndolos en el perfil de aprovisionamiento de la app. Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad. Una vez a\u00f1adido el perfil de aprovisionamiento a la app, podremos generar el archivo binario .ipa utilizando los m\u00e9todos de distribuci\u00f3n denominados Ad hoc y Development . Con ambos m\u00e9todos de distribuci\u00f3n podemos distribuir el app a aquellos dispositivos incluidos en la lista de dispositivos autorizados del perfil de aprovisionamiento. Con el segundo m\u00e9todo podemos adem\u00e1s distribuir la app a testers de nuestro equipo de desarrollo. El perfil de aprovisionamiento de la app tambi\u00e9n incluye las capacidades declaradas para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push). Perfil de aprovisionamiento \u00b6 Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 desarrolladores pueden compilar y distribuir un app. Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio Library/MobileDevice/Provisioning Profiles . Podemos acceder a este directorio desde el terminal o desde el Finder mostrando la carpeta Biblioteca con el men\u00fa Ir + Alt > Biblioteca (el modificador Alt muestra las opciones ocultas). Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero). Es posible consultar su contenido desde el terminal con el comando: security cms -D -i <perfil>.mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder: Dispositivos de prueba en el perfil de aprovisionamiento \u00b6 El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento y los permisos ( entitlements ) se usan para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store . Instalaci\u00f3n de la app en un dispositivo de prueba \u00b6 Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window > Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado. Ejecuci\u00f3n de apps en dispositivos no registrados \u00b6 Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple. Certificados de empresa \u00b6 Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house . Demo y ejercicio \u00b6 Resumen del flujo de trabajo \u00b6 Vamos a comprobar que es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Adem\u00e1s, veremos que la app puede ejecutarse en todos aquellos dispositivos que hayamos registrado y a\u00f1adido en el perfil de aprovisionamiento usado para firmar la app (adem\u00e1s de en el dispositivo de desarrollo autorizado por Xcode). Veremos que si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode, Xcode crear\u00e1 estos elementos de forma autom\u00e1tica. Tambi\u00e9n comprobaremos c\u00f3mo el administrador puede configurar App IDs y perfiles de aprovisionamiento en la web del equipo de desarrollo de Apple. Un resumen de los pasos que vamos a seguir en el ejercicio: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba. Equipo de desarrollo del programa de Universidad \u00b6 La mayor\u00eda de opciones en el portal del desarrollador ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde Xcode, seleccionando el equipo Universidad de Alicante y la opci\u00f3n Manage Certificates... . Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el portal del desarrollador o en la aplicaci\u00f3n de Acceso a llaveros: Incorporaci\u00f3n de certificado a un perfil de aprovisionamiento (administrador) \u00b6 Para poder firmar y distribuir apps el certificado reci\u00e9n creado debe estar incluido en un perfil de aprovisionamiento compatible con la app que estamos desarrollando. Vamos a incorporar los nuevos certificados al perfil de aprovisionamiento gen\u00e9rico, con App ID comod\u00edn ( * ) con el que se puede compilar cualquier app. Firma de la app con el nuevo certificado \u00b6 Para firmar la app con el nuevo certificado desmarcamos la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma . De esta forma podremos gestionar manualmente qu\u00e9 perfil de aprovisionamiento es el que utilizamos. Seleccionamos el team Universidad de Alicante. Y escribimos como bundle id es.ua.mastermoviles.ToDo . En el desplegable Provisioning Profile seleccionamos la opci\u00f3n Download Profile... . Aparece un listado con todos los perfiles de aprovisionamiento creados en nuestro equipo en el portal del desarrollador. Podemos examinarlos y seleccionar el m\u00e1s apropiado. Seleccionamos el denominado Gen\u00e9rico . Vemos que se firma la aplicaci\u00f3n correctamente y que se a\u00f1ade el perfil de aprovisionamiento que hemos seleccionado. La ventaja principal de firmar las apps de esta forma es que podremos distribuirlas a cualquier dispositivo incluido en el perfil. Prueba que es posible generar un fichero .ipa seleccionando la opci\u00f3n Product > Archive . Para ello debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. El perfil gen\u00e9rico no tiene configurado ning\u00fan servicio \u00b6 Vamos ahora a intentar a\u00f1adir una capability . Por ejemplo, la de Game Center . Lo podemos hacer pulsando en el bot\u00f3n + Capability , seleccionando la opci\u00f3n Game Center . Intentamos compilar la app ( Product > Build ) y aparecer\u00e1 el siguiente error: El error se debe a que el perfil de aprovisionamiento seleccionado no soporta la capacidad Game Center . Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el portal del desarrollador e incorporar en ese perfil el certificado del desarrollador. Examinamos los perfiles de aprovisionamiento \u00b6 Podemos examinar los perfiles de aprovisionamiento desde el portal del desarrollador, desde Xcode y desde el terminal o el Finder (en el directorio Library/MobileDevice/Provisioning Profiles ). Podemos acceder a la carpeta Library desde el Finder con el men\u00fa Ir + Alt > Biblioteca (el modificador Alt muestra las opciones ocultas). Si borramos los perfiles de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero). En el portal del desarrollador tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento. Men\u00fa de opciones \u00b6 El portal del desarrollador contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps Creaci\u00f3n de un App ID desde el portal del desarrollador (administrador) \u00b6 S\u00f3lo se puede hacer con el rol administrador. Se pulsa + en la cabecera Identifiers . Se selecciona la opci\u00f3n Register a New Identifier y se escoge la opci\u00f3n App IDs . Vemos que hay otros posibles identificadores que podemos crear. Se define la descripci\u00f3n del App ID y el prefijo de App ID (que debe emparejar con el bundle id de la aplicaci\u00f3n). Se escoge la opci\u00f3n Explicit para indicar que no se va a usar un prefijo con comod\u00edn. La app deber\u00e1 tener exactamente el bundle id es.ua.mastermoviles.ToDo para poder aplicarse el App ID. Se puede comprueba que la capability Game Center ya est\u00e1 seleccionada por defecto. Confirmamos y el App Id queda registrado en el portal del desarrollador: Una vez creado el App Id en el que definimos las capacidades del app, podemos pasar a a\u00f1adir los dispositivos en los que vamos a permitir probar el app. Y, por \u00faltimo, crearemos un perfil de aprovisionamiento que contenga el App Id y los dispositivos y que se descargar\u00e1 la app. Dispositivos (administrador) \u00b6 Para a\u00f1adir un dispositivo al portal del desarrollador hay que seleccionar la opci\u00f3n correspondientes ( Devices ) y a\u00f1adir su UDID, Unique Device Identifier . El UDID es una cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9) \u00fanica de cada dispositivo. Se puede obtener desde Xcode en la pantalla de Dispositivos ( Window > Devices ). Se pueden registrar en el portal del desarrollador hasta 200 UDIDs para probar aplicaciones en desarrollo. Creaci\u00f3n de perfiles de aprovisionamento (administrador) \u00b6 Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el portal del desarrollador y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde portal del desarrollador, ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n. Para crear un nuevo perfil de aprovisionamiento desde el portal del desarrollador, se selecciona la opci\u00f3n iOS App Development . Se selecciona el App ID que queremos incluir en el perfil: Se seleccionan los certificados de los desarrolladores a los que van a utilizar este perfil para compilar apps en Xcode: Se seleccionan los dispositivos en los que vamos a poder probar la app: Por \u00faltimo se da un nombre al perfil de aprovisionamiento: Y aparece una pantalla con el resumen del perfil generado. Se puede descargar en el ordenador para despu\u00e9s a\u00f1adirlo manualmente a la app usando Xcode. Tambi\u00e9n se puede descargar directamente desde Xcode. Listado de los perfiles de aprovisionamiento creados en el portal de desarrolladores: Firma de la app ToDo con el perfil de aprovisionamiento creado \u00b6 Una vez creado el perfil de aprovisionamiento ya es posible instalarlo en la app. Igual que antes nos aseguramos de que tenemos activa la opci\u00f3n manual y volvemos a seleccionar Download Profile... . Veremos ahora que ha aparecido el perfil que el administrador ha a\u00f1adido. Lo seleccionamos: Y ahora ya podemos ver que desparece el error anterior porque el nuevo perfil ya tiene la capacidad Game Center . Exportar la app \u00b6 Seleccionando en Xcode la opci\u00f3n Product > Archive (hay que asegurarse de que el tipo de dispositivo seleccionado es Generic iOS Device ) ahora ya funcionar\u00e1 la opci\u00f3n Distribute App . Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Seleccionamos el perfil de aprovisionamiento que acabamos de crear Master Moviles ToDo . Y, por \u00faltimo, confirmamos la opci\u00f3n de exportar: Tarda un rato en generar el fichero ipa ( iOS App file ). Se genera una carpeta con un fichero ToDo.ipa , que es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento. Instalaci\u00f3n y ejecuci\u00f3n de la app \u00b6 Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2. Fin demo y ejercicio \u00b6 Distribuci\u00f3n e instalaci\u00f3n de betas online \u00b6 Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple. Puedes encontrar m\u00e1s informaci\u00f3n sobre TestFlight en este enlace . Lo utilizar\u00e1s cuando desarrolles y publiques apps de iOS usando el perfil de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Esta es una funcionalidad que proporciona Firebase de Google. TestFlight \u00b6 TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos. Firebase para distribuir apps \u00b6 Firebase permite distribuir apps compiladas (ficheros .ipa) y ejecutarlas en aquellos dispositivos que est\u00e1n registrados en el perfil de aprovisionamiento. La funcionalidad se denomina App Distribution y permite distribuir distintas versiones de una misma app a usuarios de prueba. Podemos a\u00f1adir usuarios de prueba o crear un enlace al que puede acceder cualquiera para introducir su correo electr\u00f3nico. El usuario de prueba recibe un correo electr\u00f3nico con instrucciones de c\u00f3mo descargar la app. Al aceptar las instrucciones, el sistema comparte el UUID del dispositivo con nosotros y podemos a\u00f1adir el dispositivo al perfil de aprovisionamiento. El usuario de prueba debe a\u00f1adir el perfil de Firebase a su dispositivo. Una vez hemos a\u00f1adido el UUID al perfil de aprovisionamiento, lo a\u00f1adimos a la app y volvemos a distribuirla. El sistema enviar\u00e1 un correo al usuario, y \u00e9ste podr\u00e1 descargar y probar la app. Por \u00faltimo, Firebase permite tambi\u00e9n incluir en la app el servicio de de Google Analytics con el que podemos comprobar una gran cantidad de opciones relacionadas con el uso del app. Bibliograf\u00eda \u00b6 Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Distribuci\u00f3n de apps con Firebase Google Analytics Test Flight","title":"1. Firma, aprovisionamiento y distribuci\u00f3n de apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-aprovisionamiento-y-distribucion-de-apps","text":"","title":"Firma, aprovisionamiento y distribuci\u00f3n de apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#introduccion","text":"En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para: Ejecutar apps en dispositivos reales. Configurar perfiles de aprovisionamiento en el Programa de Desarrollo de la Universidad que nos permitan: Distribuir nuestras apps en dispositivos de prueba. Utilizar APIs de los servicios de iOS no disponibles en la cuenta de desarrollador gratuita. Probar y distribuir apps usando Test Flight y App Store Connect.","title":"Introducci\u00f3n"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#seguridad-en-las-apps","text":"La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados. El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps. Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple . Al arrancar la aplicaci\u00f3n el sistema se asegura de que el c\u00f3digo de la app no ha sido modificado desde la \u00faltima vez que fue instalada o actualizada. Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program . Para publicar una app en el App Store, es necesario haberla firmado. De esta forma, toda app que nos instalemos en nuestros dispositivos ha sido desarrollada por una persona f\u00edsica u organizaci\u00f3n identificable. A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable.","title":"Seguridad en las apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#cuenta-de-desarrollador-de-apple","text":"","title":"Cuenta de desarrollador de Apple"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distintos-programas-de-desarrollo","text":"Apple define varios tipos de programas de desarrollo: Programa gratuito Programa de desarrollador de Apple ( Apple Developer Program ) - $99 al a\u00f1o Programa de desarrollador de empresa ( Apple Developer Enterprise Program ) - $299 al a\u00f1o Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el portal del desarrollador ( member center ) de Apple con un Apple ID. El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store. El programa de desarrollador de empresa permite distribuir apps in-house , en los dispositivos del personal de la empresa, sin necesidad de usar el App Store. Adem\u00e1s de los anteriores programas, Apple ofrece el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permite acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago. Este programa permite utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Dependiendo del rol es posible acceder a distintas opciones. Hay dos tipos de roles principales: Admin (administrador de la organizaci\u00f3n) y Member (miembro de la organizaci\u00f3n). La Universidad de Alicante participa en este programa y probaremos sus caracter\u00edsticas. En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/ :","title":"Distintos programas de desarrollo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#equipo-de-desarrollo","text":"En los programas de pago de desarrollador de Apple es posible trabajar con un equipo de desarrolladores. No es necesario darse de alta como organizaci\u00f3n para componer un equipo. Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico ( Team ID ) que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership del portal del desarrollador. Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso . Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight. Tambi\u00e9n se pueden configurar estas opciones en el programa universitario.","title":"Equipo de desarrollo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo","text":"Veremos una demostraci\u00f3n en la que accederemos al portal del desarrollador y al App Store Connect usando distintos perfiles: Perfil gratuito (domingo.gallardo.appledev2@gmail.com) Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com) Administrador de la cuenta de la universidad (domingo@dccia.ua.es) Perfil de pago (domingo@dccia.ua.es)","title":"Demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#perfil-gratuito","text":"Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor . Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado. Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro. Una vez dados de alta como desarrolladores de Apple podremos acceder al portal del desarrollador . Con esta cuenta gratuita podremos comenzar a desarrollar apps y probarlas en nuestro dispositivo de desarrollo. Pero este desarrollo estar\u00e1 limitado. No podremos distribuirlas a m\u00e1s dispositivos ni utilizar servicios avanzados de Apple.","title":"Perfil gratuito"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#miembro-del-equipo-de-la-ua","text":"Si a\u00f1adimos nuestra cuenta al equipo de la Universidad de Alicante, podremos gestionar servicios y capacidades adicionales. Esta es la cuenta que usaremos durante la asignatura. En el men\u00fa de la izquierda podemos comprobar que hay opciones adicionales a la cuenta gratuita.","title":"Miembro del equipo de la UA"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#miembro-de-pago","text":"Por \u00faltimo, si usamos una cuenta de pago, tenemos opciones adicionales: Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store.","title":"Miembro de pago"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo","text":"","title":"Fin de la demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#certificados","text":"","title":"Certificados"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#codigo-firmado","text":"Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente. La firma digital del c\u00f3digo ( code signing ) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados. En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez. Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma.","title":"C\u00f3digo firmado"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#identidad-de-firma","text":"Una identidad de firma ( signing identity ) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador. El certificado es creado por Xcode al a\u00f1adir la cuenta de usuario y se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros ) y en el portal del desarrollador de Apple. La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo. Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero. Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador.","title":"Identidad de firma"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#tipos-de-certificados","text":"Existen varios tipos de certificados : de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store . Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store . Todos los certificados son proporcionados por Apple. Para comprobar el tipo de certificado podemos consultar el portal del desarrollador, Xcode o Acceso a llaveros .","title":"Tipos de certificados"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#gestion-de-los-certificados-en-xcode","text":"Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra los dos equipos y nos permite utilizar el que nos interese en cada momento.","title":"Gesti\u00f3n de los certificados en Xcode"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-e-instalacion-de-certificados","text":"Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione. Al firmar una aplicaci\u00f3n por primera vez, Xcode se conecta a los servidores de Apple e instala autom\u00e1ticamente el certificado de firma.","title":"Creaci\u00f3n e instalaci\u00f3n de certificados"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-reales","text":"Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos: Firma digital del binario con un certificado del desarrollador proporcionado por Apple ( Signing Certificate ). Instalaci\u00f3n de un perfil de aprovisionamiento ( Provisioning Profile ) compatible con el bundle identifier de la app que determina, entre otros: servicios de la plataforma Apple a los que la app puede acceder ( capabilities y entitlements ) y dispositivos concretos (IDs) autorizados en los que puede ejecutarse la app (lo veremos m\u00e1s adelante). Xcode facilita la realizaci\u00f3n de todos estos procesos. El resultado de estos procesos es un fichero binario .ipa firmado digitalmente. La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa ( in-house ). En estos casos es posible instalar las apps desde Test Flight , desde una web o con el programa de MacOS Apple Configurator 2 . Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si: El dispositivo es un dispositivo de desarrollo inicializado por Xcode. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario, que contiene el UUID del propio dispositivo y el certificado contiene la clave p\u00fablica del desarrollador que ha firmado la app. Se trata de una versi\u00f3n beta de la app que se ha instalado con Test Flight. El dispositivo tiene instalado un perfil de aprovisionamiento aprobado por el usuario y la app est\u00e1 firmada con un certificado de empresa proporcionado por Apple. Proviene del App Store y est\u00e1 firmada con un certificado de distribuci\u00f3n en el App Store.","title":"Ejecuci\u00f3n de apps en dispositivos reales"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo_1","text":"Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode, usando el perfil de desarrollador de la cuenta gratuita de Apple y despu\u00e9s usando el perfil de desarrollador del equipo de la Universidad de Alicante.","title":"Demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-de-la-identidad-de-firma","text":"Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador. Escogemos Xcode > Preferences y pinchamos en el signo + para a\u00f1adir Apple ID. Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito.","title":"Instalaci\u00f3n de la identidad de firma"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-una-app","text":"Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing & Capabilities . El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app.","title":"Firma de una app"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#app-ejemplo-todo","text":"Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer. Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener. Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador.","title":"App ejemplo ToDo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#comprobacion-del-certificado","text":"En la pantalla de Xcode > Preferences... > Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado. Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode .","title":"Comprobaci\u00f3n del certificado"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#comprobacion-de-la-identidad-de-firma-en-acceso-a-llaveros","text":"En la aplicaci\u00f3n Acceso a Llaveros podemos comprobar que el certificado se ha instalado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n .","title":"Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#conexion-de-un-dispositivo-de-desarrollo-a-xcode","text":"Una vez que se ha firmado la aplicaci\u00f3n es posible ejecutarla en un dispositivo de desarrollo conectado a Xcode. Comenzamos conectando el dispositivo iOS al ordenador. Se debe aceptar en el dispositivo un mensaje en el que se pide confirmaci\u00f3n para confiar en el ordenador. Despu\u00e9s, en Xcode seleccionamos Window > Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo. Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo.","title":"Conexi\u00f3n de un dispositivo de desarrollo a Xcode"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#prueba-en-un-dispositivo-real","text":"Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo. Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica.","title":"Prueba en un dispositivo real"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#autorizacion-al-desarrollador-en-el-dispositivo","text":"Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app.","title":"Autorizaci\u00f3n al desarrollador en el dispositivo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app","text":"Seleccionando la opci\u00f3n de Xcode Product > Archive se accede al panel de archivo y distribuci\u00f3n de la app Sin embargo, al estar registrado en el programa gratuito no es posible seleccionar ninguna forma de distribuci\u00f3n de la app. Cuidado Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita.","title":"Archivo y distribuci\u00f3n de la app"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-con-el-equipo-de-la-ua","text":"Podemos firmar con el equipo de la UA cambiando el bundle ID, seleccionando el Team Universidad de Alicante . Al seleccionar el equipo Universidad de Alicante Xcode selecciona nuestro certificado espec\u00edfico asociado al equipo de la UA y firma con \u00e9l la aplicaci\u00f3n. Podemos instalar cualquier perfil de aprovisionamiento creado en el equipo de la UA que sea compatible con el bundle ID. Para ello desmarcamos la opci\u00f3n Automatically manage signing y descargamos el perfil que nos interese. Un perfil de aprovisionamiento contiene un listado de capacidades que podemos activar en la app y un listado de dispositivos en los que podemos ejecutarla. M\u00e1s adelante explicaremos esto con m\u00e1s detalle. Podemos seleccionar el perfil denominado Gen\u00e9rico : Una vez instalado el perfil de aprovisionamiento, la configuraci\u00f3n de firma de la app queda como se muestra en la siguiente imagen:","title":"Firma con el equipo de la UA"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app_1","text":"Ahora ya podemos exportar la app y ejecutarla en cualquier dispositivo registrado en el perfil que acabamos de instalar. Para ello debemos seleccionar Product > Archive y la opci\u00f3n Development . Se crea una carpeta que contiene el fichero .ipa que puede instalarse en cualquier dispositivo incluido en el perfil de aprovisionamiento (aunque no sea un dispositivo de desarrollo). Podemos instalar la app en un dispositivo conectando el dispositivo al Mac y usando el programa de Apple Apple Configurator 2 .","title":"Archivo y distribuci\u00f3n de la app"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo_1","text":"","title":"Fin de la demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#capacidades-de-las-apps","text":"Apple proporciona un conjunto de servicios para ser utilizados por las apps. Apple denomina a estos servicios como Capabilities . Para que una app pueda utilizar cualquiera de estas capabilities debe autorizarse su uso desde la cuenta de desarrollo o desde Xcode. Dependiendo del tipo de cuenta de desarrollo es posible utilizar unas capabilities y otras. Por ejemplo, podemos utilizar el servicio de mapas o el API de Health Kit con el programa gratuito, pero necesitamos el programa de la universidad para poder utilizar servicios iCloud o notificaciones push. Y existen capabilities avanzadas que s\u00f3lo pueden ser usadas con el programa de pago. Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer > Support > Advanced App Capabilities . Podemos explorar en Xcode el listado de capabilities que podemos a\u00f1adir a nuestra app, accediendo desde la pantalla de Signing & Capabilities a la opci\u00f3n + Capability . Con el programa gratuito podemos usar el siguiente listado de capabilities : Con el programa de pago podemos acceder a todos los servicios proporcionados por Apple:","title":"Capacidades de las apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#bundle-identifier","text":"Un bundle ID es una cadena que identifica de forma \u00fanica una app. Cuando definimos el bundle ID de un proyecto, Apple lo registra y no permite que ning\u00fan otro desarrollador utilice ese mismo ID. Si intentamos registrar un bundle ID que otro desarrollador ya ha usado Xcode nos informa de un error. La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). Una forma de que no existan demasiadas colisiones en los bundle ID es usar un formato DNS-inverso con el nombre de la app y el dominio de nuestra organizaci\u00f3n. Por ejemplo, si el dominio de la organizaci\u00f3n es Acme.com y creamos una app llamada Hola podr\u00edamos usar como bundle ID de la app la cadena com.Acme.Hola . Tambi\u00e9n podr\u00edamos usar nuestro nombre y el nombre de la app (si nadie ha registrado una app con un nombre id\u00e9ntico al nuestro): domingogallardo.Hola . La forma de comprobar la disponibilidad del bundle ID es intentar firmar la app en la pantalla Signing & Capabilities de Xcode. Al escribir el bundle ID y pulsar Enter Xcode intenta firmar la app y da un error si el bundle ID ya est\u00e1 cogido.","title":"Bundle Identifier"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#uso-del-bundle-id","text":"Ya que el bundle ID identifica una app de forma \u00fanica, \u00e9ste se utiliza en varias fases de su configuraci\u00f3n. En concreto, se usa en el proceso de aprovisionamiento de la app y en la configuraci\u00f3n de los permisos y capacidades a los que la app puede acceder. Cuando configuramos los permisos para que la app pueda utilizar determinados servicios debemos indicar a qu\u00e9 bundle IDs otorgamos esos permisos. Esto lo hacemos como el App ID .","title":"Uso del Bundle ID"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#app-id","text":"El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades ( whitelist ) que permitimos usar a una app ( explicit App ID ) o varias apps ( wildcard App ID ). El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. Todos los App IDs creados se guardan en el portal del desarrollador. Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC. Por ejemplo, podr\u00edamos crear el App ID es.ua.mastermoviles.icloud.* con la capability de acceso a iCloud. De esta forma, todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio. Una vez creado, el App ID se instala en un perfil de aprovisionamiento que es el que finalmente hay que instalar en la app y permite que \u00e9sta acceda a los permisos otorgados. Adem\u00e1s, el perfil de aprovisionamiento tambi\u00e9n contendr\u00e1 los identificadores de los dispositivos de prueba en los que la app podr\u00e1 ejecutarse. En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios. La cadena del App ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID , y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha.","title":"App ID"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#gestion-de-las-capacidades-en-xcode","text":"Como se ha comentado anteriormente, podemos acceder en Xcode a las capabilities que queremos autorizar en la app que estamos desarrollando. Para ello debemos seleccionar el target y la opci\u00f3n Signing & Capabilities y pulsar en + Capability . Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el portal del desarrollador alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores.","title":"Gesti\u00f3n de las capacidades en Xcode"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo_2","text":"Vamos a comprobar el uso de las capacidades ( capabilities ) en la app ToDo. Si pulsamos en + Capability veremos que podemos a\u00f1adir un amplio conjunto de capacidades a la app. Son muchas m\u00e1s que en el perfil gratuito, por estar firmando la app con la cuenta de desarrollador del equipo de la UA. Pero para poder utilizar la capacidad, \u00e9sta debe estar autorizada por el perfil de aprovisionamiento. Y el perfil de aprovisionamiento Gen\u00e9rico no autoriza ninguna. Lo podemos comprobar seleccionando por ejemplo Game Center . Veremos el siguiente mensaje de error, que el perfil Gen\u00e9rico no autoriza la capacidad Game Center . Podemos ver los perfiles en la web del desarrollador del equipo de la UA, y buscar un perfil que autorice esa capacidad. Vemos que el perfil Master Moviles ToDo contiene las capacidades Game Center , iCloud , In-App Purchase y Push Notifications . Y que el App ID autoriza su uso al bundle ID es.ua.mastermoviles.ToDo . Cambiamos el bundle ID de la app a es.ua.mastermoviles.ToDo . Ese mismo identificador puede ser usado por distintos programadores, siempre que est\u00e9n en el mismo equipo. En este caso, en el equipo de la UA. Descargamos el perfil Master Moviles ToDo . Y podemos comprobar que ahora ya no da ning\u00fan error el uso de la capacidad Game Center . Al exportar la app tenemos que seleccionar manualmente el perfil correcto:","title":"Demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo_2","text":"","title":"Fin de la demo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#despliegue-de-apps-en-dispositivos-de-prueba","text":"Hemos visto que cuando estamos desarrollando una app podemos desplegarla en el dispositivo de desarrollo usando Xcode. Una vez terminada, y antes de publicarla en la App Store, debemos distribuirla en dispositivos de usuarios prueba para que realicen pruebas m\u00e1s extensas. Es posible hacerlo declarando los dispositivos de prueba en el portal del desarrollador y a\u00f1adi\u00e9ndolos al perfil de aprovisionamiento de la app. Vamos a ver estos conceptos.","title":"Despliegue de apps en dispositivos de prueba"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#caracteristicas-del-dispositivo","text":"Cuando compilamos una app podemos especificar ciertas caracter\u00edsticas necesarias que debe tener el dispositivo en el que va a correr la app. En el apartado Deployment Info de XCode, disponible en la pantalla Target > General podemos definir: Tipo de dispositivo: iPhone, iPad o Mac (utilizando Mac Catalyst ) Sistema operativo m\u00ednimo: versi\u00f3n de OS m\u00ednima necesaria de los dispositivos en los que se va a instalar nuestra app. Caracter\u00edsticas de la interfaz de usuario y de la orientaci\u00f3n del dispositivo","title":"Caracter\u00edsticas del dispositivo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distribucion-de-apps","text":"La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida. Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran.","title":"Distribuci\u00f3n de apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#aprovisionamiento-de-apps","text":"Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. Apple permite tambi\u00e9n distribuir apps de forma restringida, declarando los dispositivos en el portal del desarrollador e incorpor\u00e1ndolos en el perfil de aprovisionamiento de la app. Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad. Una vez a\u00f1adido el perfil de aprovisionamiento a la app, podremos generar el archivo binario .ipa utilizando los m\u00e9todos de distribuci\u00f3n denominados Ad hoc y Development . Con ambos m\u00e9todos de distribuci\u00f3n podemos distribuir el app a aquellos dispositivos incluidos en la lista de dispositivos autorizados del perfil de aprovisionamiento. Con el segundo m\u00e9todo podemos adem\u00e1s distribuir la app a testers de nuestro equipo de desarrollo. El perfil de aprovisionamiento de la app tambi\u00e9n incluye las capacidades declaradas para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push).","title":"Aprovisionamiento de apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#perfil-de-aprovisionamiento","text":"Un perfil de aprovisionamiento ( provisioning profile ) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas. Un perfil de aprovisionamiento determina b\u00e1sicamente: Qu\u00e9 desarrolladores pueden compilar y distribuir un app. Qu\u00e9 servicios puede utilizar una app. En qu\u00e9 dispositivos se pueden ejecutar la app. Un perfil de aprovisionamiento contiene los siguientes elementos: App ID : nombre del perfil, cadena de b\u00fasqueda y servicios autorizados por el p\u00e9rfil. Certificados de desarrolladores del equipo. Dispositivos : Nombre e identificadores de dispositivos. F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio Library/MobileDevice/Provisioning Profiles . Podemos acceder a este directorio desde el terminal o desde el Finder mostrando la carpeta Biblioteca con el men\u00fa Ir + Alt > Biblioteca (el modificador Alt muestra las opciones ocultas). Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero). Es posible consultar su contenido desde el terminal con el comando: security cms -D -i <perfil>.mobileprovision Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder:","title":"Perfil de aprovisionamiento"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#dispositivos-de-prueba-en-el-perfil-de-aprovisionamiento","text":"El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app. Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones: El bundle ID de la app empareja el App ID del perfil. Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil. La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento. En combinaci\u00f3n con el bundle ID , el perfil de aprovisionamiento y los permisos ( entitlements ) se usan para asegurar que: La app ha sido compilada y firmada por nosotros o por un miembro de confianza del equipo. Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en dispositivos de desarrollo escogidos. Las apps se ejecutan \u00fanicamente en los dispositivos de prueba que especifiquemos. Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app. S\u00f3lo nosotros podemos enviar revisiones del app al store .","title":"Dispositivos de prueba en el perfil de aprovisionamiento"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-de-la-app-en-un-dispositivo-de-prueba","text":"Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator 2 . La aplicaci\u00f3n Apple Configurator 2 permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc. La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador. Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window > Devices . All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado.","title":"Instalaci\u00f3n de la app en un dispositivo de prueba"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-no-registrados","text":"Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app: El App Store Distribution Provisioning Profile que se utiliza para poder subir la app al App Store de Apple. El In-house Distribution Provisioning Profile que se utiliza para poder distribuir una app en la empresa y que debe tener un certificado de empresa de Apple.","title":"Ejecuci\u00f3n de apps en dispositivos no registrados"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#certificados-de-empresa","text":"Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google . Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house .","title":"Certificados de empresa"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo-y-ejercicio","text":"","title":"Demo y ejercicio"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#resumen-del-flujo-de-trabajo","text":"Vamos a comprobar que es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Adem\u00e1s, veremos que la app puede ejecutarse en todos aquellos dispositivos que hayamos registrado y a\u00f1adido en el perfil de aprovisionamiento usado para firmar la app (adem\u00e1s de en el dispositivo de desarrollo autorizado por Xcode). Veremos que si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode, Xcode crear\u00e1 estos elementos de forma autom\u00e1tica. Tambi\u00e9n comprobaremos c\u00f3mo el administrador puede configurar App IDs y perfiles de aprovisionamiento en la web del equipo de desarrollo de Apple. Un resumen de los pasos que vamos a seguir en el ejercicio: Nos damos de alta al equipo de la universidad. El administrador del equipo de la universidad crea un App ID con ciertas capacidades y un perfil de aprovisionamiento con ese App ID, los dispositivos de prueba y los desarrolladores del equipo. Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo. Exportamos el fichero .ipa compilado de la app. Instalamos y ejecutamos la app en un dispositivo de prueba.","title":"Resumen del flujo de trabajo"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#equipo-de-desarrollo-del-programa-de-universidad","text":"La mayor\u00eda de opciones en el portal del desarrollador ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas. Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador. Se puede hacer desde Xcode, seleccionando el equipo Universidad de Alicante y la opci\u00f3n Manage Certificates... . Ser\u00e1 un certificado de tipo iOS App Development . Para confirmar que se ha creado el nuevo certificado, podemos entrar en el portal del desarrollador o en la aplicaci\u00f3n de Acceso a llaveros:","title":"Equipo de desarrollo del programa de Universidad"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#incorporacion-de-certificado-a-un-perfil-de-aprovisionamiento-administrador","text":"Para poder firmar y distribuir apps el certificado reci\u00e9n creado debe estar incluido en un perfil de aprovisionamiento compatible con la app que estamos desarrollando. Vamos a incorporar los nuevos certificados al perfil de aprovisionamiento gen\u00e9rico, con App ID comod\u00edn ( * ) con el que se puede compilar cualquier app.","title":"Incorporaci\u00f3n de certificado a un perfil de aprovisionamiento (administrador)"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-la-app-con-el-nuevo-certificado","text":"Para firmar la app con el nuevo certificado desmarcamos la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma . De esta forma podremos gestionar manualmente qu\u00e9 perfil de aprovisionamiento es el que utilizamos. Seleccionamos el team Universidad de Alicante. Y escribimos como bundle id es.ua.mastermoviles.ToDo . En el desplegable Provisioning Profile seleccionamos la opci\u00f3n Download Profile... . Aparece un listado con todos los perfiles de aprovisionamiento creados en nuestro equipo en el portal del desarrollador. Podemos examinarlos y seleccionar el m\u00e1s apropiado. Seleccionamos el denominado Gen\u00e9rico . Vemos que se firma la aplicaci\u00f3n correctamente y que se a\u00f1ade el perfil de aprovisionamiento que hemos seleccionado. La ventaja principal de firmar las apps de esta forma es que podremos distribuirlas a cualquier dispositivo incluido en el perfil. Prueba que es posible generar un fichero .ipa seleccionando la opci\u00f3n Product > Archive . Para ello debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita.","title":"Firma de la app con el nuevo certificado"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#el-perfil-generico-no-tiene-configurado-ningun-servicio","text":"Vamos ahora a intentar a\u00f1adir una capability . Por ejemplo, la de Game Center . Lo podemos hacer pulsando en el bot\u00f3n + Capability , seleccionando la opci\u00f3n Game Center . Intentamos compilar la app ( Product > Build ) y aparecer\u00e1 el siguiente error: El error se debe a que el perfil de aprovisionamiento seleccionado no soporta la capacidad Game Center . Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el portal del desarrollador e incorporar en ese perfil el certificado del desarrollador.","title":"El perfil gen\u00e9rico no tiene configurado ning\u00fan servicio"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#examinamos-los-perfiles-de-aprovisionamiento","text":"Podemos examinar los perfiles de aprovisionamiento desde el portal del desarrollador, desde Xcode y desde el terminal o el Finder (en el directorio Library/MobileDevice/Provisioning Profiles ). Podemos acceder a la carpeta Library desde el Finder con el men\u00fa Ir + Alt > Biblioteca (el modificador Alt muestra las opciones ocultas). Si borramos los perfiles de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero). En el portal del desarrollador tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento.","title":"Examinamos los perfiles de aprovisionamiento"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#menu-de-opciones","text":"El portal del desarrollador contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada. Certificados : todos los certificados de los desarrolladores del equipo. Identificadores : todos los App IDs aprobados, con las caracter\u00edsticas aprobadas en cada uno de ellos. Dispositivos : todos los dispositivos aprobados para probar las apps","title":"Men\u00fa de opciones"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-de-un-app-id-desde-el-portal-del-desarrollador-administrador","text":"S\u00f3lo se puede hacer con el rol administrador. Se pulsa + en la cabecera Identifiers . Se selecciona la opci\u00f3n Register a New Identifier y se escoge la opci\u00f3n App IDs . Vemos que hay otros posibles identificadores que podemos crear. Se define la descripci\u00f3n del App ID y el prefijo de App ID (que debe emparejar con el bundle id de la aplicaci\u00f3n). Se escoge la opci\u00f3n Explicit para indicar que no se va a usar un prefijo con comod\u00edn. La app deber\u00e1 tener exactamente el bundle id es.ua.mastermoviles.ToDo para poder aplicarse el App ID. Se puede comprueba que la capability Game Center ya est\u00e1 seleccionada por defecto. Confirmamos y el App Id queda registrado en el portal del desarrollador: Una vez creado el App Id en el que definimos las capacidades del app, podemos pasar a a\u00f1adir los dispositivos en los que vamos a permitir probar el app. Y, por \u00faltimo, crearemos un perfil de aprovisionamiento que contenga el App Id y los dispositivos y que se descargar\u00e1 la app.","title":"Creaci\u00f3n de un App ID desde el portal del desarrollador (administrador)"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#dispositivos-administrador","text":"Para a\u00f1adir un dispositivo al portal del desarrollador hay que seleccionar la opci\u00f3n correspondientes ( Devices ) y a\u00f1adir su UDID, Unique Device Identifier . El UDID es una cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9) \u00fanica de cada dispositivo. Se puede obtener desde Xcode en la pantalla de Dispositivos ( Window > Devices ). Se pueden registrar en el portal del desarrollador hasta 200 UDIDs para probar aplicaciones en desarrollo.","title":"Dispositivos (administrador)"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-de-perfiles-de-aprovisionamento-administrador","text":"Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento. Se puede hacer desde el portal del desarrollador y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde portal del desarrollador, ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones ( entitlements ) a la propia aplicaci\u00f3n. Para crear un nuevo perfil de aprovisionamiento desde el portal del desarrollador, se selecciona la opci\u00f3n iOS App Development . Se selecciona el App ID que queremos incluir en el perfil: Se seleccionan los certificados de los desarrolladores a los que van a utilizar este perfil para compilar apps en Xcode: Se seleccionan los dispositivos en los que vamos a poder probar la app: Por \u00faltimo se da un nombre al perfil de aprovisionamiento: Y aparece una pantalla con el resumen del perfil generado. Se puede descargar en el ordenador para despu\u00e9s a\u00f1adirlo manualmente a la app usando Xcode. Tambi\u00e9n se puede descargar directamente desde Xcode. Listado de los perfiles de aprovisionamiento creados en el portal de desarrolladores:","title":"Creaci\u00f3n de perfiles de aprovisionamento (administrador)"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-la-app-todo-con-el-perfil-de-aprovisionamiento-creado","text":"Una vez creado el perfil de aprovisionamiento ya es posible instalarlo en la app. Igual que antes nos aseguramos de que tenemos activa la opci\u00f3n manual y volvemos a seleccionar Download Profile... . Veremos ahora que ha aparecido el perfil que el administrador ha a\u00f1adido. Lo seleccionamos: Y ahora ya podemos ver que desparece el error anterior porque el nuevo perfil ya tiene la capacidad Game Center .","title":"Firma de la app ToDo con el perfil de aprovisionamiento creado"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#exportar-la-app","text":"Seleccionando en Xcode la opci\u00f3n Product > Archive (hay que asegurarse de que el tipo de dispositivo seleccionado es Generic iOS Device ) ahora ya funcionar\u00e1 la opci\u00f3n Distribute App . Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla. La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development , que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento. La opci\u00f3n de App Thining permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo. Seleccionamos el perfil de aprovisionamiento que acabamos de crear Master Moviles ToDo . Y, por \u00faltimo, confirmamos la opci\u00f3n de exportar: Tarda un rato en generar el fichero ipa ( iOS App file ). Se genera una carpeta con un fichero ToDo.ipa , que es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento.","title":"Exportar la app"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-y-ejecucion-de-la-app","text":"Probamos a instalar la app en un dispositivo autorizado usando Apple Configurator 2.","title":"Instalaci\u00f3n y ejecuci\u00f3n de la app"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-demo-y-ejercicio","text":"","title":"Fin demo y ejercicio"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distribucion-e-instalacion-de-betas-online","text":"Hemos visto que es posible ejecutar apps de prueba en dispositivos que est\u00e9n dados de alta en el perfil de aprovisionamiento. Pero la instalaci\u00f3n de la app es un proceso algo tedioso: hay que conectar f\u00edsicamente el dispositivo a un ordenador Mac y realizar la instalaci\u00f3n mediante una aplicaci\u00f3n auxiliar como Xcode o Apple Configurator 2. Ser\u00eda mucho m\u00e1s f\u00e1cil si permiti\u00e9ramos instalar la app desde el propio dispositivo (iPhone o iPad), descarg\u00e1ndola de una web o de alguna app de configuraci\u00f3n. Esto es lo que se consigue con la aplicaci\u00f3n TestFlight de Apple. Puedes encontrar m\u00e1s informaci\u00f3n sobre TestFlight en este enlace . Lo utilizar\u00e1s cuando desarrolles y publiques apps de iOS usando el perfil de pago. Existe una soluci\u00f3n intermedia: seguir usando la distribuci\u00f3n al equipo de desarrollo mediante el alta de los dispositivos en el pefil de aprovisionamiento, pero usar un servicio que facilite la instalaci\u00f3n de la app en esos dispositivos. Esta es una funcionalidad que proporciona Firebase de Google.","title":"Distribuci\u00f3n e instalaci\u00f3n de betas online"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#testflight","text":"TestFlight es una plataforma integrada en App Store Connect que permite distribuir versiones beta de apps a probadores. Es posible distribuir la app hasta 25 probadores internos (seleccionados de entre los usuarios de la cuenta de App Store Connect) y hasta 10.000 probadores externos. Los usuarios de prueba deben descargarse la app TestFlight con la que gestionar\u00e1n la descarga de las pruebas en sus dispositivos.","title":"TestFlight"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firebase-para-distribuir-apps","text":"Firebase permite distribuir apps compiladas (ficheros .ipa) y ejecutarlas en aquellos dispositivos que est\u00e1n registrados en el perfil de aprovisionamiento. La funcionalidad se denomina App Distribution y permite distribuir distintas versiones de una misma app a usuarios de prueba. Podemos a\u00f1adir usuarios de prueba o crear un enlace al que puede acceder cualquiera para introducir su correo electr\u00f3nico. El usuario de prueba recibe un correo electr\u00f3nico con instrucciones de c\u00f3mo descargar la app. Al aceptar las instrucciones, el sistema comparte el UUID del dispositivo con nosotros y podemos a\u00f1adir el dispositivo al perfil de aprovisionamiento. El usuario de prueba debe a\u00f1adir el perfil de Firebase a su dispositivo. Una vez hemos a\u00f1adido el UUID al perfil de aprovisionamiento, lo a\u00f1adimos a la app y volvemos a distribuirla. El sistema enviar\u00e1 un correo al usuario, y \u00e9ste podr\u00e1 descargar y probar la app. Por \u00faltimo, Firebase permite tambi\u00e9n incluir en la app el servicio de de Google Analytics con el que podemos comprobar una gran cantidad de opciones relacionadas con el uso del app.","title":"Firebase para distribuir apps"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#bibliografia","text":"Developer Account Help Code Signing Help Xcode Help Distribute your app to registered devices Distribute your app App Store Connect Help Distribuci\u00f3n de apps con Firebase Google Analytics Test Flight","title":"Bibliograf\u00eda"},{"location":"teoria/icloud/icloud.html","text":"iCloud y CloudKit \u00b6 iCloud \u00b6 iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros. Filosof\u00eda de iCloud para el usuario de iOS \u00b6 Un escenario frecuente es que un usuario tenga una app instalada en m\u00e1s de un dispositivo (un iPhone y un iPad, por ejemplo). Por ejemplo es muy com\u00fan usar la app de fotos, la del calendario, o las notas en cualquier dispositivo. En este escenario, la idea principal de iCloud es que el usuario pueda pasar de un dispositivo a otro y seguir trabajando con el mismo estado de la app tal y como la dej\u00f3 en el dispositivo anterior. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud. Cuenta iCloud \u00b6 Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID. Casi todos los usuarios de dispositivos Apple tienen activada esta cuenta. Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos asociados al mismo Apple ID: Recordatorios, Notas, etc. El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. De forma gratuita Apple proporciona 5Gb de espacio en la cuenta de iCloud. Nota La cuenta de iCloud puede activarse desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos . Distintas APIs \u00b6 Bajo el nombre gen\u00e9rico de iCloud, existen distintas APIs que Apple ha ido proporcionando a los desarrolladores para gestionar datos asociados a la cuenta de usuario: Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit : nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en la gesti\u00f3n en la nube de registros con diccionarios clave-valor, con un enfoque muy similar a las tecnolog\u00edas NoSQL. Se trata de un API de peticiones a los servidores en la nube, que no mantiene un estado local. Es conveniente usarla en combinaci\u00f3n con Core Data, si queremos hacer persistentes en local los datos existentes en la nube. Basada en peticiones y respuestas as\u00edncronas. Vamos a ver en esta sesi\u00f3n el almacenamiento clave-valor y CloudKit , que son las APIs m\u00e1s usadas. Preparaci\u00f3n de aprovisionamiento y permisos para iCloud \u00b6 Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo autom\u00e1ticamente desde Xcode. Creaci\u00f3n del App ID \u00b6 Para trabajar con iCloud clave-valor puedes utilizar el perfil de aprovisionamiento Master Moviles iCloud creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.iCloud . Tambi\u00e9n hemos actualizado el perfil Master Moviles ToDoList para incluir los permisos de uso de iCloud y CloudKit. Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Hemos creado el permiso (App ID) Master Moviles iCloud con el bundle name es.ua.mastermoviles.iCloud que incluye la capacidad de iCloud. Aparece un bot\u00f3n junto al permiso de iCloud porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). Pero es suficiente para trabajar con iCloud clave-valor. iCloud clave-valor \u00b6 API de almacenamiento clave-valor \u00b6 Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para gestionar estos valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: let iCloudStore = NSUbiquitousKeyValueStore . default M\u00e9todo synchronize \u00b6 func synchronize () -> Bool Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano. Ejemplo de uso de synchronize al lanzar la app \u00b6 @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( \"Sincronizaci\u00f3n OK\" ) } else { print ( \"Problemas en la sincronizaci\u00f3n\" ) } } ... } Guardar valores en el almac\u00e9n de claves-valor \u00b6 Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: store . set ( 100 , forKey : \"puntuacion\" ) Obtenci\u00f3n de valores del almac\u00e9n de claves-valor \u00b6 Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) -> [Any]? bool(forKey: String) -> Bool dictionary(forKey: String) -> [String : Any]? string(forKey: String) -> String? longLong(forKey: String) -> Int64 ... forKey es el String que es la clave en el almac\u00e9n de claves-valor. Devuelve el valor asociado a la clave o nil si la clave no existe (0 en el caso de los m\u00e9todos que devuelven un valor num\u00e9rico). Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: let puntuacion = Int ( store . longLong ( forKey : \"puntuacion\" )) En la aplicaci\u00f3n ejemplo que veremos despu\u00e9s en la demostraci\u00f3n tenemos el siguiente c\u00f3digo que sincroniza el valor actual de la interfaz de usuario (una etiqueta con un valor) con el valor del almac\u00e9n de iCloud. class ViewController : UIViewController { let store = NSUbiquitousKeyValueStore . default override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. let valoriCloud = Int ( store . longLong ( forKey : \"valor\" )) print ( \"Valor cargado de iCloud: \\( valoriCloud ) \" ) self . muestra ( valor : valoriCloud ) } @IBAction func pulsadoStepper ( _ sender : UIStepper ) { let valorPulsado : Int = Int ( sender . value ) store . set ( valorPulsado , forKey : \"valor\" ) store . synchronize () self . muestra ( valor : valorPulsado ) } Definici\u00f3n de un observador de cambios \u00b6 Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado. Por ejemplo, en el siguiente c\u00f3digo se registra como observador un m\u00e9todo de la propia clase AppDelegate : @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( \"Sincronizaci\u00f3n OK\" ) } else { print ( \"Problemas en la sincronizaci\u00f3n\" ) } NotificationCenter . default . addObserver ( self , selector : #selector ( muestraValoriCloud ( notification :)), name : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : nil ) return true } @objc func muestraValoriCloud ( notification : Notification ){ let valoriCloud = Int ( store . longLong ( forKey : \"valor\" )) print ( \"Recibida notificaci\u00f3n del sistema con el valor: \\( valoriCloud ) \" ) // Actualizamos el valor en el controller let application = UIApplication . shared if let controller = application . windows [ 0 ]. rootViewController { let miController : ViewController = controller as ! ViewController miController . muestra ( valor : valoriCloud ) } } Demo \u00b6 Descargamos la app iCloudKeyValue desde este enlace , comentamos su funcionamiento y a\u00f1adimos el c\u00f3digo para incorporar iCloud clave valor: Primero para que vaya grabando en iCloud el \u00faltimo n\u00famero pulsado, y para que se obtenga cuando arranca la app. Lo probamos primero en el simulador y despu\u00e9s en el dispositivo f\u00edsico. Nos logeamos con nuestra cuenta de iCloud en el simulador y probamos si se comparte la informaci\u00f3n con el dispositivo f\u00edsico. Nos logeamos despu\u00e9s en otro dispositivo f\u00edsico (un iPad) y probamos si se comparte la informaci\u00f3n entre los dos dispositivos f\u00edsicos. Por \u00faltimo a\u00f1adimos el c\u00f3digo para que se actualice la informaci\u00f3n entre dos dispositivos con una notificaci\u00f3n del sistema. CloudKit \u00b6 Introducci\u00f3n a CloudKit \u00b6 El origen de CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Permite gestionar datos remotos ubicados en los servidores de iCloud propios de Apple. En los datos propios de la aplicaci\u00f3n (datos privados del usuario) el almacenamiento se imputa a las cuentas iCloud de los usuarios. Existe la posibilidad de datos p\u00fablicos, en un almacenamiento gestionado por el desarrollador (gratuito hasta una capacidad y de pago a partir de ella). Permite datos estructurados y datos bulk . CloudKit proporciona una base de datos NoSQL en la nube, mediante la que las aplicaciones pueden guardar, consultar y realizar b\u00fasquedas de registros. Tecnolog\u00eda de transporte \u00b6 CloudKit no proporciona ninguna forma de almacenar datos localmente. Los datos obtenidos se almacenan en la aplicaci\u00f3n. Si queremos hacerlos persistentes de forma local (para que est\u00e9n disponibles sin conexi\u00f3n) podemos utilizar otra tecnolog\u00eda como Core Data. Es un servicio para mover datos a y desde la nube iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para la nube y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen. Elementos de CloudKit \u00b6 Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias Contenedores \u00b6 M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . En general, un contenedor va a contener todos los datos p\u00fablicos y de usuarios de una aplicaci\u00f3n. Tambi\u00e9n es posible que m\u00e1s de una app del mismo desarrollador compartan un \u00fanico contenedor. Los datos se encuentran almacenados en un contenedor. Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Es posible compartir un contenedor entre varias apps , siempre que hayan sido desarrolladas por el mismo desarrollador. Cada contenedor tiene un nombre \u00fanico que por defecto est\u00e1 asociado al bundle id de la app. El nombre es iCloud.<bundleId> . Los contenedores no pueden borrarse. En el portal de desarrolladores de la UA hemos acumulado muchos nombres antiguos de contenedores que ya no se usan. Clase CKContainer \u00b6 La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta. Datos p\u00fablicos y privados \u00b6 Se pueden guardar datos de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los datos p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los datos privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar datos en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro. Bases de datos \u00b6 Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos: Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase Dashboard \u00b6 El CloudKit Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores y bases de datos. Podemos acceder desde la cuenta de desarrollador de la universidad: La interfaz web permite: Crear, visualizar, editar y borrar tipos de registros, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue Ejemplo de visualizaci\u00f3n de tipos de registros: CloudKit trabaja sobre registros en iCloud \u00b6 CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. A diferencia de las bases de datos relacionales tradicionales, en las que el modelo de datos se basa en tablas, en CloudKit se trabaja con tipos de registros . Un tipo de registro se define din\u00e1micamente, en tiempo de ejecuci\u00f3n de la app, por un nombre y un conjunto de claves. Una instancia concreta de un registro tiene un identificador \u00fanico y es un diccionario de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros. Por ejemplo, en la siguiente figura se muestran dos tipos de registros con sus campos asociados. El nombre del primer tipo de registro es Artwork y el del segundo Artist . Nota En iCloud se dispone de dos tipos de entornos: el entorno de desarrollo y el de producci\u00f3n . Cuando se desarrolla la app se construyen de forma din\u00e1mica los tipos de registros, con sus identificadores y sus campos. Despu\u00e9s se debe desplegar estos tipos de registros al entorno de producci\u00f3n, en donde ya no es posible modificar los tipos de registro. Registros \u00b6 Una base de datos est\u00e1 compuesta de registros: Las instancias de registro son objetos de la clase CKRecord . Cada instancia es un conjunto de parejas clave y valor (determinados por el tipo de registro) y tiene un identificador \u00fanico, un objeto de la clase CKRecord.ID . Este identificador \u00fanico podemos proporcionarlo en el momento de creaci\u00f3n del registro o podemos dejar que se inicializa autom\u00e1ticamente, si no lo definimos. Para crear una instancia de registro es necesario identificar el tipo de registro, definido por un String : let artistaRecord = CKRecord ( recordType : \"Artista\" ) Si es la primera vez que se crea un registro de ese tipo, se crea el tipo de registro din\u00e1micamente en la base de datos. Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): artistaRecord [ \"artista\" ] = \"Jonhn Lennon\" let formatter = DateFormatter () formatter . dateFormat = \"yyyy/MM/dd\" artistaRecord [ \"fechanacimiento\" ] = formatter . date ( from : \"1940/10/09\" ) ! Datos en los registros \u00b6 Es posible definir los siguientes tipos de valores que pueden haber en los campos de los registros: NSString ( String ): Cadenas NSNumber ( Int , Double , ...): N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior Grabaci\u00f3n de registros \u00b6 Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). privateDB . save ( toDoItemRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) in print ( \"Error: \\( String ( describing : error )) \" ) }) Relaciones entre registros: referencias \u00b6 Es posible definir relaciones entre los registros. Por ejemplo un Artwork est\u00e1 relacionado con un Artist . Son similares a las claves ajenas en el tradicional modelo relacional con las que se implementan relaciones muchos-a-uno. La clase CKReference es la utilizada para definir estas relaciones: itemRecord [ \"owningList\" ] = CKReference ( record : listRecord , action : . deleteSelf ) La constante .deleteSelf indica que si el registro referenciado se borra, el propio registro tambi\u00e9n debe borrarse (borrado en cascada). La otra posible acci\u00f3n es .none . Queries \u00b6 Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation . Por ejemplo, la query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual es la siguiente (se ha a\u00f1adido c\u00f3digo de ejemplo en el que se actualiza el array de tareas por hacer y se actualiza la vista de la tabla) let privateDB = CKContainer . default (). privateCloudDatabase let query = CKQuery ( recordType : \"Tarea\" , predicate : NSPredicate ( value : true )) privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { if let nombre = result [ \"nombre\" ] { let toDoItem = ToDoItem ( nombre : nombre as ! String , publica : false ) self . toDoItems . append ( toDoItem ) } } DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) } else { print ( \"Query error: \\( String ( describing : error )) \" ) } }) Importante Para que funcione la consulta que recupera todos los registros de un tipo hay que crear en el dashboard un \u00edndice queryable sobre el campo nativo recordName . Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) let predicate = NSPredicate ( format : \"nombre BEGINSWITH 'Limpiar'\" ) let predicate = NSPredicate ( format : \"favoriteColors CONTAINS 'red'\" ) Operaciones con registros obtenidos \u00b6 Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: func deleteTarea ( _ toDoItem : ToDoItem ) { let query = CKQuery ( recordType : \"Tarea\" , predicate : NSPredicate ( format : \"nombre == %@\" , argumentArray : [ toDoItem . nombreItem ])) let publicDB = CKContainer . default (). publicCloudDatabase publicDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord publicDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( \"Error: \\( String ( describing : error )) \" ) }) } } }) } Caracter\u00edsticas sociales de CloudKit \u00b6 CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente. Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente. Ejemplo de c\u00f3digo: let container = CKContainer . default () print ( \"Container: \" ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( \"Permiso concedido: \" + \" \\( permissionStatus == CKApplicationPermissionStatus . granted ) \" )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }}) Suscripciones \u00b6 Es posible hacer consultas \"permanentes\" que son ejecutadas en background por el servidor tras cada registro salvado. Generan notificaciones push con los resultados. CloudKit JS \u00b6 CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) Un ejemplo de aplicaci\u00f3n web presentado por Apple en el que se demuestra el uso de esta librer\u00eda CloudKit Catalog Demo \u00b6 App DemoCloudKit \u00b6 Vamos a hacer una demostraci\u00f3n de una sencilla app llamada DemoCloudKit . Est\u00e1 basada en un tutorial de la web raywenderlich.com . Se puede descargar desde este enlace . La app tiene como bundle id es.ua.mastermoviles.DemoCloudKit . Creaci\u00f3n del contenedor \u00b6 Debemos crear un perfil de aprovisionamiento con capacidad de acceso a CloudKit. Para ello creamos primero el identificador del contenedor de CloudKit. Podemos hacerlo desde la p\u00e1gina con el listado de contenedores de CloudKit, pulsando el bot\u00f3n + junto a Identifiers . Tambi\u00e9n se puede hacer autom\u00e1ticamente desde Xcode si somos administradores de la cuenta con la que estamos logeados. Despu\u00e9s debemos rellenar el identificador del contenedor. Como el bundle id de la app es es.ua.mastermoviles.DemoCloudKit el identificador del contenedor ser\u00e1: iCloud.es.ua.mastermoviles.DemoCloudKit Hay que tener mucho cuidado porque una vez creados los identificadores de contenedores no se pueden borrar. Creaci\u00f3n del App ID y asignaci\u00f3n del contenedor \u00b6 Una vez creado el identificador del contenedor, debemos crear el App ID con el permiso para iCloud y seleccionar el contenedor que vamos a usar en ese App ID . Creamos el App ID con el bundle ID de la aplicaci\u00f3n. Marcamos el servicio iCloud y configuramos el contenedor. A\u00f1adimos el contenedor reci\u00e9n creado, el que tiene el identificador iCloud.es.ua.mastermoviles.DemoCloudKit . Creaci\u00f3n del perfil de aprovisionamiento \u00b6 Creamos para la demo el perfil de aprovisionamiento con el App ID anterior. Actualizaci\u00f3n de capacidades de la app ToDoList \u00b6 Escribimos como Bundle Identifier el definido por el App ID. En el caso de la demo usaremos es.ua.mastermoviles.DemoCloudKit . Actualizamos las capacidades en Xcode a\u00f1adiendo la capacidad iCloud y activando CloudKit . Seleccionamos el equipo de la UA y autom\u00e1ticamente se cargar\u00e1 el perfil reci\u00e9n creado. Dashboard \u00b6 Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud. El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. Revisamos el esquema de datos y los registros. Hemos creado manualmente dos tipos de registros: Establishmet Note Y hemos creado un par de registros concretos de esos tipos de registros. Examinamos los tipos de registro, sus campos, los datos, las relaciones y las bases de datos en las que est\u00e1n creados. Ejecutamos la app y mostramos el c\u00f3digo \u00b6 En la app podemos navegar por los establecimientos y vemos como se muestran sus caracter\u00edsticas. Tambi\u00e9n podemos comprobar las notas privadas creadas asociadas con cada establecimiento. Probamos a modificar alg\u00fan dato en el dashboard y a comprobar que se actualiza en la aplicaci\u00f3n. Todo el c\u00f3digo relacionado con CloudKit est\u00e1 en la carpeta Model . Se definen dos clases que mapean los registros: Establishment.swift y Note.swift . La clase Model.swift contiene m\u00e9todos para recuperar los registros de iCloud mediante queries . Referencias \u00b6 P\u00e1gina principal tecnolog\u00eda CloudKit CloudKit Documentation CloudKit Quick Start iCloud Design Guide Providing User Access to CloudKit Data Changing Access Controls on User Data Responding to Requests to Delete Data Identifying an App's Containers CloudKit JS Tutorial de raywenderlich.com sobre CloudKit","title":"4. iCloud y CloudKit"},{"location":"teoria/icloud/icloud.html#icloud-y-cloudkit","text":"","title":"iCloud y CloudKit"},{"location":"teoria/icloud/icloud.html#icloud","text":"iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID. iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo. Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros.","title":"iCloud"},{"location":"teoria/icloud/icloud.html#filosofia-de-icloud-para-el-usuario-de-ios","text":"Un escenario frecuente es que un usuario tenga una app instalada en m\u00e1s de un dispositivo (un iPhone y un iPad, por ejemplo). Por ejemplo es muy com\u00fan usar la app de fotos, la del calendario, o las notas en cualquier dispositivo. En este escenario, la idea principal de iCloud es que el usuario pueda pasar de un dispositivo a otro y seguir trabajando con el mismo estado de la app tal y como la dej\u00f3 en el dispositivo anterior. Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud.","title":"Filosof\u00eda de iCloud para el usuario de iOS"},{"location":"teoria/icloud/icloud.html#cuenta-icloud","text":"Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID. Casi todos los usuarios de dispositivos Apple tienen activada esta cuenta. Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos asociados al mismo Apple ID: Recordatorios, Notas, etc. El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. De forma gratuita Apple proporciona 5Gb de espacio en la cuenta de iCloud. Nota La cuenta de iCloud puede activarse desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos .","title":"Cuenta iCloud"},{"location":"teoria/icloud/icloud.html#distintas-apis","text":"Bajo el nombre gen\u00e9rico de iCloud, existen distintas APIs que Apple ha ido proporcionando a los desarrolladores para gestionar datos asociados a la cuenta de usuario: Almacenamiento clave-valor en iCloud : para mantener el estado de la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.). Documentos en iCloud : para gestionar documentos en la nube y mantenerlos sincronizados entre iPhone/iPad/Mac. iCloud con Core Data : para mantener de forma autom\u00e1tica en iCloud una copia de todos los datos de la app gestionados con Core Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las \u00faltimas versiones. CloudKit : nueva tecnolog\u00eda a partir de iOS 8 que permite mayor flexibilidad y control. Basado en la gesti\u00f3n en la nube de registros con diccionarios clave-valor, con un enfoque muy similar a las tecnolog\u00edas NoSQL. Se trata de un API de peticiones a los servidores en la nube, que no mantiene un estado local. Es conveniente usarla en combinaci\u00f3n con Core Data, si queremos hacer persistentes en local los datos existentes en la nube. Basada en peticiones y respuestas as\u00edncronas. Vamos a ver en esta sesi\u00f3n el almacenamiento clave-valor y CloudKit , que son las APIs m\u00e1s usadas.","title":"Distintas APIs"},{"location":"teoria/icloud/icloud.html#preparacion-de-aprovisionamiento-y-permisos-para-icloud","text":"Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA. Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso ( capabilities ) en la app con XCode. Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo autom\u00e1ticamente desde Xcode.","title":"Preparaci\u00f3n de aprovisionamiento y permisos para iCloud"},{"location":"teoria/icloud/icloud.html#creacion-del-app-id","text":"Para trabajar con iCloud clave-valor puedes utilizar el perfil de aprovisionamiento Master Moviles iCloud creado en el member center del equipo de la universidad. El bundle ID de la app debe ser es.ua.mastermoviles.iCloud . Tambi\u00e9n hemos actualizado el perfil Master Moviles ToDoList para incluir los permisos de uso de iCloud y CloudKit. Se debe crear el App ID que otorgue la capacidad de acceso a iCloud. Hemos creado el permiso (App ID) Master Moviles iCloud con el bundle name es.ua.mastermoviles.iCloud que incluye la capacidad de iCloud. Aparece un bot\u00f3n junto al permiso de iCloud porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). Pero es suficiente para trabajar con iCloud clave-valor.","title":"Creaci\u00f3n del App ID"},{"location":"teoria/icloud/icloud.html#icloud-clave-valor","text":"","title":"iCloud clave-valor"},{"location":"teoria/icloud/icloud.html#api-de-almacenamiento-clave-valor","text":"Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id. Para gestionar estos valores debemos usar la clase NSUbiquitousKeyValueStore . Puedes almacenar String s, valores escalares como BOOL o Double , diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: NSNumber , NSString , NSDate , NSData , NSArray , or NSDictionary . El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves. Para obtener el objeto compartido iCloudKeyValueStore: let iCloudStore = NSUbiquitousKeyValueStore . default","title":"API de almacenamiento clave-valor"},{"location":"teoria/icloud/icloud.html#metodo-synchronize","text":"func synchronize () -> Bool Devuelve true si las claves y valores en memoria y en disco est\u00e1n sincronizados o false si ha sucedido alg\u00fan error. Por ejemplo, devuelve false si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud. Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud. Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos. No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda. Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano.","title":"M\u00e9todo synchronize"},{"location":"teoria/icloud/icloud.html#ejemplo-de-uso-de-synchronize-al-lanzar-la-app","text":"@UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( \"Sincronizaci\u00f3n OK\" ) } else { print ( \"Problemas en la sincronizaci\u00f3n\" ) } } ... }","title":"Ejemplo de uso de synchronize al lanzar la app"},{"location":"teoria/icloud/icloud.html#guardar-valores-en-el-almacen-de-claves-valor","text":"Para actualizar los valores hay que usar los m\u00e9todos set . El primer par\u00e1metro es el valor a guardar y el segundo la clave: set(Bool, forKey: String) set(Double, forKey: String) set(Int64, forKey: String) set([Any]?, forKey: String) ... Por ejemplo, set(Int64, forKey: String) actualiza en el almac\u00e9n el valor long long ( Int64 ) asoci\u00e1ndolo a una clave especificada: store . set ( 100 , forKey : \"puntuacion\" )","title":"Guardar valores en el almac\u00e9n de claves-valor"},{"location":"teoria/icloud/icloud.html#obtencion-de-valores-del-almacen-de-claves-valor","text":"Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena): array(forKey: String) -> [Any]? bool(forKey: String) -> Bool dictionary(forKey: String) -> [String : Any]? string(forKey: String) -> String? longLong(forKey: String) -> Int64 ... forKey es el String que es la clave en el almac\u00e9n de claves-valor. Devuelve el valor asociado a la clave o nil si la clave no existe (0 en el caso de los m\u00e9todos que devuelven un valor num\u00e9rico). Por ejemplo, longlong(forKey: String) devuelve el valor Int64 asociado a una clave especificada: let puntuacion = Int ( store . longLong ( forKey : \"puntuacion\" )) En la aplicaci\u00f3n ejemplo que veremos despu\u00e9s en la demostraci\u00f3n tenemos el siguiente c\u00f3digo que sincroniza el valor actual de la interfaz de usuario (una etiqueta con un valor) con el valor del almac\u00e9n de iCloud. class ViewController : UIViewController { let store = NSUbiquitousKeyValueStore . default override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. let valoriCloud = Int ( store . longLong ( forKey : \"valor\" )) print ( \"Valor cargado de iCloud: \\( valoriCloud ) \" ) self . muestra ( valor : valoriCloud ) } @IBAction func pulsadoStepper ( _ sender : UIStepper ) { let valorPulsado : Int = Int ( sender . value ) store . set ( valorPulsado , forKey : \"valor\" ) store . synchronize () self . muestra ( valor : valorPulsado ) }","title":"Obtenci\u00f3n de valores del almac\u00e9n de claves-valor"},{"location":"teoria/icloud/icloud.html#definicion-de-un-observador-de-cambios","text":"Adem\u00e1s de almacenar los valores podemos recibir notificaciones ( NSNotification gestionadas por el NotificationCenter ) de cambio de los valores en otros dispositivos conectados a iCloud. En el lanzamiento del app hay que registrarse para la notificaci\u00f3n NSUbiquitousKeyValueStoreDidChangeExternallyNotification . La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores. El diccionario atributo userInfo de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados. El objeto en la notificaci\u00f3n es el NSUbiquitousKeyValueStore cuyo contenido ha cambiado. Por ejemplo, en el siguiente c\u00f3digo se registra como observador un m\u00e9todo de la propia clase AppDelegate : @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate { var window : UIWindow ? let store = NSUbiquitousKeyValueStore . default func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplication . LaunchOptionsKey : Any ]?) -> Bool { // Override point for customization after application launch. if ( store . synchronize ()) { print ( \"Sincronizaci\u00f3n OK\" ) } else { print ( \"Problemas en la sincronizaci\u00f3n\" ) } NotificationCenter . default . addObserver ( self , selector : #selector ( muestraValoriCloud ( notification :)), name : NSUbiquitousKeyValueStore . didChangeExternallyNotification , object : nil ) return true } @objc func muestraValoriCloud ( notification : Notification ){ let valoriCloud = Int ( store . longLong ( forKey : \"valor\" )) print ( \"Recibida notificaci\u00f3n del sistema con el valor: \\( valoriCloud ) \" ) // Actualizamos el valor en el controller let application = UIApplication . shared if let controller = application . windows [ 0 ]. rootViewController { let miController : ViewController = controller as ! ViewController miController . muestra ( valor : valoriCloud ) } }","title":"Definici\u00f3n de un observador de cambios"},{"location":"teoria/icloud/icloud.html#demo","text":"Descargamos la app iCloudKeyValue desde este enlace , comentamos su funcionamiento y a\u00f1adimos el c\u00f3digo para incorporar iCloud clave valor: Primero para que vaya grabando en iCloud el \u00faltimo n\u00famero pulsado, y para que se obtenga cuando arranca la app. Lo probamos primero en el simulador y despu\u00e9s en el dispositivo f\u00edsico. Nos logeamos con nuestra cuenta de iCloud en el simulador y probamos si se comparte la informaci\u00f3n con el dispositivo f\u00edsico. Nos logeamos despu\u00e9s en otro dispositivo f\u00edsico (un iPad) y probamos si se comparte la informaci\u00f3n entre los dos dispositivos f\u00edsicos. Por \u00faltimo a\u00f1adimos el c\u00f3digo para que se actualice la informaci\u00f3n entre dos dispositivos con una notificaci\u00f3n del sistema.","title":"Demo"},{"location":"teoria/icloud/icloud.html#cloudkit","text":"","title":"CloudKit"},{"location":"teoria/icloud/icloud.html#introduccion-a-cloudkit","text":"El origen de CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8. Permite gestionar datos remotos ubicados en los servidores de iCloud propios de Apple. En los datos propios de la aplicaci\u00f3n (datos privados del usuario) el almacenamiento se imputa a las cuentas iCloud de los usuarios. Existe la posibilidad de datos p\u00fablicos, en un almacenamiento gestionado por el desarrollador (gratuito hasta una capacidad y de pago a partir de ella). Permite datos estructurados y datos bulk . CloudKit proporciona una base de datos NoSQL en la nube, mediante la que las aplicaciones pueden guardar, consultar y realizar b\u00fasquedas de registros.","title":"Introducci\u00f3n a CloudKit"},{"location":"teoria/icloud/icloud.html#tecnologia-de-transporte","text":"CloudKit no proporciona ninguna forma de almacenar datos localmente. Los datos obtenidos se almacenan en la aplicaci\u00f3n. Si queremos hacerlos persistentes de forma local (para que est\u00e9n disponibles sin conexi\u00f3n) podemos utilizar otra tecnolog\u00eda como Core Data. Es un servicio para mover datos a y desde la nube iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData). El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para la nube y recibir actualizaciones posteriores sobre esos datos. Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente. Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen.","title":"Tecnolog\u00eda de transporte"},{"location":"teoria/icloud/icloud.html#elementos-de-cloudkit","text":"Contenedores Bases de datos Registros Zonas de registros Identificadores Referencias","title":"Elementos de CloudKit"},{"location":"teoria/icloud/icloud.html#contenedores","text":"M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas contenedores . En general, un contenedor va a contener todos los datos p\u00fablicos y de usuarios de una aplicaci\u00f3n. Tambi\u00e9n es posible que m\u00e1s de una app del mismo desarrollador compartan un \u00fanico contenedor. Los datos se encuentran almacenados en un contenedor. Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador. Es posible compartir un contenedor entre varias apps , siempre que hayan sido desarrolladas por el mismo desarrollador. Cada contenedor tiene un nombre \u00fanico que por defecto est\u00e1 asociado al bundle id de la app. El nombre es iCloud.<bundleId> . Los contenedores no pueden borrarse. En el portal de desarrolladores de la UA hemos acumulado muchos nombres antiguos de contenedores que ya no se usan.","title":"Contenedores"},{"location":"teoria/icloud/icloud.html#clase-ckcontainer","text":"La clase con la que trabajar para gestionar el contenedor es CKContainer La debemos usar para: Obtener las bases de datos p\u00fablicas y privadas Obtener el identificador del contenedor Determinar el estado del acceso de la cuenta iCloud del usuario Solicitar y determinar permisos de la app Ejecutar operaciones sobre el contenedor Descubrir registros de usuarios En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta.","title":"Clase CKContainer"},{"location":"teoria/icloud/icloud.html#datos-publicos-y-privados","text":"Se pueden guardar datos de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada . Los datos p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud. Los datos privados son s\u00f3lo visibles por el usuario actual logeado en iCloud. Para salvar datos en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro.","title":"Datos p\u00fablicos y privados"},{"location":"teoria/icloud/icloud.html#bases-de-datos","text":"Las bases de datos son instancias de la clase CKDatabase Cada app tiene acceso a dos bases de datos: Base de datos p\u00fablica Base de datos privada Se obtienen a trav\u00e9s del CKContainer : let container = CKContainer . default () let privateDB = container . privateCloudDatabase let publicDB = container . publicCloudDatabase","title":"Bases de datos"},{"location":"teoria/icloud/icloud.html#dashboard","text":"El CloudKit Dashboard es una interfaz web con la que podemos gestionar nuestros contenedores y bases de datos. Podemos acceder desde la cuenta de desarrollador de la universidad: La interfaz web permite: Crear, visualizar, editar y borrar tipos de registros, registros, etc. Estad\u00edsticas de uso Administraci\u00f3n de acceso Configuraci\u00f3n de despliegue Ejemplo de visualizaci\u00f3n de tipos de registros:","title":"Dashboard"},{"location":"teoria/icloud/icloud.html#cloudkit-trabaja-sobre-registros-en-icloud","text":"CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud. A diferencia de las bases de datos relacionales tradicionales, en las que el modelo de datos se basa en tablas, en CloudKit se trabaja con tipos de registros . Un tipo de registro se define din\u00e1micamente, en tiempo de ejecuci\u00f3n de la app, por un nombre y un conjunto de claves. Una instancia concreta de un registro tiene un identificador \u00fanico y es un diccionario de parejas clave-valor con cada clave representando un campo del registro . El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros), Es posible guardar en los valores referencias a otros registros , permitiendo definir relaciones entre registros. Por ejemplo, en la siguiente figura se muestran dos tipos de registros con sus campos asociados. El nombre del primer tipo de registro es Artwork y el del segundo Artist . Nota En iCloud se dispone de dos tipos de entornos: el entorno de desarrollo y el de producci\u00f3n . Cuando se desarrolla la app se construyen de forma din\u00e1mica los tipos de registros, con sus identificadores y sus campos. Despu\u00e9s se debe desplegar estos tipos de registros al entorno de producci\u00f3n, en donde ya no es posible modificar los tipos de registro.","title":"CloudKit trabaja sobre registros en iCloud"},{"location":"teoria/icloud/icloud.html#registros","text":"Una base de datos est\u00e1 compuesta de registros: Las instancias de registro son objetos de la clase CKRecord . Cada instancia es un conjunto de parejas clave y valor (determinados por el tipo de registro) y tiene un identificador \u00fanico, un objeto de la clase CKRecord.ID . Este identificador \u00fanico podemos proporcionarlo en el momento de creaci\u00f3n del registro o podemos dejar que se inicializa autom\u00e1ticamente, si no lo definimos. Para crear una instancia de registro es necesario identificar el tipo de registro, definido por un String : let artistaRecord = CKRecord ( recordType : \"Artista\" ) Si es la primera vez que se crea un registro de ese tipo, se crea el tipo de registro din\u00e1micamente en la base de datos. Una vez creado el registro se a\u00f1aden valores a sus campos (que tambi\u00e9n se crean din\u00e1micamente): artistaRecord [ \"artista\" ] = \"Jonhn Lennon\" let formatter = DateFormatter () formatter . dateFormat = \"yyyy/MM/dd\" artistaRecord [ \"fechanacimiento\" ] = formatter . date ( from : \"1940/10/09\" ) !","title":"Registros"},{"location":"teoria/icloud/icloud.html#datos-en-los-registros","text":"Es posible definir los siguientes tipos de valores que pueden haber en los campos de los registros: NSString ( String ): Cadenas NSNumber ( Int , Double , ...): N\u00fameros, incluidos enteros y punto flotante. NSData : Bytes arbitrarios de datos (por ejemplo, la serializaci\u00f3n binaria de un struct . No usar para almacenar ficheros binarios grandes, usar CKAsset en su lugar. NSDate : Fechas CLLocation : Coordenadas geogr\u00e1ficas CKReference : Referencias a otros registros para crear relaciones entre ellos. CKAsset : Fichero binario. Arrays de todo lo anterior","title":"Datos en los registros"},{"location":"teoria/icloud/icloud.html#grabacion-de-registros","text":"Se a\u00f1aden registros a una base de datos usando la funci\u00f3n save , a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar). privateDB . save ( toDoItemRecord , completionHandler : { ( record : CKRecord ?, error : Error ?) in print ( \"Error: \\( String ( describing : error )) \" ) })","title":"Grabaci\u00f3n de registros"},{"location":"teoria/icloud/icloud.html#relaciones-entre-registros-referencias","text":"Es posible definir relaciones entre los registros. Por ejemplo un Artwork est\u00e1 relacionado con un Artist . Son similares a las claves ajenas en el tradicional modelo relacional con las que se implementan relaciones muchos-a-uno. La clase CKReference es la utilizada para definir estas relaciones: itemRecord [ \"owningList\" ] = CKReference ( record : listRecord , action : . deleteSelf ) La constante .deleteSelf indica que si el registro referenciado se borra, el propio registro tambi\u00e9n debe borrarse (borrado en cascada). La otra posible acci\u00f3n es .none .","title":"Relaciones entre registros: referencias"},{"location":"teoria/icloud/icloud.html#queries","text":"Para realizar una consulta se debe utilizar la clase CKQuery para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos. La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados. El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo perform Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa nil para la zona por defecto). Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una CKQueryOperation . Por ejemplo, la query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual es la siguiente (se ha a\u00f1adido c\u00f3digo de ejemplo en el que se actualiza el array de tareas por hacer y se actualiza la vista de la tabla) let privateDB = CKContainer . default (). privateCloudDatabase let query = CKQuery ( recordType : \"Tarea\" , predicate : NSPredicate ( value : true )) privateDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { if let nombre = result [ \"nombre\" ] { let toDoItem = ToDoItem ( nombre : nombre as ! String , publica : false ) self . toDoItems . append ( toDoItem ) } } DispatchQueue . main . async ( execute : { self . tableView . reloadData () }) } else { print ( \"Query error: \\( String ( describing : error )) \" ) } }) Importante Para que funcione la consulta que recupera todos los registros de un tipo hay que crear en el dashboard un \u00edndice queryable sobre el campo nativo recordName . Otros ejemplos de predicados (consultar CKQuery y NSPredicate ) let predicate = NSPredicate ( format : \"nombre BEGINSWITH 'Limpiar'\" ) let predicate = NSPredicate ( format : \"favoriteColors CONTAINS 'red'\" )","title":"Queries"},{"location":"teoria/icloud/icloud.html#operaciones-con-registros-obtenidos","text":"Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre: func deleteTarea ( _ toDoItem : ToDoItem ) { let query = CKQuery ( recordType : \"Tarea\" , predicate : NSPredicate ( format : \"nombre == %@\" , argumentArray : [ toDoItem . nombreItem ])) let publicDB = CKContainer . default (). publicCloudDatabase publicDB . perform ( query , inZoneWith : nil , completionHandler : { ( results , error ) in if error == nil { for result in results ! { let record : CKRecord ! = result as CKRecord publicDB . delete ( withRecordID : record . recordID , completionHandler : { ( recordID , error ) in print ( \"Error: \\( String ( describing : error )) \" ) }) } } }) }","title":"Operaciones con registros obtenidos"},{"location":"teoria/icloud/icloud.html#caracteristicas-sociales-de-cloudkit","text":"CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si: Est\u00e1n en los contactos del usuario actual Han dado el permiso a la app Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n requestApplicationPermission Se le pasa como par\u00e1metro completionHandler el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el applicationPermissionStatus (constante que indica lo que ha respondido el usuario) y un objeto error que ser\u00e1 nil si todo ha ido correctamente. Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id. La funci\u00f3n discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b) de CKContainer permite obtener estos usuarios Se le pasa como par\u00e1metro completionHandler , una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros: Un array de objetos CKUser\u200bIdentity que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo. Un objeto error si sucede alg\u00fan problema, o nil si los IDs se han obtenido correctamente. Ejemplo de c\u00f3digo: let container = CKContainer . default () print ( \"Container: \" ) print ( container ) // Solicitamos permiso para que el usuario se haga descubrible container . requestApplicationPermission ( CKApplicationPermissions . userDiscoverability , completionHandler : { ( permissionStatus , error ) in print ( \"Permiso concedido: \" + \" \\( permissionStatus == CKApplicationPermissionStatus . granted ) \" )}) // Obtenemos los usuarios de la app que han dado permiso container . discoverAllIdentities ( completionHandler : { ( optUsers , error ) in if let users = optUsers { for user in users { print ( user ) // usamos user.userRecordID para buscar // registros p\u00fablicos de un usuario } }})","title":"Caracter\u00edsticas sociales de CloudKit"},{"location":"teoria/icloud/icloud.html#suscripciones","text":"Es posible hacer consultas \"permanentes\" que son ejecutadas en background por el servidor tras cada registro salvado. Generan notificaciones push con los resultados.","title":"Suscripciones"},{"location":"teoria/icloud/icloud.html#cloudkit-js","text":"CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit. Lanzado en WWDC 2015. Necesita un token generado en el dashboard para acceso seguro al API en la conexi\u00f3n servidor-servidor. Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit. Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.) Un ejemplo de aplicaci\u00f3n web presentado por Apple en el que se demuestra el uso de esta librer\u00eda CloudKit Catalog","title":"CloudKit JS"},{"location":"teoria/icloud/icloud.html#demo_1","text":"","title":"Demo"},{"location":"teoria/icloud/icloud.html#app-democloudkit","text":"Vamos a hacer una demostraci\u00f3n de una sencilla app llamada DemoCloudKit . Est\u00e1 basada en un tutorial de la web raywenderlich.com . Se puede descargar desde este enlace . La app tiene como bundle id es.ua.mastermoviles.DemoCloudKit .","title":"App DemoCloudKit"},{"location":"teoria/icloud/icloud.html#creacion-del-contenedor","text":"Debemos crear un perfil de aprovisionamiento con capacidad de acceso a CloudKit. Para ello creamos primero el identificador del contenedor de CloudKit. Podemos hacerlo desde la p\u00e1gina con el listado de contenedores de CloudKit, pulsando el bot\u00f3n + junto a Identifiers . Tambi\u00e9n se puede hacer autom\u00e1ticamente desde Xcode si somos administradores de la cuenta con la que estamos logeados. Despu\u00e9s debemos rellenar el identificador del contenedor. Como el bundle id de la app es es.ua.mastermoviles.DemoCloudKit el identificador del contenedor ser\u00e1: iCloud.es.ua.mastermoviles.DemoCloudKit Hay que tener mucho cuidado porque una vez creados los identificadores de contenedores no se pueden borrar.","title":"Creaci\u00f3n del contenedor"},{"location":"teoria/icloud/icloud.html#creacion-del-app-id-y-asignacion-del-contenedor","text":"Una vez creado el identificador del contenedor, debemos crear el App ID con el permiso para iCloud y seleccionar el contenedor que vamos a usar en ese App ID . Creamos el App ID con el bundle ID de la aplicaci\u00f3n. Marcamos el servicio iCloud y configuramos el contenedor. A\u00f1adimos el contenedor reci\u00e9n creado, el que tiene el identificador iCloud.es.ua.mastermoviles.DemoCloudKit .","title":"Creaci\u00f3n del App ID y asignaci\u00f3n del contenedor"},{"location":"teoria/icloud/icloud.html#creacion-del-perfil-de-aprovisionamiento","text":"Creamos para la demo el perfil de aprovisionamiento con el App ID anterior.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"teoria/icloud/icloud.html#actualizacion-de-capacidades-de-la-app-todolist","text":"Escribimos como Bundle Identifier el definido por el App ID. En el caso de la demo usaremos es.ua.mastermoviles.DemoCloudKit . Actualizamos las capacidades en Xcode a\u00f1adiendo la capacidad iCloud y activando CloudKit . Seleccionamos el equipo de la UA y autom\u00e1ticamente se cargar\u00e1 el perfil reci\u00e9n creado.","title":"Actualizaci\u00f3n de capacidades de la app ToDoList"},{"location":"teoria/icloud/icloud.html#dashboard_1","text":"Comprobamos los permisos de los miembros del equipo de la universidad en el dashboard de iCloud. El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. Revisamos el esquema de datos y los registros. Hemos creado manualmente dos tipos de registros: Establishmet Note Y hemos creado un par de registros concretos de esos tipos de registros. Examinamos los tipos de registro, sus campos, los datos, las relaciones y las bases de datos en las que est\u00e1n creados.","title":"Dashboard"},{"location":"teoria/icloud/icloud.html#ejecutamos-la-app-y-mostramos-el-codigo","text":"En la app podemos navegar por los establecimientos y vemos como se muestran sus caracter\u00edsticas. Tambi\u00e9n podemos comprobar las notas privadas creadas asociadas con cada establecimiento. Probamos a modificar alg\u00fan dato en el dashboard y a comprobar que se actualiza en la aplicaci\u00f3n. Todo el c\u00f3digo relacionado con CloudKit est\u00e1 en la carpeta Model . Se definen dos clases que mapean los registros: Establishment.swift y Note.swift . La clase Model.swift contiene m\u00e9todos para recuperar los registros de iCloud mediante queries .","title":"Ejecutamos la app y mostramos el c\u00f3digo"},{"location":"teoria/icloud/icloud.html#referencias","text":"P\u00e1gina principal tecnolog\u00eda CloudKit CloudKit Documentation CloudKit Quick Start iCloud Design Guide Providing User Access to CloudKit Data Changing Access Controls on User Data Responding to Requests to Delete Data Identifying an App's Containers CloudKit JS Tutorial de raywenderlich.com sobre CloudKit","title":"Referencias"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html","text":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS \u00b6 Planificaci\u00f3n \u00b6 Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App Entregas de pr\u00e1cticas \u00b6 Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: una semana despu\u00e9s del final de la asignatura (7 de junio) Recomendable realizar los ejercicios semana a semana Recursos \u00b6 En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App","title":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#sesion-0-planificacion-bloque-ios","text":"","title":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#planificacion","text":"Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps Semana 2: Notificaciones Semana 3: iCloud Semana 4: Mapas y localizaci\u00f3n Semana 5: Extensiones y App Groups Semana 6: Publicaci\u00f3n en App Store y compras In-App","title":"Planificaci\u00f3n"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#entregas-de-practicas","text":"Entregas en Moodle, normalmente una entrega cada semana Plazo m\u00e1ximo: una semana despu\u00e9s del final de la asignatura (7 de junio) Recomendable realizar los ejercicios semana a semana","title":"Entregas de pr\u00e1cticas"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#recursos","text":"En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. Enlaces a los frontales de Apple de distintas tecnolog\u00edas que veremos en la asignatura: Apple Develop Notificaciones iCloud Mapas y localizaci\u00f3n App Extensions App Store Compras in-App","title":"Recursos"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html","text":"Mapas y localizaci\u00f3n \u00b6 MapKit \u00b6 Aspectos b\u00e1sicos de MapKit \u00b6 Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, etc. Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps. Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir. Un ejemplo de la app Mapas mostrando una vista 3D de Alicante: Geometr\u00eda de los mapas \u00b6 Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas. A\u00f1adir un mapa en nuestra app \u00b6 Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y para las pruebas en el simulador. No utilizaremos por tanto ning\u00fan perfil de aprovisionamiento especial para la pr\u00e1ctica. La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que cumpla el protocolo MKMapViewDelegate . Ejemplo de c\u00f3digo para a\u00f1adir un mapa mediante programa: import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 0 , width : self . view . frame . width , height : self . view . frame . height )) self . view . addSubview ( map ) map . delegate = self } } El resultado tiene el siguiente aspecto: Inicializaci\u00f3n del mapa \u00b6 Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. } @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) centerMapOnLocation ( mapView : mapView , loc : alicanteLocation ) } } func centerMapOnLocation ( mapView : MKMapView , loc : CLLocationCoordinate2D ) { let regionRadius : CLLocationDistance = 4000 let coordinateRegion = MKCoordinateRegion ( center : loc , latitudinalMeters : regionRadius , longitudinalMeters : regionRadius ) mapView . setRegion ( coordinateRegion , animated : true ) } ... } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado MKMapViewDelegate a un objeto que defina las funciones de este delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado. La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, el c\u00f3digo anterior centra el mapa en Alicante y muestra una zona de 4 km. de alto y ancho. Tipos de mapas \u00b6 La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: enum MKMapType : UInt { case standard case satellite case hybrid } Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl \u00b6 Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } } Uso del delegado \u00b6 Hemos visto que Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Por ejemplo: func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( \"Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) \" ) } Anotaciones \u00b6 Las anotaciones permiten resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n. Clases relacionadas \u00b6 Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa (una \"chincheta\" por defecto). El protocolo MKAnnotation \u00b6 El protocolo MKAnnotation define los m\u00e9todos que deben cumplir los objetos que vayan a implementar una anotaci\u00f3n: var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } coordinate : coordenadas de la anotaci\u00f3n title : cadena mostrada en el callout subtitle : cadena subt\u00edtulo mostrada en el callout Podemos conformar el protocolo en cualquier clase. Por ejemplo, podemos definir una clase Pin : class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = \"Pin \\( num ) \" self . subtitle = \"Un bonito lugar\" self . coordinate = coordinate super . init () } } MKAnnotationView \u00b6 La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image y definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta). Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa . Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar. Por ejemplo: func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? { print ( \"Devolviendo vista para anotaci\u00f3n: \\( annotation ) \" ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; } A\u00f1adir anotaciones en el mapa \u00b6 Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin ) Elementos en el callout \u00b6 Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure . Por ejemplo, podemos mostrar im\u00e1genes en la parte izquierda del callout , un thumbnail con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Podemos guardar la imagen en el objeto modelo annotation y despu\u00e9s inicializar la imagen del callout con esa imagen. Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar. Podr\u00edamos tambi\u00e9n tener una colecci\u00f3n de im\u00e1genes y guardar en el pin la m\u00e1s cercana a sus coordenadas. class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = \"Pin \\( num ) \" self . subtitle = \"Un bonito lugar\" self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : \"alicante1_thumb.png\" ) ! } else { self . thumbImage = UIImage ( named : \"alicante2_thumb.png\" ) ! } super . init () } } La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? { print ( \"Devolviendo vista para anotaci\u00f3n: \\( annotation ) \" ) let pin = annotation as ? Pin let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin ?. thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButton . ButtonType . detailDisclosure ) return view ; } Podemos saber que se ha pulsado un bot\u00f3n de un callout usando el m\u00e9todo del delegado mapView(_:annotationView:calloutAccessoryControlTapped:) . En ese caso podr\u00edamos, por ejemplo, activar un segue, pas\u00e1ndole como par\u00e1metro la vista de la anotaci\u00f3n que se ha pulsado. func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : \"DetalleImagen\" , sender : view ) } En el m\u00e9todo prepare(for segue: UIStoryboardSegue, sender: Any?) recibiremos la vista de la anotaci\u00f3n en el par\u00e1metro sender . Podemos acceder a la anotaci\u00f3n a partir de la mKAnnotationView usando el atributo annotation . Overlays \u00b6 Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com . Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa. Un ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View : class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } } class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } } El overlay debe a\u00f1adirse al mapView : let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) -> MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : \"overlay_park\" )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () } Geocoding \u00b6 El API de MapKit proporciona funcionalidades para realizar geocoding , transformar coordenadas del mapa en nombres de lugares y vicersa. La clase CLGeocoder proporciona un API que realiza estas operaciones realizando peticiones a un servicio de Apple. Debemos crear un objeto geocoder y realizar una petici\u00f3n llamando a uno de sus m\u00e9todos de forward geocoding o reverse geocoding . Las peticiones de reverse geocoding toman una longitud y latitud y obtienen una direcci\u00f3n con nombres. Las peticiones de forward geocoding hacen al rev\u00e9s: toman una direcci\u00f3n con nombres y buscan la correspondiente latitud y longitud. Estas peticiones pueden tambi\u00e9n devolver informaci\u00f3n adicional acerca de la localizaci\u00f3n especificada, como un punto de inter\u00e9s o un edificio en esa localizaci\u00f3n. El objeto devuelto en ambos tipos de peticiones es un CLPlacemark . En el caso de peticiones forward geocoding se puede devolver una lista de lugares a los que corresponde la direcci\u00f3n suministrada. Un placemark (marca de lugar) contiene propiedades para especificar el nombre de una calle, de una ciudad o de un pa\u00eds. Tambi\u00e9n contienen propiedades que describen caracter\u00edsticas geogr\u00e1ficas relevantes o puntos de inter\u00e9s en la localizaci\u00f3n, como los nombres de monta\u00f1as, r\u00edos, negocios o localizaciones. Existe un l\u00edmite en el ratio de peticiones de geocoding que puede hacer una app. Si se hacen demasiadas peticiones en un tiempo peque\u00f1o puede producirse un error. Conversi\u00f3n de localizaci\u00f3n en placemarks \u00b6 Con el m\u00e9todo reverseGeocodeLocation se puede obtener una lista de placemarks asociadas a unas coordenadas. Las llamadas al objeto geocoder son as\u00edncronas y hay que pasarle al m\u00e9todo una clausura completion handler . Un ejemplo de uso: func lookUpCurrentLocation ( completionHandler : @ escaping ( CLPlacemark ?) -> Void ) { // Use the last reported location. if let lastLocation = self . locationManager . location { let geocoder = CLGeocoder () // Look up the location and pass it to the completion handler geocoder . reverseGeocodeLocation ( lastLocation , completionHandler : { ( placemarks , error ) in if error == nil { let firstLocation = placemarks ?[ 0 ] completionHandler ( firstLocation ) } else { // An error occurred during geocoding. completionHandler ( nil ) } }) } else { // No location was available. completionHandler ( nil ) } } Conversi\u00f3n de placemarks en localizaciones \u00b6 Con el m\u00e9todo geocodeAddressString se puede pasar una direcci\u00f3n al geocoder y obtener una lista de lugares asociados ( placemarks ). Se obtendr\u00e1n menos lugares cuanto m\u00e1s precisa sea la direcci\u00f3n. Ejemplo: func getCoordinate ( addressString : String , completionHandler : @ escaping ( CLLocationCoordinate2D , NSError ?) -> Void ) { let geocoder = CLGeocoder () geocoder . geocodeAddressString ( addressString ) { ( placemarks , error ) in if error == nil { if let placemark = placemarks ?[ 0 ] { let location = placemark . location ! completionHandler ( location . coordinate , nil ) return } } completionHandler ( kCLLocationCoordinate2DInvalid , error as NSError ?) } } Otras caracter\u00edsticas: b\u00fasquedas, rutas y 3D \u00b6 No tenemos tiempo de verlo, pero el API tambi\u00e9n proporciona la posibilidad de realizar b\u00fasquedas y rutas en los mapas: As\u00ed como la posibilidad de mostrar el mapa en 3D: Localizaci\u00f3n \u00b6 Mediante el framework Core Location es posible obtener la localizaci\u00f3n del dispositivo m\u00f3vil. Los datos de localizaci\u00f3n pueden ser muy \u00fatiles para proporcionar servicios al usuario en distintos tipos de apps, como redes sociales, compras o navegaci\u00f3n. Este framework proporciona bastantes funcionalidades que podemos usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones nos permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda. La clase principal del framework es CLLocationManager . Activaci\u00f3n de los servicios de localizaci\u00f3n \u00b6 Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS. Solicitar informaci\u00f3n al usuario \u00b6 Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n. Clase CLLocationManager \u00b6 Se debe crear una instancia de la clase CLLocation\u200bManager . Se necesita mantener una referencia a esta instancia que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, no debemos almacenar una referencia al location manager en una variable local. La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() . Ejemplo de c\u00f3digo: import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) -> Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ... Monitorizaci\u00f3n de la localizaci\u00f3n \u00b6 Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones } Clase CLLocation \u00b6 La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description Activaci\u00f3n de la localizaci\u00f3n en el mapa \u00b6 Una vez activado el servicio de localizaci\u00f3n se puede visualizar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton } Prueba de la localizaci\u00f3n en el simulador \u00b6 Es posible probar los servicios de localizaci\u00f3n desde el simulador. Pare ello se debe seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug > Location y escoger una de las siguientes opciones: Ninguna (se desactiva la localizadi\u00f3n) Custom (se puede definir una localizaci\u00f3n) Apple (localizaci\u00f3n de Apple en San Francisco) City Bicycle Ride (Simulaci\u00f3n de un paseo en bicicleta) City Run (Simulaci\u00f3n de una carrera por la ciudad) Freeway Ride (Simulaci\u00f3n de un recorrido en coche) Referencias \u00b6 Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide Map Kit Framework Reference Core Location Framework Reference Converting a User's Location to a Descriptive Placemark Converting Between Coordinates and User-Friendly Place Names","title":"2. Mapas y localizaci\u00f3n"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mapas-y-localizacion","text":"","title":"Mapas y localizaci\u00f3n"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mapkit","text":"","title":"MapKit"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#aspectos-basicos-de-mapkit","text":"Map Kit es el framework de Apple para trabajar con mapas. Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, etc. Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps. Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona. El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app Mapas . Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir. Un ejemplo de la app Mapas mostrando una vista 3D de Alicante:","title":"Aspectos b\u00e1sicos de MapKit"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#geometria-de-los-mapas","text":"Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica. Una coordenada se define por una latitud y una longitud . La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo. La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste. La estructura CLLocationCoordinate2D representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante: let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) Un punto en el mapa se define por los valores x e y en la proyecci\u00f3n de Mercator. Se define utilizando la estructura MKMapPoint . Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa. Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura CGPoint y las \u00e1reas usando CGSize y CGRect . Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace . Para almacenar los datos en ficheros es preferible usar coordenadas de mapas.","title":"Geometr\u00eda de los mapas"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anadir-un-mapa-en-nuestra-app","text":"Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios. No es necesario para el desarrollo y para las pruebas en el simulador. No utilizaremos por tanto ning\u00fan perfil de aprovisionamiento especial para la pr\u00e1ctica. La clase MKMapView es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar MapKit . No debes hacer una subclase de MKMapView sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app: Usando el Interface Builder puedes arrastrar un objeto Map view a la vista o ventana apropiada. Para a\u00f1adir un mapa por programa, crea una instancia de la clase MKMapView , inicial\u00edzala con el m\u00e9todo initWithFrame: y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista. Por \u00faltimo debes actualizar el delegado con un objeto que cumpla el protocolo MKMapViewDelegate . Ejemplo de c\u00f3digo para a\u00f1adir un mapa mediante programa: import UIKit import MapKit class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () let map = MKMapView ( frame : CGRect ( x : 0 , y : 0 , width : self . view . frame . width , height : self . view . frame . height )) self . view . addSubview ( map ) map . delegate = self } } El resultado tiene el siguiente aspecto:","title":"A\u00f1adir un mapa en nuestra app"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#inicializacion-del-mapa","text":"Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder , usando un didSet en el outlet mapView que definimos arrastrando desde el storyboard : class ViewController : UIViewController , MKMapViewDelegate { override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. } @IBOutlet weak var mapView : MKMapView ! { didSet { mapView . mapType = . standard mapView . delegate = self let alicanteLocation = CLLocationCoordinate2D ( latitude : 38.3453 , longitude : - 0.4831 ) centerMapOnLocation ( mapView : mapView , loc : alicanteLocation ) } } func centerMapOnLocation ( mapView : MKMapView , loc : CLLocationCoordinate2D ) { let regionRadius : CLLocationDistance = 4000 let coordinateRegion = MKCoordinateRegion ( center : loc , latitudinalMeters : regionRadius , longitudinalMeters : regionRadius ) mapView . setRegion ( coordinateRegion , animated : true ) } ... } Para que los controles del mapa funcionen correctamente es necesario asignar el delegado MKMapViewDelegate a un objeto que defina las funciones de este delegado. Lo m\u00e1s sencillo es definir el propio View Controller como el delegado. La propiedad region del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa. Por ejemplo, el c\u00f3digo anterior centra el mapa en Alicante y muestra una zona de 4 km. de alto y ancho.","title":"Inicializaci\u00f3n del mapa"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#tipos-de-mapas","text":"La definici\u00f3n del tipo de mapa se controla con la propiedad mapType del mapa. Puede tener los valores: enum MKMapType : UInt { case standard case satellite case hybrid }","title":"Tipos de mapas"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#ejemplo-de-seleccion-del-tipo-de-mapa-con-un-segmentedcontrol","text":"Supongamos un SegmentedControl con los valores Mapa y Sat\u00e9lite . Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el mapView : enum TipoMapa : Int { case mapa = 0 case satelite } ... // En el ViewController @IBAction func seleccion ( sender : UISegmentedControl ) { let tipoMapa = TipoMapa ( rawValue : sender . selectedSegmentIndex ) ! switch ( tipoMapa ) { case . mapa : mapView . mapType = MKMapType . standard case . satelite : mapView . mapType = MKMapType . satellite } }","title":"Ejemplo de selecci\u00f3n del tipo de mapa con un SegmentedControl"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#uso-del-delegado","text":"Hemos visto que Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa. El objeto delegado puede implementar las funciones del protocolo MKMapViewDelegate donde recibe los eventos relacionados con el mapa: Cambios en la regi\u00f3n visible del mapa. La carga de zonas del mapa de la red. Cambios en la localizaci\u00f3n del usuario. Cambios asociados con anotaciones y overlys. Por ejemplo: func mapView ( _ mapView : MKMapView , regionDidChangeAnimated animated : Bool ) { print ( \"Cambiada la posici\u00f3n del mapa: \\( mapView . centerCoordinate ) \" ) }","title":"Uso del delegado"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anotaciones","text":"Las anotaciones permiten resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas. Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos. Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo ( callout ) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido. En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n.","title":"Anotaciones"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clases-relacionadas","text":"Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos: Un objeto annotation , que es un objeto que cumple el protocolo MKAnnotation y que gestiona los datos de la anotaci\u00f3n. Una vista de la anotaci\u00f3n, que es una vista (derivada de la clase MKAnnotationView ) usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre la superficie del mapa (una \"chincheta\" por defecto).","title":"Clases relacionadas"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#el-protocolo-mkannotation","text":"El protocolo MKAnnotation define los m\u00e9todos que deben cumplir los objetos que vayan a implementar una anotaci\u00f3n: var coordinate : CLLocationCoordinate2D { get } var title : String ? { get } var subtitle : String ? { get } coordinate : coordenadas de la anotaci\u00f3n title : cadena mostrada en el callout subtitle : cadena subt\u00edtulo mostrada en el callout Podemos conformar el protocolo en cualquier clase. Por ejemplo, podemos definir una clase Pin : class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String ? var subtitle : String ? init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = \"Pin \\( num ) \" self . subtitle = \"Un bonito lugar\" self . coordinate = coordinate super . init () } }","title":"El protocolo MKAnnotation"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mkannotationview","text":"La clase MKAnnotationView permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones. Permite definir la imagen de la anotaci\u00f3n, con su propiedad image y definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo. La subclase MKPinAnnotationView proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta). Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n mapView(_:viewFor:) en el objeto delegado del mapa . Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver nil si queremos que se muestre la vista est\u00e1ndar. Por ejemplo: func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? { print ( \"Devolviendo vista para anotaci\u00f3n: \\( annotation ) \" ) let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true return view ; }","title":"MKAnnotationView"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anadir-anotaciones-en-el-mapa","text":"Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo addAnnotation del viewMap . Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de Pin (la clase definida anteriormente, que cumple el protocolo MKAnnotation ) que inicializamos con un n\u00famero (variable definida en el viewController que vamos incrementado): let pin = Pin ( num : numPin , coordinate : mapView . centerCoordinate ) mapView . addAnnotation ( pin )","title":"A\u00f1adir anotaciones en el mapa"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#elementos-en-el-callout","text":"Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha. Hay que actualizar las propiedades de la vista leftCalloutAccessoryView y rightCalloutAccessoryView con objetos UIView . En la parte derecha es com\u00fan usar un objeto UIButton con tipo UIButtonTypeDetailDisclosure . Por ejemplo, podemos mostrar im\u00e1genes en la parte izquierda del callout , un thumbnail con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Podemos guardar la imagen en el objeto modelo annotation y despu\u00e9s inicializar la imagen del callout con esa imagen. Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar. Podr\u00edamos tambi\u00e9n tener una colecci\u00f3n de im\u00e1genes y guardar en el pin la m\u00e1s cercana a sus coordenadas. class Pin : NSObject , MKAnnotation { var coordinate : CLLocationCoordinate2D var title : String var subtitle : String var thumbImage : UIImage init ( num : Int , coordinate : CLLocationCoordinate2D ) { self . title = \"Pin \\( num ) \" self . subtitle = \"Un bonito lugar\" self . coordinate = coordinate if ( num % 2 == 0 ) { self . thumbImage = UIImage ( named : \"alicante1_thumb.png\" ) ! } else { self . thumbImage = UIImage ( named : \"alicante2_thumb.png\" ) ! } super . init () } } La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo mapView(_:viewFor ) que devuelve la vista de una anotaci\u00f3n: func mapView ( _ mapView : MKMapView , viewFor annotation : MKAnnotation ) -> MKAnnotationView ? { print ( \"Devolviendo vista para anotaci\u00f3n: \\( annotation ) \" ) let pin = annotation as ? Pin let view = MKPinAnnotationView ( annotation : annotation , reuseIdentifier : nil ) view . pinTintColor = UIColor . red view . animatesDrop = true view . canShowCallout = true let thumbnailImageView = UIImageView ( frame : CGRect ( x : 0 , y : 0 , width : 59 , height : 59 )) thumbnailImageView . image = pin ?. thumbImage view . leftCalloutAccessoryView = thumbnailImageView view . rightCalloutAccessoryView = UIButton ( type : UIButton . ButtonType . detailDisclosure ) return view ; } Podemos saber que se ha pulsado un bot\u00f3n de un callout usando el m\u00e9todo del delegado mapView(_:annotationView:calloutAccessoryControlTapped:) . En ese caso podr\u00edamos, por ejemplo, activar un segue, pas\u00e1ndole como par\u00e1metro la vista de la anotaci\u00f3n que se ha pulsado. func mapView ( _ mapView : MKMapView , annotationView view : MKAnnotationView , calloutAccessoryControlTapped control : UIControl ) { performSegue ( withIdentifier : \"DetalleImagen\" , sender : view ) } En el m\u00e9todo prepare(for segue: UIStoryboardSegue, sender: Any?) recibiremos la vista de la anotaci\u00f3n en el par\u00e1metro sender . Podemos acceder a la anotaci\u00f3n a partir de la mKAnnotationView usando el atributo annotation .","title":"Elementos en el callout"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#overlays","text":"Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa. Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas. Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com . Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos: Un objeto overlay , que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay. Un renderizador del overlay , que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa. Un ejemplo de c\u00f3digo de la aplicaci\u00f3n demo Park View : class ParkMapOverlay : NSObject , MKOverlay { var coordinate : CLLocationCoordinate2D var boundingMapRect : MKMapRect init ( park : Park ) { boundingMapRect = park . overlayBoundingMapRect coordinate = park . midCoordinate } } class ParkMapOverlayView : MKOverlayRenderer { var overlayImage : UIImage init ( overlay : MKOverlay , overlayImage : UIImage ) { self . overlayImage = overlayImage super . init ( overlay : overlay ) } override func draw ( _ mapRect : MKMapRect , zoomScale : MKZoomScale , in context : CGContext ) { guard let imageReference = overlayImage . cgImage else { return } let rect = self . rect ( for : overlay . boundingMapRect ) context . scaleBy ( x : 1.0 , y : - 1.0 ) context . translateBy ( x : 0.0 , y : - rect . size . height ) context . draw ( imageReference , in : rect ) } } El overlay debe a\u00f1adirse al mapView : let overlay = ParkMapOverlay ( park : park ) mapView . add ( overlay ) Para su visualizaci\u00f3n debemos implementar el m\u00e9todo mapView:rendererForOverlay: en el mapView delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays: func mapView ( _ mapView : MKMapView , rendererFor overlay : MKOverlay ) -> MKOverlayRenderer { if overlay is ParkMapOverlay { return ParkMapOverlayView ( overlay : overlay , overlayImage : # imageLiteral ( resourceName : \"overlay_park\" )) } else if overlay is MKPolyline { let lineView = MKPolylineRenderer ( overlay : overlay ) lineView . strokeColor = UIColor . green return lineView else if ... } return MKOverlayRenderer () }","title":"Overlays"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#geocoding","text":"El API de MapKit proporciona funcionalidades para realizar geocoding , transformar coordenadas del mapa en nombres de lugares y vicersa. La clase CLGeocoder proporciona un API que realiza estas operaciones realizando peticiones a un servicio de Apple. Debemos crear un objeto geocoder y realizar una petici\u00f3n llamando a uno de sus m\u00e9todos de forward geocoding o reverse geocoding . Las peticiones de reverse geocoding toman una longitud y latitud y obtienen una direcci\u00f3n con nombres. Las peticiones de forward geocoding hacen al rev\u00e9s: toman una direcci\u00f3n con nombres y buscan la correspondiente latitud y longitud. Estas peticiones pueden tambi\u00e9n devolver informaci\u00f3n adicional acerca de la localizaci\u00f3n especificada, como un punto de inter\u00e9s o un edificio en esa localizaci\u00f3n. El objeto devuelto en ambos tipos de peticiones es un CLPlacemark . En el caso de peticiones forward geocoding se puede devolver una lista de lugares a los que corresponde la direcci\u00f3n suministrada. Un placemark (marca de lugar) contiene propiedades para especificar el nombre de una calle, de una ciudad o de un pa\u00eds. Tambi\u00e9n contienen propiedades que describen caracter\u00edsticas geogr\u00e1ficas relevantes o puntos de inter\u00e9s en la localizaci\u00f3n, como los nombres de monta\u00f1as, r\u00edos, negocios o localizaciones. Existe un l\u00edmite en el ratio de peticiones de geocoding que puede hacer una app. Si se hacen demasiadas peticiones en un tiempo peque\u00f1o puede producirse un error.","title":"Geocoding"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#conversion-de-localizacion-en-placemarks","text":"Con el m\u00e9todo reverseGeocodeLocation se puede obtener una lista de placemarks asociadas a unas coordenadas. Las llamadas al objeto geocoder son as\u00edncronas y hay que pasarle al m\u00e9todo una clausura completion handler . Un ejemplo de uso: func lookUpCurrentLocation ( completionHandler : @ escaping ( CLPlacemark ?) -> Void ) { // Use the last reported location. if let lastLocation = self . locationManager . location { let geocoder = CLGeocoder () // Look up the location and pass it to the completion handler geocoder . reverseGeocodeLocation ( lastLocation , completionHandler : { ( placemarks , error ) in if error == nil { let firstLocation = placemarks ?[ 0 ] completionHandler ( firstLocation ) } else { // An error occurred during geocoding. completionHandler ( nil ) } }) } else { // No location was available. completionHandler ( nil ) } }","title":"Conversi\u00f3n de localizaci\u00f3n en placemarks"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#conversion-de-placemarks-en-localizaciones","text":"Con el m\u00e9todo geocodeAddressString se puede pasar una direcci\u00f3n al geocoder y obtener una lista de lugares asociados ( placemarks ). Se obtendr\u00e1n menos lugares cuanto m\u00e1s precisa sea la direcci\u00f3n. Ejemplo: func getCoordinate ( addressString : String , completionHandler : @ escaping ( CLLocationCoordinate2D , NSError ?) -> Void ) { let geocoder = CLGeocoder () geocoder . geocodeAddressString ( addressString ) { ( placemarks , error ) in if error == nil { if let placemark = placemarks ?[ 0 ] { let location = placemark . location ! completionHandler ( location . coordinate , nil ) return } } completionHandler ( kCLLocationCoordinate2DInvalid , error as NSError ?) } }","title":"Conversi\u00f3n de placemarks en localizaciones"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#otras-caracteristicas-busquedas-rutas-y-3d","text":"No tenemos tiempo de verlo, pero el API tambi\u00e9n proporciona la posibilidad de realizar b\u00fasquedas y rutas en los mapas: As\u00ed como la posibilidad de mostrar el mapa en 3D:","title":"Otras caracter\u00edsticas: b\u00fasquedas, rutas y 3D"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#localizacion","text":"Mediante el framework Core Location es posible obtener la localizaci\u00f3n del dispositivo m\u00f3vil. Los datos de localizaci\u00f3n pueden ser muy \u00fatiles para proporcionar servicios al usuario en distintos tipos de apps, como redes sociales, compras o navegaci\u00f3n. Este framework proporciona bastantes funcionalidades que podemos usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo: El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo. El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios. La monitorizaci\u00f3n de regiones nos permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda. La clase principal del framework es CLLocationManager .","title":"Localizaci\u00f3n"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#activacion-de-los-servicios-de-localizacion","text":"Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave UIRequiredDeviceCapabilities en el fichero Info.plist de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio. El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas location-services y gps . La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS.","title":"Activaci\u00f3n de los servicios de localizaci\u00f3n"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#solicitar-informacion-al-usuario","text":"Es necesario a\u00f1adir tambi\u00e9n en Info.plist una cadena asociada a la clave NSLocationWhenInUseUsageDescription . Esta clave tiene la descripci\u00f3n en Xcode Privacy - Location When in Use Usage Description . Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo request\u200bWhen\u200bIn\u200bUse\u200bAuthorization() o requestAlwaysAuthorization() del objeto CLLocationManager . La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n.","title":"Solicitar informaci\u00f3n al usuario"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clase-cllocationmanager","text":"Se debe crear una instancia de la clase CLLocation\u200bManager . Se necesita mantener una referencia a esta instancia que han terminado todas las tareas en las que participa. Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, no debemos almacenar una referencia al location manager en una variable local. La clase AppDelegate tambi\u00e9n puede funcionar como CLLocationManagerDelegate . Inicializamos ah\u00ed el CLLocationManager . En el m\u00e9todo didFinishLaunchingWithOptions podemos actualizar el gestor de localizaci\u00f3n: Inicializamos el delegado del gestor de localizaci\u00f3n. Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo requestWhenInUseAuthorization() Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad desiredAccuracy del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo. Despu\u00e9s se debe llamar al m\u00e9todo startUpdatingLocation() . Ejemplo de c\u00f3digo: import UIKit import CoreLocation @UIApplicationMain class AppDelegate : UIResponder , UIApplicationDelegate , CLLocationManagerDelegate { var window : UIWindow ? let locationManager = CLLocationManager () func application ( application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ NSObject : AnyObject ]?) -> Bool { // Override point for customization after application launch. locationManager . delegate = self locationManager . requestWhenInUseAuthorization () locationManager . desiredAccuracy = kCLLocationAccuracyNearestTenMeters locationManager . startUpdatingLocation () return true } ...","title":"Clase CLLocationManager"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#monitorizacion-de-la-localizacion","text":"Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo didUpdateLocations pas\u00e1ndole un array de localizaciones (objetos CLLocation ): func locationManager ( _ manager : CLLocationManager , didUpdateLocations locations : [ CLLocation ]) { // C\u00f3digo para gestionar las localizaciones }","title":"Monitorizaci\u00f3n de la localizaci\u00f3n"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clase-cllocation","text":"La clase CLLocation permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella. Atributos: coordinate altitude floor horizontalAccuracy verticalAccuracy speed course timestamp description","title":"Clase CLLocation"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#activacion-de-la-localizacion-en-el-mapa","text":"Una vez activado el servicio de localizaci\u00f3n se puede visualizar la localizaci\u00f3n en el mapa obteniendo el MKUserTrackingBarButtonItem y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n. No hace falta llamar a startUpdatingLocation() . Se puede hacer en el ViewController que contiene el mapa: override func viewDidLoad () { super . viewDidLoad () let userTrackingButton = MKUserTrackingBarButtonItem ( mapView : mapView ) self . navigationItem . leftBarButtonItem = userTrackingButton }","title":"Activaci\u00f3n de la localizaci\u00f3n en el mapa"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#prueba-de-la-localizacion-en-el-simulador","text":"Es posible probar los servicios de localizaci\u00f3n desde el simulador. Pare ello se debe seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug > Location y escoger una de las siguientes opciones: Ninguna (se desactiva la localizadi\u00f3n) Custom (se puede definir una localizaci\u00f3n) Apple (localizaci\u00f3n de Apple en San Francisco) City Bicycle Ride (Simulaci\u00f3n de un paseo en bicicleta) City Run (Simulaci\u00f3n de una carrera por la ciudad) Freeway Ride (Simulaci\u00f3n de un recorrido en coche)","title":"Prueba de la localizaci\u00f3n en el simulador"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#referencias","text":"Recursos sobre mapas y localizaci\u00f3n Location and maps programming guide Map Kit Framework Reference Core Location Framework Reference Converting a User's Location to a Descriptive Placemark Converting Between Coordinates and User-Friendly Place Names","title":"Referencias"},{"location":"teoria/notificaciones/notificaciones.html","text":"Notificaciones \u00b6 En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS. Introducci\u00f3n \u00b6 En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11. Apariencia de las notificaciones \u00b6 Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes > Notificaciones ). D\u00f3nde aparecen las notificaciones \u00b6 Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla). Interacci\u00f3n en las notificaciones \u00b6 Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app. Notificaciones locales \u00b6 Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado. Notificaciones remotas \u00b6 Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido. Para qu\u00e9 se usan las notificaciones \u00b6 Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice. Notification service app extensions \u00b6 Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones. Ciclo de vida de la app \u00b6 Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps. API de notificaciones \u00b6 A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones UNUserNotificationCenter \u00b6 La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n. Notifications UI Framework \u00b6 Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications . Preparaci\u00f3n de las notificaciones \u00b6 Registro de los tipos de notificaci\u00f3n \u00b6 Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes > Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n. Obtener los ajustes definidos por el usuario \u00b6 El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. func applicationWillEnterForeground ( _ application : UIApplication ) { print ( \"Voy a pedir los settigs\" ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( \"Alert enabled\" ) } else { print ( \"Alert not enabled\" ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( \"Badge enabled\" ) } else { print ( \"Badge not enabled\" ) }}) } Notificaciones locales \u00b6 Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado. Creaci\u00f3n de notificaciones \u00b6 La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? ) Contenido de la notificaci\u00f3n \u00b6 El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: let content = UNMutableNotificationContent () content . title = \"Introduction to Notifications\" content . subtitle = \"Session 707\" content . body = \"Woah! These new notifications look amazing! Don\u2019t you agree?\" content . badge = 1 Media attachments \u00b6 Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) -> UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + \".png\" let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( \"error \" + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: if let attachment = UNNotificationAttachment . create ( identifier : \"prueba\" , image : UIImage ( named : \"gatito.png\" ) ! , options : nil ) { content . attachments = [ attachment ] } Condiciones de disparo de la notificaci\u00f3n \u00b6 Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : \"Headquarters\" ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false ) Creaci\u00f3n de la notificaci\u00f3n local \u00b6 Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: let content = UNMutableNotificationContent () content . title = \"Introducci\u00f3n a Notificaciones\" content . body = \"Hablemos sobre notificaciones!\" content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = \"peticionEjemplo\" let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( \"Error \\( error ) \" )} Demo \u00b6 Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo. Ejemplo de app: Notificaciones \u00b6 Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones. Acciones \u00b6 Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction . El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter asociada a un identificador. Una vez creada la categor\u00eda con el conjunto de acciones podemos crear una notificaci\u00f3n que contenga estas acciones inicializando la propiedad categoryIdentifier de la notificaci\u00f3n con la cadena apropiada. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto , y es la cadena: com.apple.UNNotificationDefaultActionIdentifier . Ejemplo de c\u00f3digo de creaci\u00f3n de una acci\u00f3n \u00b6 Para crear las acciones y asociarlas a una categor\u00eda: let action1 = UNNotificationAction ( identifier : \"acepto\" , title : \"Acepto\" , options : []) let action2 = UNNotificationAction ( identifier : \"otro\" , title : \"Otro d\u00eda\" , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : \"mensaje\" , title : \"Mensaje\" , options : [], textInputButtonTitle : \"Enviar\" , textInputPlaceholder : \"Comentario\" ) let category = UNNotificationCategory ( identifier : \"invitacion\" , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Para asignar las acciones a la notificaci\u00f3n se asigna el identificador de la categor\u00eda. content . categoryIdentifier = \"invitacion\" La notificaci\u00f3n creada tiene el siguiente aspecto: Manejo de notificaciones \u00b6 Una vez que el usuario ha pulsado una acci\u00f3n de la notificaci\u00f3n o la ha abierto nuestra app debe gestionar esa acci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Para ello debemos implementar los m\u00e9todos del protocolo UNUserNotificationCenterDelegate . userNotificationCenter(_:didReceive:withCompletionHandler:) : se llama cuando la app est\u00e1 en segundo plano y el usuario interact\u00faa con la notificaci\u00f3n. userNotificationCenter(_:willPresent:withCompletionHandler:) : se llama cuando la app est\u00e1 en primer plano y se recibe la notificaci\u00f3n. Estos m\u00e9todos se suelen implementar en el propio AppDelegate , que cumple este protocolo. Y se debe asignar al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:) . Por ejemplo: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { ... UNUserNotificationCenter . current (). delegate = self ... } App en segundo plano \u00b6 Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local el usuario puede interactuar con las acciones de la notificaci\u00f3n o pulsar la opci\u00f3n de Abrir . En ambos casos se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) con la informaci\u00f3n de la opci\u00f3n seleccionada por el usuario. Si el usuario ha seleccionado una acci\u00f3n la aplicaci\u00f3n no pasa a primer plano. Sin embargo, si el usuario ha decidido abrir la notificaci\u00f3n, la aplicaci\u00f3n pasa a primer plano, ejecut\u00e1ndose el m\u00e9todo de ciclo de vida applicationWillEnterForeground del UIApplicationDelegate antes del m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) . Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida. Si la notificaci\u00f3n es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante). Un ejemplo del c\u00f3digo en el que se gestiona la notificaci\u00f3n recibida: func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () -> Void ) { // Get the meeting ID from the original notification. let userInfo = response . notification . request . content . userInfo if response . notification . request . content . categoryIdentifier == \"MEETING_INVITATION\" { // Retrieve the meeting details. let meetingID = userInfo [ \"MEETING_ID\" ] as ! String let userID = userInfo [ \"USER_ID\" ] as ! String switch response . actionIdentifier { case \"ACCEPT_ACTION\" : sharedMeetingManager . acceptMeeting ( user : userID , meetingID : meetingID ) break case \"DECLINE_ACTION\" : sharedMeetingManager . declineMeeting ( user : userID , meetingID : meetingID ) break case UNNotificationDefaultActionIdentifier , UNNotificationDismissActionIdentifier : // Queue meeting-related notifications for later // if the user does not act. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) break default : break } } else { // Handle other notification types... } // Always call the completion handler when done. completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier , el contenido de la constante UNNotificationDefaultActionIdentifier . App en primer plano \u00b6 En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Un ejemplo de c\u00f3digo: func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) -> Void ) { if notification . request . content . categoryIdentifier == \"MEETING_INVITATION\" { // Retrieve the meeting details. let meetingID = notification . request . content . userInfo [ \"MEETING_ID\" ] as ! String let userID = notification . request . content . userInfo [ \"USER_ID\" ] as ! String // Add the meeting to the queue. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) // Play a sound to let the user know about the invitation. completionHandler (. sound ) return } else { // Handle other notification types... } // Don't alert the user for other types. completionHandler ( UNNotificationPresentationOptions ( rawValue : 0 )) } Demo \u00b6 Probamos y examinamos el c\u00f3digo de la aplicaci\u00f3n de prueba que incluye acciones en la notificaci\u00f3n y que define las funciones de gesti\u00f3n de las notificaciones. Probamos a seleccionar distintas acciones y comprobar qu\u00e9 mensaje aparece por la salida est\u00e1ndar: Notificaciones remotas ( push ) \u00b6 Objetivos de las notificaciones remotas \u00b6 La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ). Arquitectura de las notificaciones remotas \u00b6 El servicio Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos. Arquitectura de seguridad \u00b6 No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs. Secuencia de registro del dispositivo \u00b6 Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs. Token del dispositivo \u00b6 Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo. Env\u00edo de notificaci\u00f3n remota usando el token \u00b6 Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado. Contenido de la notificaci\u00f3n \u00b6 Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple . El tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes y debe tener el formato de un objeto JSON diccionario (parejas clave, valor). Un ejemplo en JSON: { \"aps\" : { \"alert\" : { \"title\" : \"Introducci\u00f3n a las notificaciones\" , \"subtitle\" : \"Sesi\u00f3n 707\" , \"body\" : \"La nueva API de notificaciones es genial!!!\" , \"category\" : \"mensaje\" , }, \"badge\" : 1 }, } El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: - Mensaje de alerta a mostrar al usuario - Numero a a\u00f1adir en el globo del icono de la app - Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. En este caso es conveniente no mostrar al usuario ninguna notificaci\u00f3n. El contenido nuevo se ver\u00e1 la siguiente vez que se abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app. Otros ejemplos de payload . N\u00famero en el badge y custom keys : { \"aps\" : { \"alert\" : \"You got your emails.\" , \"badge\" : 9 , \"sound\" : \"bingbong.aiff\" }, \"acme1\" : \"bar\" , \"acme2\" : 42 } Notificaci\u00f3n silenciosa: { \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\" , \"acme2\" : 42 } Notificaci\u00f3n con cadenas localizadas: { \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\" , \"loc-args\" : [ \"Jenna\" , \"Frank\" ] }, \"sound\" : \"chime.aiff\" }, \"acme\" : \"foo\" } Notificaci\u00f3n con acciones: { \"aps\" : { \"alert\u201d : { \u201cbody\u201d : \" Acme message received fr om Joh nn y Appleseed\u201d , \u201cac t io n - loc - key\u201d : \u201cVIEW\u201d , \"actions\" : [ { \u201cid \" : \u201cdelete\" , \"title\" : \"Delete\" }, { \u201cid \" : \u201creply-to\u201d, \" loc - key \" : \u201cREPLYTO\u201d, \" loc - args \" : [\u201cJane\" ] } ] } \"badge\" : 3 , \"sound\" : \u201cchime.ai ff \" }, \" acme - accou nt \" : \" ja ne .appleseed@apple.com \", \" acme - message \" : \" message 123456 \" } Servidores proveedores \u00b6 Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida por Apple basada en un protocolo HTTP/2 y TLS. Es posible montar un servidor propio usando librer\u00edas ya existentes. Por ejemplo, en Java existe la librer\u00eda Pushy . Es recomendable consultar la documentaci\u00f3n de Apple Setting Up a Remote Notification Server y Sending Notification Requests to APNs . La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal. En cualquier caso nuestro servidor deber\u00e1 conectarse al APNs usando una t\u00e9cnica segura: o bien un certificado proporcionado por Apple (es lo que haremos en la demostraci\u00f3n) o bien un token, usando JWT (JSON Web Token). Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs Gesti\u00f3n de las notificaciones remotas en la app \u00b6 Capacidad de notificaci\u00f3n remota \u00b6 La app debe tener el permiso de usar las notificaciones remotas. Debe usar un perfil de aprovisionamiento con un App ID que otorgue ese permiso. Se puede hacer desde Xcode o desde el la web de desarrollador. En la demostraci\u00f3n lo haremos desde la web del programa de desarrollo de la universidad. Registro de las notificaciones \u00b6 Para que una app trabaje con notificaciones remotas lo primero que debe hacerse, al igual que con las notificaciones locales, es pedir permiso al usuario. La forma de hacerlo es id\u00e9ntica a las de las notificaciones locales, usando el m\u00e9todo requestAuthorization(options:completionHandler:) . Una vez hecho esto, hay que conseguir el token asociado al dispositivo y la app registr\u00e1ndose en el Apple Push Notification service (APNs). Lo hace el m\u00e9todo registerForRemoteNotifications del objeto application. Se trata de un m\u00e9todo as\u00edncrono. Si el registro en el servicio tiene \u00e9xito, la app llama al m\u00e9todo application(_:didRegisterForRemoteNotificationsWithDeviceToken:) del delegado de la aplicaci\u00f3n pasando el token asignado que habr\u00e1 que incluir en las notificaciones que enviemos al dispositivo. Ejemplo de c\u00f3digo de registro de las notificaciones remotas: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } Ejemplo de obtenci\u00f3n del token e impresi\u00f3n en la consola: func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = \"\" for i in 0. .< deviceToken . count { token = token + String ( format : \"%02.2hhx\" , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( \"Failed to register:\" , error ) } Recepci\u00f3n de las notificaciones en la app \u00b6 La gesti\u00f3n de las notificaciones recibidas es id\u00e9ntica a la ya vista en notificaciones locales, us\u00e1ndose exactamente los mismos manejadores, con la excepci\u00f3n de la posibilidad de gestionar notificaciones remotas cuando la app est\u00e1 en segundo plano. Recordemos los manejadores que ya vimos en las notificaciones locales: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate cuando llega la notificaci\u00f3n. Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . La diferencia de las notificaciones remotas es la posibilidad de definir el manejador application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app, que se activa cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 : { \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\", \"acme2\" : 42 } Para que se llame al m\u00e9todo se debe activar la capability Background Modes > Remote Notifications en Xcode. El m\u00e9todo se llama tanto si la app est\u00e1 en primer plano como si est\u00e1 en segundo plano. De hecho, es recomendable usarlo \u00fanicamente para gestionar notificaciones silenciosas que no se muestran al usuario sino que se usan para que la app pueda recuperar informaci\u00f3n del servidor que se mostrar\u00e1 la siguiente vez que el usuario lance la app. Por ello habr\u00eda que enviar un payload como el que hemos visto anteriormente. Con custom keys pero en el que el diccionario aps no contenga ninguna clave que disparare una interacci\u00f3n con el usuario. Ejemplo de app \u00b6 Ejemplo de app que usaremos para demostrar las notificaciones remotas: C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando la app est\u00e1 en primer plano : func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) -> Void ) { print ( \"Recibida notificaci\u00f3n primer plano\" ) let aps = notification . request . content . userInfo [ \"aps\" ] as ! [ String : AnyObject ] if let news = aps [ \"alert\" ] as ? String { createNewNewsItem ( text : news ) } // No mostramos la notificaci\u00f3n completionHandler ([]) } C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando ha sido accionada por el usuario : func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () -> Void ) { print ( \"Usuario ha pulsado una notificaci\u00f3n\" ) let aps = response . notification . request . content . userInfo [ \"aps\" ] as ! [ String : AnyObject ] if let news = aps [ \"alert\" ] as ? String { createNewNewsItem ( text : news ) } completionHandler () } C\u00f3digo de gesti\u00f3n de una notificaci\u00f3n silenciosa : func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) -> Void ) { print ( \"Recibida notificaci\u00f3n remota en background\" ) createNewNewsItem ( text : \"Notificaci\u00f3n silenciosa\" ) completionHandler ( UIBackgroundFetchResult . newData ) } Demo \u00b6 Pasos necesarios para la demo \u00b6 En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP que tendremos que configurar con: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push. Nuevo App ID en el member center \u00b6 Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n. Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push. Creaci\u00f3n del certificado SSL en el member center \u00b6 Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros > Asistente de Certificados > Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest . Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest Generaci\u00f3n del fichero .pem \u00b6 Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros. Lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs: Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles20) Creamos el fichero .pem con el siguiente comando: $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Una vez hecho esto, ya tendremos listo el certificado para enviar la notificaci\u00f3n push al APNs, usando el script PHP. Creaci\u00f3n del perfil de aprovisionamiento \u00b6 Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo. Obtenci\u00f3n del token del dispositivo \u00b6 Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo y de la app que va a recibir la notificaci\u00f3n. Para ello debemos ejecutar la app en un dispositivo f\u00edsico (no funciona en el simulador). Probamos la app NotificacionesPush \u00b6 Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs. La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador. Anotamos el token del dispositivo que aparece en la consola al ejecutar la app por primera vez. Probamos a enviar notificaciones remotas al dispositivo \u00b6 Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: $ php apnspush.php 'Hola mundo desde la UA' Connected to APNS Message successfully delivered Bibliograf\u00eda \u00b6 Framework UserNotifications Asking Permission to Use Notifications Scheduling a Notification Locally from Your App Handling Notifications and Notification-Related Actions Registering Your App with APNs Generating a Remote Notification Pushing Updates to Your App Silently Setting Up a Remote Notification Server Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"3. Notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones","text":"En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas ( push ) usando el User Notifications Framework de iOS.","title":"Notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#introduccion","text":"En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s. Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference . Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch . Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchKit Framework para m\u00e1s informaci\u00f3n. En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11.","title":"Introducci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#apariencia-de-las-notificaciones","text":"Tanto las notificaciones locales como las remotas pueden aparecer como: Un aviso ( alert ) o tira ( banner ) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen. Un globo ( badge ) en el icono de la app. Un sonido que acompa\u00f1a la alerta, banner o badge . El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes ( Ajustes > Notificaciones ).","title":"Apariencia de las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#donde-aparecen-las-notificaciones","text":"Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma. Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior. Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo. En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla).","title":"D\u00f3nde aparecen las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#interaccion-en-las-notificaciones","text":"Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones. O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar ( Abrir , Borrar o Ver ): Con la opci\u00f3n Abrir se pasa a primer plano la app a la que corresponde la notificaci\u00f3n. Con la opci\u00f3n Borrar se borra la notificaci\u00f3n. Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el usuario puede seleccionar una de las acciones incluidas en ella. Con el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes, audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app.","title":"Interacci\u00f3n en las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-locales","text":"Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o. Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante. Dos ejemplos de uso: En una app que gestiona una lista de tareas por hacer, en la que cada \u00edtem tiene una fecha y hora en el que debe ser completado. En una app que recibe en background informaci\u00f3n de cotizaciones en bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una empresa que el usuario ha marcado.","title":"Notificaciones locales"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-remotas","text":"Una notificaci\u00f3n remota , tambi\u00e9n llamada notificaci\u00f3n push , llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs). Dos ejemplos de uso: En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando el usuario recibe un nuevo mensaje. En un reproductor de podcasts el servidor avisa de que hay un nuevo episodio disponible para ser reproducido.","title":"Notificaciones remotas"},{"location":"teoria/notificaciones/notificaciones.html#para-que-se-usan-las-notificaciones","text":"Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios. Las notificaciones remotas se utilizan para: Avisar al usuario de que han sucedido determinados eventos. Notificar a la app para que descargue contenido nuevo para que est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice.","title":"Para qu\u00e9 se usan las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#notification-service-app-extensions","text":"Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario. Por ejemplo, se pueden usar para: Implementar encriptaci\u00f3n end-to-end de las notificaciones. Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan contexto modificado en la app. Descargar del servidor im\u00e1genes o media adicionales. Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones.","title":"Notification service app extensions"},{"location":"teoria/notificaciones/notificaciones.html#ciclo-de-vida-de-la-app","text":"Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano. Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n). Nota: Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background , o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps.","title":"Ciclo de vida de la app"},{"location":"teoria/notificaciones/notificaciones.html#api-de-notificaciones","text":"A partir de iOS 10 se unifican todas las funciones en el framework UserNotifications . Las clases y protocolos de ese framework permiten: Mismo c\u00f3digo para notificaciones locales y remotas M\u00e9todos delegados simplificados Mejor gesti\u00f3n de las notificaciones Opci\u00f3n para presentar la notificaci\u00f3n en el app Planificaci\u00f3n y manejo de notificaciones en extensiones","title":"API de notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#unusernotificationcenter","text":"La clase UNUserNotificationCenter es la clase principal de UserNotifications Framework. Define un singleton que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones. Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas: Pedir autorizaci\u00f3n para mostrar las notificaciones. Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app. Planificar el env\u00edo de notificaciones a la app. Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones. Obtener los ajustes relacionados con notificaciones de la app. Contener un delegado en el que se define la funci\u00f3n de callback a la que el sistema llama cuando el usuario activa la notificaci\u00f3n.","title":"UNUserNotificationCenter"},{"location":"teoria/notificaciones/notificaciones.html#notifications-ui-framework","text":"Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework . No tenemos tiempo de verlo en clase, puedes consultar la sesi\u00f3n de WWDC 2016 Advanced Notifications .","title":"Notifications UI Framework"},{"location":"teoria/notificaciones/notificaciones.html#preparacion-de-las-notificaciones","text":"","title":"Preparaci\u00f3n de las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#registro-de-los-tipos-de-notificacion","text":"Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo application:didFinishLaunchingWithOptions: del delegado de la aplicaci\u00f3n. El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos. Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n ( Ajustes > Notificaciones ). Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { UNUserNotificationCenter . current () . requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} return true } Se utiliza el m\u00e9todo requestAuthorization(options:completionHandler:) del singleton UserNotificationCenter (accesible con el m\u00e9todo de tipo current() ). Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario. La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n. Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n.","title":"Registro de los tipos de notificaci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#obtener-los-ajustes-definidos-por-el-usuario","text":"El m\u00e9todo getNotificationSettings(completionHandler:) pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto UNNotificationSettings como par\u00e1metro. func applicationWillEnterForeground ( _ application : UIApplication ) { print ( \"Voy a pedir los settigs\" ) UNUserNotificationCenter . current (). getNotificationSettings ( completionHandler : {( settings : UNNotificationSettings ) in if ( settings . alertSetting == UNNotificationSetting . enabled ) { print ( \"Alert enabled\" ) } else { print ( \"Alert not enabled\" ) } if ( settings . badgeSetting == UNNotificationSetting . enabled ) { print ( \"Badge enabled\" ) } else { print ( \"Badge not enabled\" ) }}) }","title":"Obtener los ajustes definidos por el usuario"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-locales_1","text":"Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda. Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app. Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado.","title":"Notificaciones locales"},{"location":"teoria/notificaciones/notificaciones.html#creacion-de-notificaciones","text":"La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase UNNotificationRequest , indicando los siguientes elementos: Identificador ( identifier: String ) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n. Contenido de la notificaci\u00f3n ( content: UNNotificationContent ) Condiciones que disparan la notificaci\u00f3n ( trigger: UNNotificationTrigger? )","title":"Creaci\u00f3n de notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#contenido-de-la-notificacion","text":"El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent . Podemos actualizar sus propiedades para especificar: title: String : Breve descripci\u00f3n de la raz\u00f3n del aviso subtitle: String : Descripci\u00f3n secundaria body: String : El mensaje mostrado en el aviso badge: NSNumber? : El n\u00famero a mostrar en el globo de la app sound: UNNotificationSound? : El sonido cuando se entrega la notificaci\u00f3n launchImageName: String : El nombre de la imagen de lanzamiento a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n var userInfo: [AnyHashable : Any] : Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n var attachments: [UNNotificationAttachment] : Un array de adjuntos a mostrar con la notificaci\u00f3n Por ejemplo, la siguiente notificaci\u00f3n: se especifica con el siguiente c\u00f3digo: let content = UNMutableNotificationContent () content . title = \"Introduction to Notifications\" content . subtitle = \"Session 707\" content . body = \"Woah! These new notifications look amazing! Don\u2019t you agree?\" content . badge = 1","title":"Contenido de la notificaci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#media-attachments","text":"Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados: Audio: MP3, MPEG4 Imagen: JPEG, GIF, PNG V\u00eddeo: MPEG, MPEG2, MPEG4, AVI Se debe crear un objeto de tipo UNNotificationAttachment . El siguiente c\u00f3digo presenta una extensi\u00f3n de UNNotificationAttachment que permite crear un attachment de tipo imagen a partir de una UIImage : extension UNNotificationAttachment { static func create ( identifier : String , image : UIImage , options : [ NSObject : AnyObject ]?) -> UNNotificationAttachment ? { let fileManager = FileManager . default let tmpSubFolderName = ProcessInfo . processInfo . globallyUniqueString let tmpSubFolderURL = URL ( fileURLWithPath : NSTemporaryDirectory ()). appendingPathComponent ( tmpSubFolderName , isDirectory : true ) do { try fileManager . createDirectory ( at : tmpSubFolderURL , withIntermediateDirectories : true , attributes : nil ) let imageFileIdentifier = identifier + \".png\" let fileURL = tmpSubFolderURL . appendingPathComponent ( imageFileIdentifier ) guard let imageData = UIImagePNGRepresentation ( image ) else { return nil } try imageData . write ( to : fileURL ) let imageAttachment = try UNNotificationAttachment . init ( identifier : imageFileIdentifier , url : fileURL , options : options ) return imageAttachment } catch { print ( \"error \" + error . localizedDescription ) } return nil } } Una vez definida la extensi\u00f3n, podemos incluir el attachment en la notificaci\u00f3n: if let attachment = UNNotificationAttachment . create ( identifier : \"prueba\" , image : UIImage ( named : \"gatito.png\" ) ! , options : nil ) { content . attachments = [ attachment ] }","title":"Media attachments"},{"location":"teoria/notificaciones/notificaciones.html#condiciones-de-disparo-de-la-notificacion","text":"Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo. Intervalo de tiempo : dentro determinado intervalo de tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la notificaci\u00f3n cada hora a partir de ahora\"). Calendario : en una determinada fecha (\"a las 8:00 del d\u00eda 20 de abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\"). Localizaci\u00f3n : cuando entre o salga de una determinada regi\u00f3n geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\"). Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta UNNotificationTrigger : UNTimeIntervalNotificationTrigger : Para entregar una notificaci\u00f3n local en cierto momento relativo a al momento actual. Se debe especificar el n\u00famero de segundos que debe pasar antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir un intervalo de repetici\u00f3n. // Fire in 30 minutes (60 seconds times 30) let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : ( 30 * 60 ), repeats : false ) UNCalendarNotificationTrigger : Para especificar una fecha y hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo, para crear un trigger que lanza notificaciones todas las ma\u00f1anas a las 8:30: let date = DateComponents () date . hour = 8 date . minute = 30 let trigger = UNCalendarNotificationTrigger ( dateMatching : date , repeats : true ) UNLocationNotificationTrigger : Para entregar una notificaci\u00f3n cuando el dispositivo entra o abandona una zona geogr\u00e1fica espec\u00edfica. let center = CLLocationCoordinate2D ( latitude : 37.335400 , longitude : - 122.009201 ) let region = CLCircularRegion ( center : center , radius : 2000.0 , identifier : \"Headquarters\" ) region . notifyOnEntry = true region . notifyOnExit = false let trigger = UNLocationNotificationTrigger ( region : region , repeats : false )","title":"Condiciones de disparo de la notificaci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#creacion-de-la-notificacion-local","text":"Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo add del centro de notificaciones compartido: let content = UNMutableNotificationContent () content . title = \"Introducci\u00f3n a Notificaciones\" content . body = \"Hablemos sobre notificaciones!\" content . sound = UNNotificationSound . default () let trigger = UNTimeIntervalNotificationTrigger ( timeInterval : 10 , repeats : false ) let requestIdentifier = \"peticionEjemplo\" let request = UNNotificationRequest ( identifier : requestIdentifier , content : content , trigger : trigger ) UNUserNotificationCenter . current (). add ( request ) { ( error ) in print ( \"Error \\( error ) \" )}","title":"Creaci\u00f3n de la notificaci\u00f3n local"},{"location":"teoria/notificaciones/notificaciones.html#demo","text":"Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo.","title":"Demo"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-app-notificaciones","text":"Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales. Las notificaciones locales se pueden probar en el simulador. Mostramos el funcionamiento de la app y los mensajes que aparecen por la salida est\u00e1ndar. Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo application(_:didFinishLaunchingWithOptions:) de la clase AppDelegate . Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo m\u00e9todo. Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de la app y el de obtenci\u00f3n de los settings de notificaciones.","title":"Ejemplo de app: Notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#acciones","text":"Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones: Botones con t\u00edtulos customizables Entrada de texto Las acciones se crean con la clase UNNotificationAction . Para conseguir una entrada de texto hay que crear un objeto de tipo UNTextInputNotificationAction . El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda UNNotificationCategory que se registra en el UNUserNotificationCenter asociada a un identificador. Una vez creada la categor\u00eda con el conjunto de acciones podemos crear una notificaci\u00f3n que contenga estas acciones inicializando la propiedad categoryIdentifier de la notificaci\u00f3n con la cadena apropiada. La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto , y es la cadena: com.apple.UNNotificationDefaultActionIdentifier .","title":"Acciones"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-codigo-de-creacion-de-una-accion","text":"Para crear las acciones y asociarlas a una categor\u00eda: let action1 = UNNotificationAction ( identifier : \"acepto\" , title : \"Acepto\" , options : []) let action2 = UNNotificationAction ( identifier : \"otro\" , title : \"Otro d\u00eda\" , options : []) // Acci\u00f3n con entrada de texto let action3 = UNTextInputNotificationAction ( identifier : \"mensaje\" , title : \"Mensaje\" , options : [], textInputButtonTitle : \"Enviar\" , textInputPlaceholder : \"Comentario\" ) let category = UNNotificationCategory ( identifier : \"invitacion\" , actions : [ action1 , action2 , action3 ], intentIdentifiers : [], options : []) UNUserNotificationCenter . current (). setNotificationCategories ([ category ]) Para asignar las acciones a la notificaci\u00f3n se asigna el identificador de la categor\u00eda. content . categoryIdentifier = \"invitacion\" La notificaci\u00f3n creada tiene el siguiente aspecto:","title":"Ejemplo de c\u00f3digo de creaci\u00f3n de una acci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#manejo-de-notificaciones","text":"Una vez que el usuario ha pulsado una acci\u00f3n de la notificaci\u00f3n o la ha abierto nuestra app debe gestionar esa acci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n . Para ello debemos implementar los m\u00e9todos del protocolo UNUserNotificationCenterDelegate . userNotificationCenter(_:didReceive:withCompletionHandler:) : se llama cuando la app est\u00e1 en segundo plano y el usuario interact\u00faa con la notificaci\u00f3n. userNotificationCenter(_:willPresent:withCompletionHandler:) : se llama cuando la app est\u00e1 en primer plano y se recibe la notificaci\u00f3n. Estos m\u00e9todos se suelen implementar en el propio AppDelegate , que cumple este protocolo. Y se debe asignar al centro de notificaciones en los m\u00e9todos application(_:willFinishLaunchingWithOptions:) o application(_:didFinishLaunchingWithOptions:) . Por ejemplo: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { ... UNUserNotificationCenter . current (). delegate = self ... }","title":"Manejo de notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#app-en-segundo-plano","text":"Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema. Si es una notificaci\u00f3n local el usuario puede interactuar con las acciones de la notificaci\u00f3n o pulsar la opci\u00f3n de Abrir . En ambos casos se llama al m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) con la informaci\u00f3n de la opci\u00f3n seleccionada por el usuario. Si el usuario ha seleccionado una acci\u00f3n la aplicaci\u00f3n no pasa a primer plano. Sin embargo, si el usuario ha decidido abrir la notificaci\u00f3n, la aplicaci\u00f3n pasa a primer plano, ejecut\u00e1ndose el m\u00e9todo de ciclo de vida applicationWillEnterForeground del UIApplicationDelegate antes del m\u00e9todo userNotificationCenter(_:didReceive:withCompletionHandler:) . Podemos recuperar informaci\u00f3n contenida en la notificaci\u00f3n accediendo al content del request de la notificaci\u00f3n recibida. Si la notificaci\u00f3n es una notificaci\u00f3n remota se llama al m\u00e9todo application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del UIApplicationDelegate (lo veremos m\u00e1s adelante). Un ejemplo del c\u00f3digo en el que se gestiona la notificaci\u00f3n recibida: func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () -> Void ) { // Get the meeting ID from the original notification. let userInfo = response . notification . request . content . userInfo if response . notification . request . content . categoryIdentifier == \"MEETING_INVITATION\" { // Retrieve the meeting details. let meetingID = userInfo [ \"MEETING_ID\" ] as ! String let userID = userInfo [ \"USER_ID\" ] as ! String switch response . actionIdentifier { case \"ACCEPT_ACTION\" : sharedMeetingManager . acceptMeeting ( user : userID , meetingID : meetingID ) break case \"DECLINE_ACTION\" : sharedMeetingManager . declineMeeting ( user : userID , meetingID : meetingID ) break case UNNotificationDefaultActionIdentifier , UNNotificationDismissActionIdentifier : // Queue meeting-related notifications for later // if the user does not act. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) break default : break } } else { // Handle other notification types... } // Always call the completion handler when done. completionHandler () } Si el usuario pulsa en la propia notificaci\u00f3n (no en una opci\u00f3n) el identificador de la acci\u00f3n seleccionada ser\u00e1 com.apple.UNNotificationDefaultActionIdentifier , el contenido de la constante UNNotificationDefaultActionIdentifier .","title":"App en segundo plano"},{"location":"teoria/notificaciones/notificaciones.html#app-en-primer-plano","text":"En el protocolo se define la funci\u00f3n userNotificationCenter(_:willPresent:withCompletionHandler:) a la que el sistema llama cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos. Un ejemplo de c\u00f3digo: func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) -> Void ) { if notification . request . content . categoryIdentifier == \"MEETING_INVITATION\" { // Retrieve the meeting details. let meetingID = notification . request . content . userInfo [ \"MEETING_ID\" ] as ! String let userID = notification . request . content . userInfo [ \"USER_ID\" ] as ! String // Add the meeting to the queue. sharedMeetingManager . queueMeetingForDelivery ( user : userID , meetingID : meetingID ) // Play a sound to let the user know about the invitation. completionHandler (. sound ) return } else { // Handle other notification types... } // Don't alert the user for other types. completionHandler ( UNNotificationPresentationOptions ( rawValue : 0 )) }","title":"App en primer plano"},{"location":"teoria/notificaciones/notificaciones.html#demo_1","text":"Probamos y examinamos el c\u00f3digo de la aplicaci\u00f3n de prueba que incluye acciones en la notificaci\u00f3n y que define las funciones de gesti\u00f3n de las notificaciones. Probamos a seleccionar distintas acciones y comprobar qu\u00e9 mensaje aparece por la salida est\u00e1ndar:","title":"Demo"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-remotas-push","text":"","title":"Notificaciones remotas (push)"},{"location":"teoria/notificaciones/notificaciones.html#objetivos-de-las-notificaciones-remotas","text":"La app tiene un componente server-side en el que se detecta que ha sucedido algo interesante para el usuario. La notificaci\u00f3n remota permite enviar la informaci\u00f3n desde el servicio directamente al usuario. Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. El env\u00edo de notificaciones se hace a trav\u00e9s del APNs ( Apple Push Notification service ).","title":"Objetivos de las notificaciones remotas"},{"location":"teoria/notificaciones/notificaciones.html#arquitectura-de-las-notificaciones-remotas","text":"El servicio Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X. Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente. Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible. Las notificaciones se originan en servidores ( proveedores ) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos.","title":"Arquitectura de las notificaciones remotas"},{"location":"teoria/notificaciones/notificaciones.html#arquitectura-de-seguridad","text":"No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos. El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor y el servicio. Seguridad en la conexi\u00f3n Proveedor-APNs Basada en JWT (JSON web tokens) o basada en un certificado. Utilizaremos la seguridad basada en un certificado, obteni\u00e9ndolo en el member center y us\u00e1ndolo para que el APNs conf\u00ede en los mensajes que recibe del proveedor. Seguridad en la conexi\u00f3n APNs-Dispositivo Basada en un token de dispositivo (\u00fanico para cada dispositivo y encriptado con su clave privada) que env\u00eda el APNs al dispositivo y que debe estar presente en cada petici\u00f3n del proveedor al APNs.","title":"Arquitectura de seguridad"},{"location":"teoria/notificaciones/notificaciones.html#secuencia-de-registro-del-dispositivo","text":"Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase Application registerForRemoteNotifications() son los siguientes: El dispositivo establece una conexi\u00f3n SSL con el APNs. El APNs le env\u00eda un token \u00fanico asociado con el dispositivo. El dispositivo le env\u00eda el token al app. El app env\u00eda el token a su servidor ( Provider ) para que lo utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n realizada al APNs.","title":"Secuencia de registro del dispositivo"},{"location":"teoria/notificaciones/notificaciones.html#token-del-dispositivo","text":"Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo. Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas. El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado application:didRegisterForRemoteNotificationsWithDeviceToken: . Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo.","title":"Token del dispositivo"},{"location":"teoria/notificaciones/notificaciones.html#envio-de-notificacion-remota-usando-el-token","text":"Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, incluye el token del dispositivo. El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino. Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado.","title":"Env\u00edo de notificaci\u00f3n remota usando el token"},{"location":"teoria/notificaciones/notificaciones.html#contenido-de-la-notificacion_1","text":"Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n. El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple . El tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes y debe tener el formato de un objeto JSON diccionario (parejas clave, valor). Un ejemplo en JSON: { \"aps\" : { \"alert\" : { \"title\" : \"Introducci\u00f3n a las notificaciones\" , \"subtitle\" : \"Sesi\u00f3n 707\" , \"body\" : \"La nueva API de notificaciones es genial!!!\" , \"category\" : \"mensaje\" , }, \"badge\" : 1 }, } El diccionario debe contener otro diccionario identificado por la clave aps . Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n: - Mensaje de alerta a mostrar al usuario - Numero a a\u00f1adir en el globo del icono de la app - Sonido a tocar El diccionario aps tambi\u00e9n puede tener la clave content-available con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. En este caso es conveniente no mostrar al usuario ninguna notificaci\u00f3n. El contenido nuevo se ver\u00e1 la siguiente vez que se abra la app. El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom . La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro userInfor en el m\u00e9todo didReceiveRemoteNotification del delegado del app. Otros ejemplos de payload . N\u00famero en el badge y custom keys : { \"aps\" : { \"alert\" : \"You got your emails.\" , \"badge\" : 9 , \"sound\" : \"bingbong.aiff\" }, \"acme1\" : \"bar\" , \"acme2\" : 42 } Notificaci\u00f3n silenciosa: { \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\" , \"acme2\" : 42 } Notificaci\u00f3n con cadenas localizadas: { \"aps\" : { \"alert\" : { \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\" , \"loc-args\" : [ \"Jenna\" , \"Frank\" ] }, \"sound\" : \"chime.aiff\" }, \"acme\" : \"foo\" } Notificaci\u00f3n con acciones: { \"aps\" : { \"alert\u201d : { \u201cbody\u201d : \" Acme message received fr om Joh nn y Appleseed\u201d , \u201cac t io n - loc - key\u201d : \u201cVIEW\u201d , \"actions\" : [ { \u201cid \" : \u201cdelete\" , \"title\" : \"Delete\" }, { \u201cid \" : \u201creply-to\u201d, \" loc - key \" : \u201cREPLYTO\u201d, \" loc - args \" : [\u201cJane\" ] } ] } \"badge\" : 3 , \"sound\" : \u201cchime.ai ff \" }, \" acme - accou nt \" : \" ja ne .appleseed@apple.com \", \" acme - message \" : \" message 123456 \" }","title":"Contenido de la notificaci\u00f3n"},{"location":"teoria/notificaciones/notificaciones.html#servidores-proveedores","text":"Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida por Apple basada en un protocolo HTTP/2 y TLS. Es posible montar un servidor propio usando librer\u00edas ya existentes. Por ejemplo, en Java existe la librer\u00eda Pushy . Es recomendable consultar la documentaci\u00f3n de Apple Setting Up a Remote Notification Server y Sending Notification Requests to APNs . La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones: Firebase Cloud Messaging for iOS Amazon Web Services Microsoft Azure Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es usar un script PHP desde el terminal. En cualquier caso nuestro servidor deber\u00e1 conectarse al APNs usando una t\u00e9cnica segura: o bien un certificado proporcionado por Apple (es lo que haremos en la demostraci\u00f3n) o bien un token, usando JWT (JSON Web Token). Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"Servidores proveedores"},{"location":"teoria/notificaciones/notificaciones.html#gestion-de-las-notificaciones-remotas-en-la-app","text":"","title":"Gesti\u00f3n de las notificaciones remotas en la app"},{"location":"teoria/notificaciones/notificaciones.html#capacidad-de-notificacion-remota","text":"La app debe tener el permiso de usar las notificaciones remotas. Debe usar un perfil de aprovisionamiento con un App ID que otorgue ese permiso. Se puede hacer desde Xcode o desde el la web de desarrollador. En la demostraci\u00f3n lo haremos desde la web del programa de desarrollo de la universidad.","title":"Capacidad de notificaci\u00f3n remota"},{"location":"teoria/notificaciones/notificaciones.html#registro-de-las-notificaciones","text":"Para que una app trabaje con notificaciones remotas lo primero que debe hacerse, al igual que con las notificaciones locales, es pedir permiso al usuario. La forma de hacerlo es id\u00e9ntica a las de las notificaciones locales, usando el m\u00e9todo requestAuthorization(options:completionHandler:) . Una vez hecho esto, hay que conseguir el token asociado al dispositivo y la app registr\u00e1ndose en el Apple Push Notification service (APNs). Lo hace el m\u00e9todo registerForRemoteNotifications del objeto application. Se trata de un m\u00e9todo as\u00edncrono. Si el registro en el servicio tiene \u00e9xito, la app llama al m\u00e9todo application(_:didRegisterForRemoteNotificationsWithDeviceToken:) del delegado de la aplicaci\u00f3n pasando el token asignado que habr\u00e1 que incluir en las notificaciones que enviemos al dispositivo. Ejemplo de c\u00f3digo de registro de las notificaciones remotas: func application ( _ application : UIApplication , didFinishLaunchingWithOptions launchOptions : [ UIApplicationLaunchOptionsKey : Any ]?) -> Bool { UNUserNotificationCenter . current (). requestAuthorization ( options : [. alert , . sound , . badge ]) { ( granted , error ) in print ( granted )} application . registerForRemoteNotifications () UNUserNotificationCenter . current (). delegate = self return true } Ejemplo de obtenci\u00f3n del token e impresi\u00f3n en la consola: func application ( _ application : UIApplication , didRegisterForRemoteNotificationsWithDeviceToken deviceToken : Data ) { var token = \"\" for i in 0. .< deviceToken . count { token = token + String ( format : \"%02.2hhx\" , arguments : [ deviceToken [ i ]]) } print ( token ) } func application ( _ application : UIApplication , didFailToRegisterForRemoteNotificationsWithError error : Error ) { print ( \"Failed to register:\" , error ) }","title":"Registro de las notificaciones"},{"location":"teoria/notificaciones/notificaciones.html#recepcion-de-las-notificaciones-en-la-app","text":"La gesti\u00f3n de las notificaciones recibidas es id\u00e9ntica a la ya vista en notificaciones locales, us\u00e1ndose exactamente los mismos manejadores, con la excepci\u00f3n de la posibilidad de gestionar notificaciones remotas cuando la app est\u00e1 en segundo plano. Recordemos los manejadores que ya vimos en las notificaciones locales: Si la app est\u00e1 en primer plano se llama al metodo userNotificationCenter(willPresent:withCompletionHandler:) del UNUserNotificationCenterDelegate cuando llega la notificaci\u00f3n. Si la app est\u00e1 en segundo plano y el usuario pulsa en la notificaci\u00f3n o en una de sus acciones se llama a userNotificationCenter(_:didReceive:withCompletionHandler:) del UNUserNotificationCenterDelegate . La diferencia de las notificaciones remotas es la posibilidad de definir el manejador application(_:didReceiveRemoteNotification:fetchCompletionHandler:) del delegado del app, que se activa cuando llega una notificaci\u00f3n remota que contiene la clave content-available con el valor 1 : { \"aps\" : { \"content-available\" : 1 }, \"acme1\" : \"bar\", \"acme2\" : 42 } Para que se llame al m\u00e9todo se debe activar la capability Background Modes > Remote Notifications en Xcode. El m\u00e9todo se llama tanto si la app est\u00e1 en primer plano como si est\u00e1 en segundo plano. De hecho, es recomendable usarlo \u00fanicamente para gestionar notificaciones silenciosas que no se muestran al usuario sino que se usan para que la app pueda recuperar informaci\u00f3n del servidor que se mostrar\u00e1 la siguiente vez que el usuario lance la app. Por ello habr\u00eda que enviar un payload como el que hemos visto anteriormente. Con custom keys pero en el que el diccionario aps no contenga ninguna clave que disparare una interacci\u00f3n con el usuario.","title":"Recepci\u00f3n de las notificaciones en la app"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-app","text":"Ejemplo de app que usaremos para demostrar las notificaciones remotas: C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando la app est\u00e1 en primer plano : func userNotificationCenter ( _ center : UNUserNotificationCenter , willPresent notification : UNNotification , withCompletionHandler completionHandler : @ escaping ( UNNotificationPresentationOptions ) -> Void ) { print ( \"Recibida notificaci\u00f3n primer plano\" ) let aps = notification . request . content . userInfo [ \"aps\" ] as ! [ String : AnyObject ] if let news = aps [ \"alert\" ] as ? String { createNewNewsItem ( text : news ) } // No mostramos la notificaci\u00f3n completionHandler ([]) } C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando ha sido accionada por el usuario : func userNotificationCenter ( _ center : UNUserNotificationCenter , didReceive response : UNNotificationResponse , withCompletionHandler completionHandler : @ escaping () -> Void ) { print ( \"Usuario ha pulsado una notificaci\u00f3n\" ) let aps = response . notification . request . content . userInfo [ \"aps\" ] as ! [ String : AnyObject ] if let news = aps [ \"alert\" ] as ? String { createNewNewsItem ( text : news ) } completionHandler () } C\u00f3digo de gesti\u00f3n de una notificaci\u00f3n silenciosa : func application ( _ application : UIApplication , didReceiveRemoteNotification userInfo : [ AnyHashable : Any ], fetchCompletionHandler completionHandler : @ escaping ( UIBackgroundFetchResult ) -> Void ) { print ( \"Recibida notificaci\u00f3n remota en background\" ) createNewNewsItem ( text : \"Notificaci\u00f3n silenciosa\" ) completionHandler ( UIBackgroundFetchResult . newData ) }","title":"Ejemplo de app"},{"location":"teoria/notificaciones/notificaciones.html#demo_2","text":"","title":"Demo"},{"location":"teoria/notificaciones/notificaciones.html#pasos-necesarios-para-la-demo","text":"En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real. Podremos enviar notificaciones a este dispositivo real utilizando un script en PHP que tendremos que configurar con: Certificado SSL autorizado por el APNs para enviar notificaciones Token del dispositivo al que se env\u00eda la notificaci\u00f3n. Necesitaremos crear en el member center un App ID y configurar: Certificado SSL para autentificar el proveedor de notificaciones frente al APNs. Perfil de aprovisionamiento con la capacidad de notificaci\u00f3n push.","title":"Pasos necesarios para la demo"},{"location":"teoria/notificaciones/notificaciones.html#nuevo-app-id-en-el-member-center","text":"Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n. Se debe a\u00f1adir en el App ID la autorizaci\u00f3n de notificaciones push.","title":"Nuevo App ID en el member center"},{"location":"teoria/notificaciones/notificaciones.html#creacion-del-certificado-ssl-en-el-member-center","text":"Debemos obtener un certificado de una autoridad de certificaci\u00f3n que despu\u00e9s subiremos al member center . Abrimos Acceso a Llaveros y seleccionamos Acceso a Llaveros > Asistente de Certificados > Solicitar un certificado de una autoridad de certificaci\u00f3n . Salvamos el fichero CertificateSigningRequest.certSigningRequest . Para crear el certificado es necesario subir el fichero generado previamente CertificateSigningRequest.certSigningRequest","title":"Creaci\u00f3n del certificado SSL en el member center"},{"location":"teoria/notificaciones/notificaciones.html#generacion-del-fichero-pem","text":"Una vez creado el certificado en el Member Center lo descargamos y lo instalamos en Acceso a llaveros. Lo exportamos como fichero .p12 y despu\u00e9s lo convertiremos en un fichero .pem con el que nuestro servidor establecer\u00e1 la conexi\u00f3n SSL con el APNs: Se guarda el certificado como UADevelopmentPushCertificate.p12 con una contrase\u00f1a (mastermoviles20) Creamos el fichero .pem con el siguiente comando: $ openssl pkcs12 -in UADevelopmentPushCertificate.p12 \\ -out UADevelopmentPushCertificate.pem -nodes -clcerts Nos pedir\u00e1 la contrase\u00f1a que hemos introducido antes y se generar\u00e1 el certificado UADevelopmentPushCertificate.pem . Una vez hecho esto, ya tendremos listo el certificado para enviar la notificaci\u00f3n push al APNs, usando el script PHP.","title":"Generaci\u00f3n del fichero .pem"},{"location":"teoria/notificaciones/notificaciones.html#creacion-del-perfil-de-aprovisionamiento","text":"Creamos un nuevo perfil de aprovisionamiento que podr\u00e1n usar todos los miembros del equipo.","title":"Creaci\u00f3n del perfil de aprovisionamiento"},{"location":"teoria/notificaciones/notificaciones.html#obtencion-del-token-del-dispositivo","text":"Ya hemos obtenido el certificado SSL que utilizaremos en el script PHP para enviar las notificaciones al APNs. Necesitamos obtener el token del dispositivo y de la app que va a recibir la notificaci\u00f3n. Para ello debemos ejecutar la app en un dispositivo f\u00edsico (no funciona en el simulador).","title":"Obtenci\u00f3n del token del dispositivo"},{"location":"teoria/notificaciones/notificaciones.html#probamos-la-app-notificacionespush","text":"Descargamos el proyecto NotificacionesPush desde este enlace . Contiene la app y los scripts PHP para enviar las notificaciones al APNs. La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push: Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador. Anotamos el token del dispositivo que aparece en la consola al ejecutar la app por primera vez.","title":"Probamos la app NotificacionesPush"},{"location":"teoria/notificaciones/notificaciones.html#probamos-a-enviar-notificaciones-remotas-al-dispositivo","text":"Descargamos desde este enlace el certificado SSL UADevelopmentPushCertificatepem que hemos generado y lo guardamos en el mismo directorio Scripts en el que se encuentra el script apnspush.php . Editamos el script apnspush.php (en el directorio Scripts ) y modificamos en la l\u00ednea 4 el $deviceToken . Escribimos el token que ha aparecido en la consola y que puedes copiar de este enlace . Este token identifica el dispositivo al que el APNs enviar\u00e1 la notificaci\u00f3n. Llama al script para crear una notificaci\u00f3n remota en el dispositivo: $ php apnspush.php 'Hola mundo desde la UA' Connected to APNS Message successfully delivered","title":"Probamos a enviar notificaciones remotas al dispositivo"},{"location":"teoria/notificaciones/notificaciones.html#bibliografia","text":"Framework UserNotifications Asking Permission to Use Notifications Scheduling a Notification Locally from Your App Handling Notifications and Notification-Related Actions Registering Your App with APNs Generating a Remote Notification Pushing Updates to Your App Silently Setting Up a Remote Notification Server Establishing a Certificate-Based Connection to APNs Establishing a Token-Based Connection to APNs","title":"Bibliograf\u00eda"}]}